/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { parseTemplate } from "url-template";
export const urlTemplateHandler = async (inputs) => {
    const { template, ...values } = inputs;
    const url = parseTemplate(template).expand(values);
    return { url };
};
const operators = [
    { prefix: "+", description: "reserved expansion" },
    { prefix: "#", description: "fragment expansion" },
    { prefix: ".", description: "label expansion, dot-prefixed" },
    { prefix: "/", description: "path segment expansion" },
    { prefix: ";", description: "path-style parameter expansion" },
    { prefix: "?", description: "form-style query expansion" },
    { prefix: "&", description: "form-style query continuation" },
];
export const getUrlTemplateParameters = (template) => {
    if (!template)
        return [];
    const matches = [...template.matchAll(/{([^{}]+)\}|([^{}]+)/g)];
    return matches
        .map((match) => match[1])
        .filter(Boolean)
        .map((name) => {
        const prefix = name.charAt(0);
        const operator = operators.find((op) => op.prefix === prefix);
        if (operator) {
            return { name: name.slice(1), operator };
        }
        return { name };
    });
};
export const computeInputSchema = (template) => {
    const parameters = getUrlTemplateParameters(template);
    const properties = parameters.reduce((acc, { name, operator }) => {
        const description = operator?.description
            ? `Value for ${operator.description} placeholder "${name}"`
            : `Value for placeholder "${name}"`;
        acc[name] = {
            title: name,
            description,
            type: "string",
        };
        return acc;
    }, {
        template: {
            title: "template",
            description: "The URL template to use",
            type: "string",
        },
    });
    return {
        type: "object",
        properties,
        required: ["template", ...parameters.map(({ name }) => name)],
    };
};
export const urlTemplateDescriber = async (inputs) => {
    const { template } = (inputs || {});
    return {
        inputSchema: computeInputSchema(template),
        outputSchema: {
            type: "object",
            properties: {
                url: {
                    title: "url",
                    description: "The resulting URL that was produced by filling in the placeholders in the template",
                    type: "string",
                },
            },
            required: ["url"],
        },
    };
};
export default {
    describe: urlTemplateDescriber,
    invoke: urlTemplateHandler,
};
//# sourceMappingURL=url-template.js.map