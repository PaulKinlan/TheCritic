/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const t="stream";class e{kind=t;stream;constructor(t){this.stream=t}}const r=e=>{const r=[];return{value:JSON.stringify(e,((e,s)=>(e=>{const r=e;return r&&r.kind&&r.kind===t&&r.stream instanceof ReadableStream})(s)?(r.push(s.stream),{$type:"Stream",id:r.length-1}):s)),streams:r}},s=(t,r)=>{const s=JSON.parse(t,((t,s)=>"object"==typeof s&&null!==s&&"Stream"===s.$type&&"number"==typeof s.id?new e(r(s.id)):s));return s},n=t=>{const e=r(t).value;return s(e,(()=>new ReadableStream))},a=t=>({readable:new ReadableStream({start(e){t.onmessage=t=>{null!==t.data?e.enqueue(t.data):e.close()}},cancel(){t.onmessage=null}}),writable:new WritableStream({write(e){const s=r(e);t.postMessage(e,s.streams)},close(){t.postMessage(null,[])}})});class o{#t;data;constructor(t,e){this.#t=e,this.data=t}async reply(t){await this.#t.write(t)}}class i{#e;#t;constructor(t,e){this.#e=e.getReader(),this.#t=t.getWriter()}async next(){const{done:t,value:e}=await this.#e.read();return t?(this.#t.close(),{done:t,value:void 0}):{done:!1,value:new o(e,this.#t)}}async return(){return this.#t.close(),{done:!0,value:void 0}}async throw(t){return this.#t.abort(t),{done:!0,value:void 0}}}const u=(t,e)=>({async start(e){const r=t.getWriter();await r.write(e),r.releaseLock()},[Symbol.asyncIterator]:()=>new i(t,e)}),c=()=>{ReadableStream.prototype[Symbol.asyncIterator]||(ReadableStream.prototype[Symbol.asyncIterator]=async function*(){const t=this.getReader();try{for(;;){const{done:e,value:r}=await t.read();if(e)return;yield r}}finally{t.releaseLock()}})};class p{#r;#s;constructor(t,e){this.#r=t,this.#s=e}createServerStream(){const t=this.#r,e=this.#s;return c(),e.header("Content-Type","text/event-stream"),{readableRequests:new ReadableStream({start(e){var r;"object"==typeof(r=t.body)&&null!==r&&Symbol.iterator in r?(e.enqueue(t.body),e.close()):e.error(new Error("Unexpected uniterable body. This is likely a result of processing a GET request. Only POST requests are supported."))}}),writableResponses:new WritableStream({async write(t){const s=r(t);if(e.write(`data: ${s.value}\n\n`),s.streams.length){if(s.streams.length>1)throw new Error("HTTPServerTransport does not support multiple streams at the moment.");const t=s.streams[0];await t.pipeTo(new WritableStream({write(t){const r=["http-stream-chunk",{chunk:t}];e.write(`data: ${JSON.stringify(r)}\n\n`)},close(){e.write(`data: ${JSON.stringify(["http-stream-end",{}])}\n\n`)}}))}},close(){e.end()}})}}}class l{#n;#a;#o;constructor(t,e){this.#n=t,this.#a={...e,method:"POST",headers:{"Content-Type":"application/json"}},this.#o=this.#a.fetch??globalThis.fetch.bind(globalThis)}createClientStream(){let t;const e=new Promise((e=>{t=e})),r=this;return{readableResponses:new ReadableStream({async pull(t){const r=(await e).getReader();for(;;){const e=await r.read();if(e.done)break;console.log("%cServer-Sent Event Chunk","background: #009; color: #FFF",e.value),t.enqueue(e.value)}t.close()}}),writableRequests:new WritableStream({async write(e,n){if(!t)throw new Error("HTTPClientTransport supports only one write per stream instance.");const a=await r.#o(r.#n,{...r.#a,body:JSON.stringify(e)});a.ok||n.error(new Error(`HTTP error: ${a.status}`)),t(a.body?.pipeThrough(new TextDecoderStream).pipeThrough((()=>{let t=[];return new TransformStream({transform(e,r){const s=!e.endsWith("\n"),n=e.split("\n").filter(Boolean);for(t.length&&!s&&(r.enqueue(`${t.join("")}${n.shift()}`),t=[]);n.length>1;)r.enqueue(n.shift());const a=n.shift();a&&(s?t.push(a):r.enqueue(a))},flush(){if(t.length)throw new Error("Unexpected end of stream.")}})})()).pipeThrough(new TransformStream({transform(t,e){t.startsWith("data: ")&&e.enqueue(t.slice(6))}})).pipeThrough((()=>{const t=new TransformStream,e=t.writable.getWriter();return new TransformStream({transform(r,n){const a=s(r,(e=>{if(0!==e)throw new Error("HTTPClientTransport does not support multiple streams at the moment.");return t.readable})),[o]=Array.isArray(a)?a:[];"http-stream-chunk"===o?e.write(a[1].chunk):"http-stream-end"===o?e.close():n.enqueue(a)}})})())),t=void 0}})}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const h="port-dispatcher-sendport";class d{#i;#u=new Map;#c=new Map;constructor(t){this.#i=t,this.#i.addEventListener("message",(t=>{const{type:e,id:r,port:s}=t.data;if(e!==h)return;const n=this.#u.get(r);n?(n(s),this.#u.delete(r)):this.#c.set(r,s)}))}receive(t){const e=this.#c.get(t);return e?(this.#c.delete(t),a(e)):(t=>{let e;const r=new Promise((r=>{t().then((t=>{e=a(t),r()}))}));return{readable:new ReadableStream({async start(){await r},pull:t=>e.readable.pipeTo(new WritableStream({write(e){t.enqueue(e)}})),cancel(){e.readable.cancel()}}),writable:new WritableStream({async start(){await r},async write(t){const r=e.writable.getWriter();await r.write(t),r.releaseLock()},async close(){await e.writable.close()},async abort(t){await e.writable.abort(t)}})}})((()=>new Promise((e=>{this.#u.set(t,e)}))))}send(t){const{port1:e,port2:r}=new MessageChannel;return this.#i.postMessage({type:h,id:t,port:r},[r]),a(e)}}class w{#e;#t;constructor(t){this.#e=t.readable.getReader(),this.#t=t.writable.getWriter()}createClientStream(){return{writableRequests:(e=this.#t,new WritableStream({write:async t=>e.write(t)},{highWaterMark:0})),readableResponses:(t=this.#e,new ReadableStream({async pull(e){const{value:r,done:s}=await t.read();s?e.close():e.enqueue(r)}},{highWaterMark:0}))};var t,e}}class m{#p;constructor(t){this.#p=t}createServerStream(){return{readableRequests:this.#p.readable,writableResponses:this.#p.writable}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const f=async(t,e,r)=>{const s=(t=>{if(t instanceof Function)return t;if(t.invoke)return t.invoke;throw new Error("Invalid handler")})(t);return new Promise((t=>{s(e,r).then(t).catch((e=>{t({$error:{error:e}})}))}))};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class y{url;title;description;version;namespacePrefix;constructor({title:t,description:e,version:r,url:s,namespacePrefix:n=""}){this.url=s,this.title=t,this.description=e,this.version=r,this.namespacePrefix=n}#l(t){return Object.keys(t).reduce(((e,r)=>(e[`${this.namespacePrefix}${r}`]=t[r],e)),{})}build(t){if(!this.url)throw new Error("Builder was not yet initialized.");const e=this.url,r=this.namespacePrefix,{title:s,description:n,version:a}=this,o=this.#l(t),i=Object.keys(t);return class{title=s;description=n;version=a;url=e;get handlers(){return o}constructor(t){const e=new Proxy(this,{get:(s,n)=>"handlers"===n||"url"===n?s[n]:i.includes(n)?(s={})=>{const a=t.getConfigWithLambda(s),{$id:o,...i}=a;return t.create(e,`${r}${n}`,{...i},o)}:void 0});return e}}}static wrap(t,e){const r=Object.entries(e).reduce(((t,e)=>{const[r,s]=e;return t[r]={invoke:async t=>{let e=[];s&&s.length>0&&(e=s.toString().match(/\((.+?)\)/)?.[1].split(",")??[],s.length>1&&0===e.length&&"___args"in t&&Array.isArray(t.___args)&&(e=["___args"]));for(const r of e)if(r.trim()in t==!1)throw new Error(`Missing input: ${r.trim()}. Valid inputs are: ${Object.keys(t).join(", ")}`);const r=e.filter((t=>0==t.startsWith("___"))).map((e=>t[e.trim()])),n=e[e.length-1];null!=n&&n.startsWith("___")&&r.push(...t[n]);const a=await s(...r);return"object"!=typeof a||Array.isArray(a)?{result:a}:{...a}}},t}),{});return new y(t).build(r)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const g=globalThis.process?t=>Buffer.from(t,"base64").toString("binary"):globalThis.atob,b=globalThis.process?t=>Buffer.from(t,"binary").toString("base64"):globalThis.btoa;class S{outputName;from;to;when;constructor(t,e,r,s={}){this.outputName=t,this.from=e,this.to=r,this.when=s}getInputNames(){const t=Object.keys(this.when);return 0===t.length?[this.outputName]:t}matches(t){return Object.entries(this.when).every((([e,r])=>{const s=t[e];return"string"==typeof r?s===r:"string"==typeof s&&r.test(s)}))}}const v=(t,e)=>Object.fromEntries(Object.entries(e).map((([e,r])=>"string"==typeof r?[e,[new S(e,t,r)]]:Array.isArray(r)?[e,r.map((r=>"string"==typeof r?new S(e,t,r):new S(e,t,r.to,r.when)))]:[e,[new S(e,t,r.to,r.when)]]))),O=Math.round(Date.now()/6048e5).toString(36),$=`T-${O}-`,E=`-${O}-T`,k=new RegExp(`(${$}.*?${E})`,"gm"),R=new RegExp(`^${$}(.+?)${E}$`),T=async(t,e,r)=>{const s=JSON.stringify(t),n=s.split(k).filter(Boolean).map((t=>{const e=t.match(R);if(e){const t=e[1].split("~"),[r,s,n]=t;return{nodeType:r,outputName:s,inputs:g(n)}}return{value:t}}));const a=await Promise.all(n.map((async t=>{if("inputs"in t){const s=JSON.parse(t.inputs),{nodeType:n,outputName:a}=t,o=e?await r(n,s):{[a]:"VALUE_BLOCKED"};if(!o)return"";let i=JSON.stringify(o[a]);return i.startsWith('"')&&(i=i.slice(1,-1)),i=JSON.stringify(i),i.slice(1,-1)}return t.value})));return JSON.parse(a.join(""))},x=(t,e)=>{const r=Object.fromEntries(Object.entries(e).map((([e,r])=>{const s=t[e];return s?[e,async(t,n)=>((t,e,r)=>{if(t)return Object.fromEntries(Object.entries(t).map((([t,s])=>t in e?[t,r(t,s)]:[t,s])))})(await f(r,t,n),s,(r=>((t,e,r)=>{const s=b(JSON.stringify(r)).replace("=","");return`${$}${t}~${e}~${s}${E}`})(e,r,t)))]:[e,r]}))),s=(t=>Object.entries(t).flatMap((([t,e])=>Object.entries(e).flatMap((([t,e])=>e.map((t=>[t.to,t])))))).reduce(((t,[e,r])=>(t[e]||(t[e]=[]),t[e].push(r),t)),{}))(t),n=Object.fromEntries(Object.entries(r).map((([t,r])=>{const n=s[t];return n?[t,async(t,s)=>f(r,await(async(t,e,r)=>{const s=e.some((e=>e.matches(t)));return Object.fromEntries(await Promise.all(Object.entries(t).map((async([t,e])=>[t,await r(e,s)]))))})(t,n,(async(t,r)=>T(t,r,(async(t,r)=>f(e[t],r,s))))),s)]:[t,r]})));return{url:"tunnel-kit",handlers:n}},P=()=>globalThis.performance.now()
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */,j=(t,e=[])=>{const r=e.find((e=>"string"==typeof e?e===t:e.node===t));return"string"==typeof r?{node:r}:r};class q{#h;constructor(t){this.#h=t}async serve(t){const{kits:e}=t,r=this.#h.createServerStream(),s=x((t=>t.proxy?Object.fromEntries(t.proxy.map((t=>{if("string"!=typeof t&&t.tunnel)return[t.node,v(t.node,t.tunnel)]})).filter(Boolean)):{})(t),(t=>t.reduce(((t,e)=>({...e.handlers,...t})),{}))(e)),n=s.handlers;for await(const e of u(r.writableResponses,r.readableRequests)){const[r]=e.data;if("end"===r)break;if("proxy"!==r){e.reply(["error",{error:"Expected proxy request.",timestamp:P()}]);continue}const[,{node:s,inputs:a}]=e.data,o=j(s.type,t.proxy)?n[s.type]:void 0;if(o)try{const t=await f(o,a,{descriptor:s});if(!t){e.reply(["error",{error:"Handler returned nothing.",timestamp:P()}]);continue}e.reply(["proxy",{outputs:t}])}catch(t){e.reply(["error",{error:t.message,timestamp:P()}])}else e.reply(["error",{error:"Can't proxy a node of this node type.",timestamp:P()}])}}}class N{#h;constructor(t){this.#h=t}shutdownServer(){const t=this.#h.createClientStream().writableRequests.getWriter();t.write(["end",{timestamp:P()}]),t.close()}async proxy(t,e){const r=this.#h.createClientStream(),s=r.writableRequests.getWriter(),n=r.readableResponses.getReader();s.write(["proxy",{node:t,inputs:e}]),s.close();const a=await n.read();if(a.done)throw new Error("Unexpected proxy failure: empty response.");const[o]=a.value;if("proxy"===o){const[,{outputs:t}]=a.value;return t}if("error"===o){const[,{error:t}]=a.value;throw new Error(JSON.stringify(t))}throw new Error(`Unexpected proxy failure: unknown response type "${o}".`)}createProxyKit(t=[]){const e=t.map((t=>"string"==typeof t?t:t.node)),r=Object.fromEntries(e.map((t=>[t,{invoke:async(t,e)=>{const r=e.descriptor;return await this.proxy(r,t)}}])));return new(new y({url:"proxy"}).build(r))({create:()=>{throw Error("Node instantiation can't (yet) happen during runtime")}})}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class M extends EventTarget{#d;constructor(t){super(),this.#d=t}async report(t){return this.#d(t)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class I{static computeMissingInputs(t,e,r){const s=[...new Set(t.filter((t=>!!t.in&&!t.optional)).map((t=>t.in||"")))],n=new Set;return Object.keys(e).forEach((t=>n.add(t))),r.configuration&&Object.keys(r.configuration).forEach((t=>n.add(t))),s.filter((t=>!n.has(t)))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class W{state=new Map;constants=new Map;#w(t,e,r,s){let n=t.get(e);n||(n=new Map,t.set(e,n));let a=n.get(r);a||(a=[],n.set(r,a)),a.push(s)}wireOutputs(t,e){if(0!==t.filter((e=>e.from!=t[0].from)).length)throw new Error("All opportunities must be from the same node");t.forEach((t=>{const r=t.to,s=t.out,n=t.constant?this.constants:this.state;if(s)if("*"===s)for(const t in e){const s=e[t];null!=s&&null!=s&&this.#w(n,r,t,s)}else if(t.in){const a=e[s];null!=a&&null!=a&&this.#w(n,r,t.in,a)}}))}getAvailableInputs(t){const e={};for(const r of[this.constants.get(t),this.state.get(t)])if(r)for(const[t,s]of r.entries())0!==s.length&&(e[t]=s[0]);return e}useInputs(t,e){const r=this.state.get(t);if(r)for(const t in e){const e=r.get(t);e&&e.shift()}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class A{descriptor;inputs;missingInputs;opportunities;newOpportunities;state;outputsPromise;pendingOutputs;constructor(t,e,r,s,n,a,o){this.descriptor=t,this.inputs=e,this.missingInputs=r,this.opportunities=s,this.newOpportunities=n,this.state=a,this.pendingOutputs=o}get skip(){return this.missingInputs.length>0}static fromObject(t){const e=new W;return e.constants=t.state.constants,e.state=t.state.state,new A(t.descriptor,t.inputs,t.missingInputs,t.opportunities,t.newOpportunities,e,t.pendingOutputs)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class C{graph;#m;#f;constructor(t,e,r=!0){this.graph=t,this.#m=e,this.#f=r}static#y(t,e){const{promiseId:r,outputs:s,newOpportunities:n}=e;t.pendingOutputs.delete(r);const a=s.$error?n.filter((t=>"$error"===t.out)):n;if(t.opportunities.push(...a),t.state.wireOutputs(a,s),s.$error){if(0===a.length)throw new Error("Uncaught exception in node handler. Catch by wiring up the $error output.",{cause:s.$error});globalThis.console.warn("Error in node handler, passing to the wired $error output.",s.$error,a)}}static async processAllPendingNodes(t){return(await Promise.all(t.pendingOutputs.values())).forEach((e=>{C.#y(t,e)})),t}async next(){if(!this.#m.skip){const{inputs:t,outputsPromise:e,newOpportunities:r,descriptor:s}=this.#m;this.#m.state.useInputs(s.id,this.#m.inputs);const n=Symbol(),a=new Promise((a=>{(e||Promise.resolve({})).then((e=>{if(e.$error){const r=e.$error;e.$error={descriptor:s,...r,inputs:{...t,...r.inputs}}}a({promiseId:n,outputs:e,newOpportunities:r})})).catch((e=>{a({promiseId:n,outputs:{$error:{kind:"error",error:e,inputs:t,descriptor:s}},newOpportunities:r.filter((t=>"$error"===t.out))})}))}));this.#m.pendingOutputs.set(n,a)}for(;(0===this.#m.opportunities.length||this.#f)&&this.#m.pendingOutputs.size>0;)C.#y(this.#m,await Promise.race(this.#m.pendingOutputs.values()));if(0===this.#m.opportunities.length)return{done:!0,value:null};const t=this.#m.opportunities.shift(),{heads:e,nodes:r,tails:s}=this.graph,n=t.to,a=r.get(n);if(!a)throw new Error(`No node found for id "${n}"`);const o=e.get(n)||[],i=this.#m.state.getAvailableInputs(n),u=I.computeMissingInputs(o,i,a),c=s.get(n)||[],p={...a.configuration,...i};return this.#m=new A(a,p,u,this.#m.opportunities,c,this.#m.state,this.#m.pendingOutputs),{done:!1,value:this.#m}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class _{tails=new Map;heads=new Map;nodes=new Map;entries=[];constructor(t){this.tails=t.edges.reduce(((t,e)=>{const r=e.from;return t.has(r)?t.get(r)?.push(e):t.set(r,[e]),t}),new Map),this.heads=t.edges.reduce(((t,e)=>{const r=e.to;return t.has(r)?t.get(r)?.push(e):t.set(r,[e]),t}),new Map),this.nodes=t.nodes.reduce(((t,e)=>(t.set(e.id,e),t)),new Map),this.entries=Array.from(this.tails.keys()).filter((t=>!this.heads.has(t)||0===this.heads.get(t)?.length))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class J{graph;previousResult;constructor(t,e){this.graph=new _(t),this.previousResult=e}[Symbol.asyncIterator](){return this.start()}start(){if(this.previousResult)return new C(this.graph,this.previousResult);const{entries:t}=this.graph;if(0===t.length)throw new Error("No entry node found in graph.");const e=t.map((t=>({from:"$entry",to:t}))),r=new A({id:"$empty",type:"$empty"},{},[],e,[],new W,new Map);return new C(this.graph,r)}static async prepareToSave(t){return await C.processAllPendingNodes(t)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const F=(t,e)=>e instanceof Map?{$type:"Map",value:Array.from(e.entries())}:e,L=(t,e)=>{const{$type:r}=e||{};return"Map"==r&&e.value?new Map(e.value):e};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class B{#g;#b;#S;#v;constructor(t,e,r,s){this.#b=t,this.#g=e,this.#S=r,this.#v=s}get invocationId(){return this.#v}get type(){return this.#g}get node(){return this.#b.descriptor}get inputArguments(){return this.#b.inputs}set inputs(t){this.#b.outputsPromise=Promise.resolve(t)}get outputs(){return this.#b.inputs}get state(){return this.#b}async save(){return(async(t,e)=>{const r=await J.prepareToSave(e);return JSON.stringify({state:r,type:t},F)})(this.#g,this.#b)}get runState(){return this.#S}get timestamp(){return P()}isAtExitNode(){return 0===this.#b.newOpportunities.length&&0===this.#b.opportunities.length&&0===this.#b.pendingOutputs.size}static load(t){const{state:e,type:r}=(t=>{const{state:e,type:r}=JSON.parse(t,L);return{state:A.fromObject(e),type:r}})(t);return new B(e,r,void 0,0)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class U{#h;constructor(t){this.#h=t}async serve(t,e=!1,r={}){const s=this.#h.createServerStream(),a=s.readableRequests.getReader();let o=await a.read();if(o.done)return;const i=(t=>{const[e,,r]=t;if(console.log("resumeRun",e,r),!r)return;if(r.length>1)throw new Error("I don't yet know how to resume from nested subgraphs.");const s=B.load(r[0].state);if("input"===e){const[,e]=t;s.inputs=e.inputs}return s})(o.value),u=s.writableResponses.getWriter(),c={...r,probe:e?new M((async t=>{const{type:e,data:r}=t,s=[e,n(r)];"nodestart"==e&&s.push(t.state),await u.write(s)})):void 0};try{for await(const e of t.run(c,i))if("input"===e.type){const t=e.runState,{node:r,inputArguments:s,timestamp:n}=e;if(await u.write(["input",{node:r,inputArguments:s,timestamp:n},t]),o=await a.read(),o.done)return void await u.close();{const[t,r]=o.value;"input"===t&&(e.inputs=r.inputs)}}else if("output"===e.type){const{node:t,outputs:r,timestamp:s}=e;await u.write(["output",{node:t,outputs:r,timestamp:s}])}await u.write(["end",{timestamp:P()}]),await u.close()}catch(t){const e=t;let r;if(e?.cause){const{cause:t}=e;r=t}else r=e.message;console.error("Run Server error:",r),await u.write(["error",{error:r,timestamp:P()}]),await u.close()}}}const H=t=>{const[e,r,s]=t.data;return{type:e,data:r,state:s,reply:async r=>{if("input"!==e)throw new Error("For now, we cannot reply to messages other than 'input'.");await t.reply([e,r,s])}}};class z{#h;constructor(t){this.#h=t}async*run(t){const e=this.#h.createClientStream(),r=u(e.writableRequests,e.readableResponses),s=["run",{}];t&&s.push(t),await r.start(s);for await(const t of r)yield H(t)}async runOnce(t){let e;for await(const r of this.run()){const{type:s,data:n}=r;if("input"===s)r.reply({inputs:t});else if("output"===s){e=n.outputs;break}}return e||{}}}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class D{#h;constructor(t){this.#h=t}async serve(){const t=this.#h.createServerStream().readableRequests.getReader(),e=await t.read();if(e.done)throw new Error("Client closed stream without sending a request.");return e.value.url}}class K{#h;constructor(t){this.#h=t}async load(t){const e=this.#h.createClientStream().writableRequests.getWriter();await e.write({url:t}),await e.close()}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const V=t=>t,G=t=>({test:e=>new URL(e).origin===t});export{l as HTTPClientTransport,p as HTTPServerTransport,K as InitClient,D as InitServer,d as PortDispatcher,N as ProxyClient,q as ProxyServer,z as RunClient,U as RunServer,w as WorkerClientTransport,m as WorkerServerTransport,V as defineConfig,G as hasOrigin};
//# sourceMappingURL=remote.min.js.map
