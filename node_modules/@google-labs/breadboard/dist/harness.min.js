/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class t{static computeMissingInputs(t,e,r){const s=[...new Set(t.filter((t=>!!t.in&&!t.optional)).map((t=>t.in||"")))],n=new Set;return Object.keys(e).forEach((t=>n.add(t))),r.configuration&&Object.keys(r.configuration).forEach((t=>n.add(t))),s.filter((t=>!n.has(t)))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class e{state=new Map;constants=new Map;#t(t,e,r,s){let n=t.get(e);n||(n=new Map,t.set(e,n));let o=n.get(r);o||(o=[],n.set(r,o)),o.push(s)}wireOutputs(t,e){if(0!==t.filter((e=>e.from!=t[0].from)).length)throw new Error("All opportunities must be from the same node");t.forEach((t=>{const r=t.to,s=t.out,n=t.constant?this.constants:this.state;if(s)if("*"===s)for(const t in e){const s=e[t];null!=s&&null!=s&&this.#t(n,r,t,s)}else if(t.in){const o=e[s];null!=o&&null!=o&&this.#t(n,r,t.in,o)}}))}getAvailableInputs(t){const e={};for(const r of[this.constants.get(t),this.state.get(t)])if(r)for(const[t,s]of r.entries())0!==s.length&&(e[t]=s[0]);return e}useInputs(t,e){const r=this.state.get(t);if(r)for(const t in e){const e=r.get(t);e&&e.shift()}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class r{descriptor;inputs;missingInputs;opportunities;newOpportunities;state;outputsPromise;pendingOutputs;constructor(t,e,r,s,n,o,i){this.descriptor=t,this.inputs=e,this.missingInputs=r,this.opportunities=s,this.newOpportunities=n,this.state=o,this.pendingOutputs=i}get skip(){return this.missingInputs.length>0}static fromObject(t){const s=new e;return s.constants=t.state.constants,s.state=t.state.state,new r(t.descriptor,t.inputs,t.missingInputs,t.opportunities,t.newOpportunities,s,t.pendingOutputs)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class s{graph;#e;#r;constructor(t,e,r=!0){this.graph=t,this.#e=e,this.#r=r}static#s(t,e){const{promiseId:r,outputs:s,newOpportunities:n}=e;t.pendingOutputs.delete(r);const o=s.$error?n.filter((t=>"$error"===t.out)):n;if(t.opportunities.push(...o),t.state.wireOutputs(o,s),s.$error){if(0===o.length)throw new Error("Uncaught exception in node handler. Catch by wiring up the $error output.",{cause:s.$error});globalThis.console.warn("Error in node handler, passing to the wired $error output.",s.$error,o)}}static async processAllPendingNodes(t){return(await Promise.all(t.pendingOutputs.values())).forEach((e=>{s.#s(t,e)})),t}async next(){if(!this.#e.skip){const{inputs:t,outputsPromise:e,newOpportunities:r,descriptor:s}=this.#e;this.#e.state.useInputs(s.id,this.#e.inputs);const n=Symbol(),o=new Promise((o=>{(e||Promise.resolve({})).then((e=>{if(e.$error){const r=e.$error;e.$error={descriptor:s,...r,inputs:{...t,...r.inputs}}}o({promiseId:n,outputs:e,newOpportunities:r})})).catch((e=>{o({promiseId:n,outputs:{$error:{kind:"error",error:e,inputs:t,descriptor:s}},newOpportunities:r.filter((t=>"$error"===t.out))})}))}));this.#e.pendingOutputs.set(n,o)}for(;(0===this.#e.opportunities.length||this.#r)&&this.#e.pendingOutputs.size>0;)s.#s(this.#e,await Promise.race(this.#e.pendingOutputs.values()));if(0===this.#e.opportunities.length)return{done:!0,value:null};const e=this.#e.opportunities.shift(),{heads:n,nodes:o,tails:i}=this.graph,a=e.to,c=o.get(a);if(!c)throw new Error(`No node found for id "${a}"`);const u=n.get(a)||[],d=this.#e.state.getAvailableInputs(a),p=t.computeMissingInputs(u,d,c),h=i.get(a)||[],l={...c.configuration,...d};return this.#e=new r(c,l,p,this.#e.opportunities,h,this.#e.state,this.#e.pendingOutputs),{done:!1,value:this.#e}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class n{tails=new Map;heads=new Map;nodes=new Map;entries=[];constructor(t){this.tails=t.edges.reduce(((t,e)=>{const r=e.from;return t.has(r)?t.get(r)?.push(e):t.set(r,[e]),t}),new Map),this.heads=t.edges.reduce(((t,e)=>{const r=e.to;return t.has(r)?t.get(r)?.push(e):t.set(r,[e]),t}),new Map),this.nodes=t.nodes.reduce(((t,e)=>(t.set(e.id,e),t)),new Map),this.entries=Array.from(this.tails.keys()).filter((t=>!this.heads.has(t)||0===this.heads.get(t)?.length))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class o{graph;previousResult;constructor(t,e){this.graph=new n(t),this.previousResult=e}[Symbol.asyncIterator](){return this.start()}start(){if(this.previousResult)return new s(this.graph,this.previousResult);const{entries:t}=this.graph;if(0===t.length)throw new Error("No entry node found in graph.");const n=t.map((t=>({from:"$entry",to:t}))),o=new r({id:"$empty",type:"$empty"},{},[],n,[],new e,new Map);return new s(this.graph,o)}static async prepareToSave(t){return await s.processAllPendingNodes(t)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const i=(t,e)=>e instanceof Map?{$type:"Map",value:Array.from(e.entries())}:e,a=(t,e)=>{const{$type:r}=e||{};return"Map"==r&&e.value?new Map(e.value):e},c=async(t,e)=>{const r=await o.prepareToSave(e);return JSON.stringify({state:r,type:t},i)},u=()=>globalThis.performance.now()
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */;class d{#n;#o;#i;#a;constructor(t,e,r,s){this.#o=t,this.#n=e,this.#i=r,this.#a=s}get invocationId(){return this.#a}get type(){return this.#n}get node(){return this.#o.descriptor}get inputArguments(){return this.#o.inputs}set inputs(t){this.#o.outputsPromise=Promise.resolve(t)}get outputs(){return this.#o.inputs}get state(){return this.#o}async save(){return c(this.#n,this.#o)}get runState(){return this.#i}get timestamp(){return u()}isAtExitNode(){return 0===this.#o.newOpportunities.length&&0===this.#o.opportunities.length&&0===this.#o.pendingOutputs.size}static load(t){const{state:e,type:s}=(t=>{const{state:e,type:s}=JSON.parse(t,a);return{state:r.fromObject(e),type:s}})(t);return new d(e,s,void 0,0)}}class p extends d{constructor(t,e,r){super(t,"input",e,r)}get outputs(){throw new Error('Outputs are not available in the "input" stage')}}class h extends d{constructor(t,e){super(t,"output",void 0,e)}get inputArguments(){throw new Error('Input arguments are not available in the "output" stage')}set inputs(t){throw new Error('Setting inputs is not available in the "output" stage')}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const l=(t,e,r)=>{const s=new URL(e,t),n=s.hash,o=s.href,i="file:"===s.protocol?decodeURIComponent(s.pathname):void 0,a=t.href.replace(t.hash,""),c=o.replace(n,"");if(a==c&&n)return r.push({type:"hash",location:n.substring(1),href:o}),!0;const u=i?{type:"file",location:i,href:o}:o?{type:"fetch",location:c,href:o}:{type:"unknown",location:"",href:o};return r.push(u),!n},f=async t=>{if(void 0===globalThis.process)throw new Error("Unable to use `path` when not running in node");let e;if("function"==typeof require){const{readFile:t}=require("node:fs/promises");e=t}else{const{readFile:t}=await import("node:fs/promises");e=t}return JSON.parse(await e(t,"utf-8"))},w=async t=>{const e=await fetch(t);return await e.json()};class m{loaders;graphs;constructor(t){this.loaders={file:f,fetch:w,hash:async e=>{if(!t)throw new Error("No sub-graphs to load from");return t[e]},unknown:async()=>{throw new Error("Unable to determine Board loader type")}}}async load(t){const e=await this.loaders[t.type](t.location);return e.url=t.href,e}}class y{#c;#u;constructor({base:t,graphs:e}){this.#c=t,this.#u=e}async load(t){const e=[];let r,s=this.#c;for(;!l(s,t,e);)s=new URL(e[e.length-1].href);let n=this.#u,o=!0;for(const t of e){"file"!==t.type&&"fetch"!==t.type||(o=!1);const e=new m(n);r=await e.load(t),n=r.graphs}if(!r)throw new Error("BoardLoader failed to load a graph. This error likely indicates a bug in the BoardLoader.");return{graph:r,isSubgraph:o}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ReadableStream.prototype[Symbol.asyncIterator]||(ReadableStream.prototype[Symbol.asyncIterator]=async function*(){const t=this.getReader();try{for(;;){const{done:e,value:r}=await t.read();if(e)return;yield r}}finally{t.releaseLock()}});class g{writable;readable;controller=null;constructor(){this.writable=new WritableStream({write:t=>this.write(t)}),this.readable=new ReadableStream({start:t=>{this.controller=t}})}write(t){(new TextDecoder).decode(t).split("\n").map((t=>t.trim())).filter((t=>t.length>0)).forEach((t=>{try{if("stop"===t)return void this.controller?.close();const e=JSON.parse(t);this.controller?.enqueue(e)}catch(t){console.error(t)}}))}}const b=async(t,e,r)=>{const s=await fetch(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inputs:e,state:r})});return s.body?.pipeThrough(new g)};async function*v(t){let e,r;for(;;){const s=await b(t,e,r);if(!s)break;for await(const t of s)r=JSON.stringify(t.state),yield t,e=t.inputs;if(!r)break}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const $=async(t,e,r)=>{const s=(t=>{if(t instanceof Function)return t;if(t.invoke)return t.invoke;throw new Error("Invalid handler")})(t);return new Promise((t=>{s(e,r).then(t).catch((e=>{t({$error:{error:e}})}))}))},k=t=>t.reduce(((t,e)=>({...e.handlers,...t})),{}),S=t=>t&&t.replace(/-/g,""),E=(t,e="")=>{if(!t)return"";const r=t.id,s=`${e?`${S(e)}_`:""}${S(r)}`,n=t.type,o=`"${n} <br> id='${r}'"`;switch(n){case"include":return`${s}[[${o}]]:::include`;case"slot":return`${s}((${o})):::slot`;case"passthrough":return`${s}((${o})):::passthrough`;case"input":return`${s}[/${o}/]:::input`;case"secrets":return`${s}(${o}):::secrets`;case"output":return`${s}{{${o}}}:::output`;default:return`${s}[${o}]`}};class O{nodeMap;edges;nodes;idPrefix;subgraphs;constructor(t,e=""){const{edges:r,nodes:s}=t;this.nodeMap=new Map(s.map((t=>[t.id,t]))),this.edges=r,this.nodes=s,this.idPrefix=e,this.subgraphs=t.graphs||{}}handleSlotted(t,e){const r=e?`${S(e)}_`:"";if("include"!==t.type)return"";const s=t.configuration?.slotted;if(!s)return"";return Object.entries(s).map((([e,s])=>this.describeSubgraph(s,e,"slotted",t,`${r}${t.id}`))).join("\n")}handleLambda(t,e){const r=e?`${S(e)}_`:"",s=t.configuration?.board;if(!s)return"";const n=s;if("board"!==n.kind)return"";const o=n.board;return this.describeSubgraph(o,t.id,"lamdba",t,`${r}${t.id}`)}describeSubgraphs(t,e=""){const r=this.nodeMap.get(t.from);if(!r)return"";const s=this.handleLambda(r,e);return`${this.handleSlotted(r,e)}${s}`}describeSubgraph(t,e,r,s,n){const o=new O(t,n).describeGraph(),i=this.idPrefix?`${S(this.idPrefix)}_`:"",a=r&&s?`sg_${S(e)}:::slotted -- "${r}->${r}" --o ${i}${S(s.id)}\n`:"";return`\nsubgraph sg_${S(e)} [${e}]\n${o}\nend\n${a}`}describeGraph(t=!1){return[...this.edges.map((e=>{const r=((t,e,r="")=>{const s=t.from,n=E(e.get(s),r),o=t.to,i=E(e.get(o),r),a=t.in,c=t.out,u=t.optional,d=t.constant;return"*"===c?`${n} -- all --\x3e ${i}`:c&&a?u?`${n} -. "${c}->${a}" .-> ${i}`:d?`${n} -- "${c}->${a}" --o ${i}`:`${n} -- "${c}->${a}" --\x3e ${i}`:`${n} --\x3e ${i}`})(e,this.nodeMap,this.idPrefix);return`${r}${t?"":this.describeSubgraphs(e,this.idPrefix)}`})),...t?"":Object.entries(this.subgraphs).map((([t,e])=>this.describeSubgraph(e,t,void 0,void 0,`${t}${this.idPrefix}`)))].join("\n")}}const x=t=>null==t?"null":Array.isArray(t)?"array":typeof t;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class P{additionalProperties=!1;required=[];properties={};build(){const t={type:"object",properties:this.properties,additionalProperties:this.additionalProperties};return this.required.length>0&&(t.required=this.required),t}setAdditionalProperties(t){return void 0!==t&&(this.additionalProperties=t),this}addInputs(t){return t?(Object.entries(t).forEach((([t,e])=>{this.addProperty(t,{type:x(e)})})),this):this}addProperty(t,e){return this.properties[t]=e,this}addProperties(t){return Object.entries(t).forEach((([t,e])=>{this.addProperty(t,e)})),this}addRequired(t){return t?("string"==typeof t?this.required=[...this.required,t]:Array.isArray(t)&&t.length>0&&(this.required=[...this.required,...t]),this):this}static empty(t=!1){return(new P).setAdditionalProperties(t).build()}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const N=(t,e={},r)=>{const s=e.title??e?.url;return`Missing ${r?"required ":""}input "${t}"${s?` for board "${s}".`:"."}`},j=async(t,e,r,s)=>{if(!e.requestInput)return;const n=await s.outputsPromise??{},o=new R(n,s.inputs);s.outputsPromise=o.read(I(t,e,r))},I=(t,e,r)=>async(s,n,o)=>{if(o)throw new Error(N(s,t,o));if(void 0!==n.default)return"type"in n&&"string"!==n.type?JSON.parse(n.default):n.default;const i=await(e.requestInput?.(s,n,r));if(void 0===i)throw new Error(N(s,t,o));return i};class R{#d;#p;constructor(t,e){this.#d=t,this.#p=e}async read(t){if(!("schema"in this.#p))return this.#d;const e=this.#p.schema;if(!e.properties)return this.#d;const r=Object.entries(e.properties),s={};for(const[n,o]of r){if(n in this.#d){s[n]=this.#d[n];continue}const r=e.required?.includes(n)??!1,i=await t(n,o,r);s[n]=i}return{...this.#d,...s}}}class q{#h;#l=new Map;constructor(t){this.#h=t}createHandler(t,e){return async(r,s,n)=>{const o=this.#l.get(r);if(void 0!==o)return o;const i={id:n.id,type:n.type},a={...e,descriptor:i,inputs:{schema:{type:"object",properties:{[r]:s}}}};await t(new p(a,void 0,-1));const c=await a.outputsPromise;let u=c&&c[r];return void 0===u&&(u=await(this.#h.requestInput?.(r,s,i))),s.transient||this.#l.set(r,u),u}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const C=()=>{};class A{#f=[];#w=C;#m;#y;abort=C;constructor(){this.#g()}#g(){this.#m=new Promise(((t,e)=>{this.#w=t,this.abort=e}))}#b(t){this.#f.push(t),1==this.#f.length&&(this.#w(),this.#g())}async write(t){return new Promise((e=>{this.#b({value:t,receipt:e})}))}async read(){this.#y&&this.#y(),0===this.#f.length&&await this.#m;const t=this.#f.shift();if(!t)throw new Error("asyncGen queue should never be empty.");return this.#y=t.receipt,t.value?{done:!1,value:t.value}:{done:!0,value:void 0}}close(){this.#b({value:void 0,receipt:C})}}class T{#v;#$=!0;#f=new A;constructor(t){this.#v=t}async#k(t){return this.#f.write(t)}async next(){return this.#$&&(this.#$=!1,this.#v(this.#k.bind(this)).then((()=>{this.#f.close()})).catch((t=>{this.#f.abort(t)}))),this.#f.read()}}const M=t=>({[Symbol.asyncIterator]:()=>new T(t)});
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class F{#S;#E;constructor(t){this.#S=structuredClone(t)||[]}onGraphStart(){this.#S.push({graph:0,node:0})}onNodeStart(t){this.#S[this.#S.length-1].node++,this.#E=t}onNodeEnd(){}onGraphEnd(){}async state(){const t=structuredClone(this.#S);return this.#E&&(t[t.length-1].state=await c("nodestart",this.#E)),t}}var W="https://raw.githubusercontent.com/breadboard-ai/breadboard/@google-labs/breadboard-schema@1.2.0/packages/schema/breadboard.schema.json";
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class B{url;title;description;$schema;version;edges=[];nodes=[];kits=[];graphs;args;#O={};#x=[];#P;constructor({url:t,title:e,description:r,version:s,$schema:n}={$schema:W}){Object.assign(this,{$schema:n??W,url:t,title:e,description:r,version:s})}async*run(t={},e){const r=t.base||new URL(this.url||"",import.meta.url);yield*M((async s=>{const{probe:n}=t,i=await B.handlersFromBoard(this,t.kits),a={...this.#O,...t.slots};this.#x.forEach((t=>t.addGraph(this)));const c=new o(this,e?.state),d=new q(t),l=t.invocationPath||[],f=new F(t.state);await(n?.report?.({type:"graphstart",data:{metadata:this,path:l,timestamp:u()}}));let w=0;f.onGraphStart();const m=()=>[...l,w];for await(const e of c){w++;const{inputs:o,descriptor:c,missingInputs:l}=e;if(e.skip){await(n?.report?.({type:"skip",data:{node:c,inputs:o,missingInputs:l,path:m(),timestamp:u()}}));continue}let y;if(f.onNodeStart(e),await(n?.report?.({type:"nodestart",data:{node:c,inputs:o,path:m(),timestamp:u()},state:await f.state()})),"input"===c.type)await s(new p(e,await f.state(),w)),await j(this,t,c,e),y=e.outputsPromise;else if("output"===c.type)await s(new h(e,w)),y=e.outputsPromise;else{const n=i[c.type];if(!n)throw new Error(`No handler for node type "${c.type}"`);const u={...t,board:this,descriptor:c,outerGraph:this.#P||this,base:r,slots:a,kits:[...t.kits||[],...this.kits],requestInput:d.createHandler(s,e),invocationPath:m(),state:await f.state()};y=$(n,o,u)}f.onNodeEnd(),await(n?.report?.({type:"nodeend",data:{node:c,inputs:o,outputs:await y,validatorMetadata:this.#x.map((t=>t.getValidatorMetadata(c))),path:m(),timestamp:u()}})),e.outputsPromise=y}f.onGraphEnd(),await(n?.report?.({type:"graphend",data:{metadata:this,path:l,timestamp:u()}}))}))}get validators(){return this.#x}async runOnce(t,e={}){const r={...t,...this.args},{probe:s}=e;if(e.board&&e.descriptor)for(const t of e.board.validators)this.addValidator(t.getSubgraphValidator(e.descriptor,Object.keys(r)));try{let t={};const n=e.invocationPath||[];for await(const o of this.run(e))if("input"===o.type)o.inputs=r;else if("output"===o.type){t=o.outputs,await(s?.report?.({type:"nodeend",data:{node:o.node,inputs:o.inputs,outputs:t,path:[...n,o.invocationId],timestamp:u()}})),await(s?.report?.({type:"graphend",data:{metadata:this,path:n,timestamp:u()}}));break}return t}catch(t){if(t.cause)return{$error:t.cause};throw t}}addValidator(t){this.#x.push(t)}mermaid(t="TD",e=!1,r=!1){return((t,e="TD",r=!1,s=!1)=>{const n=new O(t).describeGraph(s);return r?((t,e)=>`graph ${e};\n${t}`)(n,e):((t,e)=>`%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%\ngraph ${e};\n${t}\nclassDef default stroke:#ffab40,fill:#fff2ccff,color:#000\nclassDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000\nclassDef output stroke:#38761d,fill:#b6d7a8ff,color:#000\nclassDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef slot stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef config stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef secrets stroke:#db4437,fill:#f4cccc,color:#000\nclassDef slotted stroke:#a64d79`)(n,e)})(this,t,e,r)}static async fromGraphDescriptor(t){const e=new B(t);return e.edges=t.edges,e.nodes=t.nodes,e.graphs=t.graphs,e.args=t.args,e}static async load(t,e){const{base:r,slotted:s,outerGraph:n}=e||{},o=new y({base:r,graphs:n?.graphs}),{isSubgraph:i,graph:a}=await o.load(t),c=await B.fromGraphDescriptor(a);return i&&(c.#P=n),c.#O=s||{},c}static async fromBreadboardCapability(t){if("board"!==t.kind||!t.board)throw new Error(`Expected a "board" Capability, but got ${t}`);const e=t.board;if(!(e.edges&&e.kits&&e.nodes))throw new Error('Supplied "board" Capability argument is not actually a board');let r=t.board;return r.runOnce||(r=await B.fromGraphDescriptor(e)),r}static async handlersFromBoard(t,e=[]){const r=[new L,...e,...t.kits];return k(r)}static runRemote=v}class L{handlers;constructor(){this.handlers={lambda:{describe:async t=>({inputSchema:(new P).setAdditionalProperties(!0).addInputs(t).addProperty("board",{title:"board",description:"The board to run.",type:"object"}).build(),outputSchema:(new P).addProperty("board",{title:"board",description:"The now-runnable board.",type:"object"}).build()}),invoke:async t=>{const{board:e,...r}=t;if(!e||"board"!==e.kind||!e.board)throw new Error('Lambda node requires a BoardCapability as "board" input');const s={...await B.fromBreadboardCapability(e),args:r};return{board:{...e,board:s}}}}}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class U{#N=new Map;vendId(t,e){let r=this.#N.get(t)||0;return r++,this.#N.set(t,r),`${e}-${r}`}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const D=/^((?<a>.*)(?<dir><-|->))?(?<b>[^(.|?)]*)(?<q>\.|\?)?$/m,_=new U;class z{#j;#I;constructor(t,e,r,s,n){if(this.#I=t.currentBoardToAddTo(),this.#j={id:n??_.vendId(this.#I,r),type:r},s&&(t=>Object.values(t).length>0)(s)){const t=Object.entries(s).filter((([t,e])=>e instanceof z));for(const[e,r]of t){if(delete s[e],-1!==e.indexOf("->"))throw Error("Cannot pass output wire in confdig");this.wire(-1===e.indexOf("<-")?`${e}<-.`:e,r)}this.#j.configuration=s}e?.url&&!this.#I.kits.find((t=>t.url===e.url))&&this.#I.kits.push(e),this.#I.addNode(this.#j)}wire(t,e){const{ltr:r,edge:s}=(t=>{const e={ltr:!0},r=t.match(D);if(!r)throw new Error(`Invalid edge spec: ${t}`);const{a:s,b:n,dir:o,q:i}=r?.groups,a="<-"!==o;e.ltr=a;const c="?"===i,u="."===i;return e.edge={},u&&(e.edge.constant=!0),c&&(e.edge.optional=!0),s||n?"*"===s||"*"===n?(e.edge.out="*",e):s?n?(a?(e.edge.out=s,e.edge.in=n):(e.edge.out=n,e.edge.in=s),e):(e.edge.out=s,e.edge.in=s,e):(e.edge.out=n,e.edge.in=n,e):e})(t),[n,o]=r?[this,e]:[e,this],i={from:n.#j.id,to:o.#j.id,...s};return n.#I!==o.#I?o.#I.addEdgeAcrossBoards(i,n.#I,o.#I):this.#I.addEdge(i),this}get id(){return this.#j.id}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const H=t=>new t({create:()=>{throw Error("Node instantiation can't (yet) happen during runtime")}}),J=(t,e)=>{const r=void 0!==e.nodes&&void 0!==e.edges&&void 0!==e.kits,s=r||"function"==typeof e||e instanceof z||"board"===e.kind&&e.board?{board:r?{kind:"board",board:e}:e}:e;return"function"==typeof s.board&&(s.board=t.lambda(s.board)),s};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class G extends B{#R=[];#q;#C=[];input(t={}){const{$id:e,...r}=t;return new z(this,void 0,"input",{...r},e)}output(t={}){const{$id:e,...r}=t;return new z(this,void 0,"output",{...r},e)}lambda(t,e={}){const{$id:r,...s}=e;let n,o;if("function"==typeof t){n=new G,o=n.input();const e=n.output();n.#q=this.#q??this,n.#q.#R.push(n),t(n,o,e),n.#q.#R.pop()}else n=t;const i=new z(this,void 0,"lambda",{board:{kind:"board",board:n},...s},r);if(o&&n.#C.length>0){for(const{edge:t,from:e,to:r}of n.#C){if(r!==n||!t.constant)throw new Error("Across board wires: Must be constant and from parent to child");const s=`$l-${t.to}-${t.in}`;n.addEdge({...t,from:o.id,out:s});const a={...t,to:i.id,in:s};e===this?this.addEdge(a):this.addEdgeAcrossBoards(a,e,this)}n.#C=[]}return i}addEdge(t){this.edges.push(t)}addNode(t){this.nodes.push(t)}addKit(t){const e=(r=this,new t({create:(...t)=>new z(r,...t),getConfigWithLambda:t=>J(r,t)}));var r;return this.kits.push(e),e}currentBoardToAddTo(){const t=this.#q?this.#q.#R:this.#R;return 0===t.length?this:t[t.length-1]}addEdgeAcrossBoards(t,e,r){if("*"===t.out)throw new Error("Across board wires: * wires not supported");if(!t.constant)throw new Error("Across board wires: Must be constant for now");if(r!==this)throw new Error("Across board wires: Must be invoked on to board");const s=this.#q?this.#q.#R:this.#R;if(e!==this.#q&&!s.includes(e))throw new Error("Across board wires: From must be parent of to");this.#C.push({edge:t,from:e,to:r})}}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class V{#A;constructor(t){this.#A=t}async serve(){const t=this.#A.createServerStream().readableRequests.getReader(),e=await t.read();if(e.done)throw new Error("Client closed stream without sending a request.");return e.value.url}}class K{#A;constructor(t){this.#A=t}async load(t){const e=this.#A.createClientStream().writableRequests.getWriter();await e.write({url:t}),await e.close()}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Q extends EventTarget{#v;constructor(t){super(),this.#v=t}async report(t){return this.#v(t)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const X="stream";class Y{kind=X;stream;constructor(t){this.stream=t}}const Z=t=>{const e=[];return{value:JSON.stringify(t,((t,r)=>(t=>{const e=t;return e&&e.kind&&e.kind===X&&e.stream instanceof ReadableStream})(r)?(e.push(r.stream),{$type:"Stream",id:e.length-1}):r)),streams:e}},tt=(t,e)=>{const r=JSON.parse(t,((t,r)=>"object"==typeof r&&null!==r&&"Stream"===r.$type&&"number"==typeof r.id?new Y(e(r.id)):r));return r},et=t=>{const e=Z(t).value;return tt(e,(()=>new ReadableStream))},rt=t=>({readable:new ReadableStream({start(e){t.onmessage=t=>{null!==t.data?e.enqueue(t.data):e.close()}},cancel(){t.onmessage=null}}),writable:new WritableStream({write(e){const r=Z(e);t.postMessage(e,r.streams)},close(){t.postMessage(null,[])}})});class st{#T;data;constructor(t,e){this.#T=e,this.data=t}async reply(t){await this.#T.write(t)}}class nt{#M;#T;constructor(t,e){this.#M=e.getReader(),this.#T=t.getWriter()}async next(){const{done:t,value:e}=await this.#M.read();return t?(this.#T.close(),{done:t,value:void 0}):{done:!1,value:new st(e,this.#T)}}async return(){return this.#T.close(),{done:!0,value:void 0}}async throw(t){return this.#T.abort(t),{done:!0,value:void 0}}}const ot=(t,e)=>({async start(e){const r=t.getWriter();await r.write(e),r.releaseLock()},[Symbol.asyncIterator]:()=>new nt(t,e)});class it{#A;constructor(t){this.#A=t}async serve(t,e=!1,r={}){const s=this.#A.createServerStream(),n=s.readableRequests.getReader();let o=await n.read();if(o.done)return;const i=(t=>{const[e,,r]=t;if(console.log("resumeRun",e,r),!r)return;if(r.length>1)throw new Error("I don't yet know how to resume from nested subgraphs.");const s=d.load(r[0].state);if("input"===e){const[,e]=t;s.inputs=e.inputs}return s})(o.value),a=s.writableResponses.getWriter(),c={...r,probe:e?new Q((async t=>{const{type:e,data:r}=t,s=[e,et(r)];"nodestart"==e&&s.push(t.state),await a.write(s)})):void 0};try{for await(const e of t.run(c,i))if("input"===e.type){const t=e.runState,{node:r,inputArguments:s,timestamp:i}=e;if(await a.write(["input",{node:r,inputArguments:s,timestamp:i},t]),o=await n.read(),o.done)return void await a.close();{const[t,r]=o.value;"input"===t&&(e.inputs=r.inputs)}}else if("output"===e.type){const{node:t,outputs:r,timestamp:s}=e;await a.write(["output",{node:t,outputs:r,timestamp:s}])}await a.write(["end",{timestamp:u()}]),await a.close()}catch(t){const e=t;let r;if(e?.cause){const{cause:t}=e;r=t}else r=e.message;console.error("Run Server error:",r),await a.write(["error",{error:r,timestamp:u()}]),await a.close()}}}const at=t=>{const[e,r,s]=t.data;return{type:e,data:r,state:s,reply:async r=>{if("input"!==e)throw new Error("For now, we cannot reply to messages other than 'input'.");await t.reply([e,r,s])}}};class ct{#A;constructor(t){this.#A=t}async*run(t){const e=this.#A.createClientStream(),r=ot(e.writableRequests,e.readableResponses),s=["run",{}];t&&s.push(t),await r.start(s);for await(const t of r)yield at(t)}async runOnce(t){let e;for await(const r of this.run()){const{type:s,data:n}=r;if("input"===s)r.reply({inputs:t});else if("output"===s){e=n.outputs;break}}return e||{}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const ut="port-dispatcher-sendport";class dt{#F;#W=new Map;#B=new Map;constructor(t){this.#F=t,this.#F.addEventListener("message",(t=>{const{type:e,id:r,port:s}=t.data;if(e!==ut)return;const n=this.#W.get(r);n?(n(s),this.#W.delete(r)):this.#B.set(r,s)}))}receive(t){const e=this.#B.get(t);return e?(this.#B.delete(t),rt(e)):(t=>{let e;const r=new Promise((r=>{t().then((t=>{e=rt(t),r()}))}));return{readable:new ReadableStream({async start(){await r},pull:t=>e.readable.pipeTo(new WritableStream({write(e){t.enqueue(e)}})),cancel(){e.readable.cancel()}}),writable:new WritableStream({async start(){await r},async write(t){const r=e.writable.getWriter();await r.write(t),r.releaseLock()},async close(){await e.writable.close()},async abort(t){await e.writable.abort(t)}})}})((()=>new Promise((e=>{this.#W.set(t,e)}))))}send(t){const{port1:e,port2:r}=new MessageChannel;return this.#F.postMessage({type:ut,id:t,port:r},[r]),rt(e)}}class pt{#M;#T;constructor(t){this.#M=t.readable.getReader(),this.#T=t.writable.getWriter()}createClientStream(){return{writableRequests:(e=this.#T,new WritableStream({write:async t=>e.write(t)},{highWaterMark:0})),readableResponses:(t=this.#M,new ReadableStream({async pull(e){const{value:r,done:s}=await t.read();s?e.close():e.enqueue(r)}},{highWaterMark:0}))};var t,e}}class ht{#L;constructor(t){this.#L=t}createServerStream(){return{readableRequests:this.#L.readable,writableResponses:this.#L.writable}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class lt{url;title;description;version;namespacePrefix;constructor({title:t,description:e,version:r,url:s,namespacePrefix:n=""}){this.url=s,this.title=t,this.description=e,this.version=r,this.namespacePrefix=n}#U(t){return Object.keys(t).reduce(((e,r)=>(e[`${this.namespacePrefix}${r}`]=t[r],e)),{})}build(t){if(!this.url)throw new Error("Builder was not yet initialized.");const e=this.url,r=this.namespacePrefix,{title:s,description:n,version:o}=this,i=this.#U(t),a=Object.keys(t);return class{title=s;description=n;version=o;url=e;get handlers(){return i}constructor(t){const e=new Proxy(this,{get:(s,n)=>"handlers"===n||"url"===n?s[n]:a.includes(n)?(s={})=>{const o=t.getConfigWithLambda(s),{$id:i,...a}=o;return t.create(e,`${r}${n}`,{...a},i)}:void 0});return e}}}static wrap(t,e){const r=Object.entries(e).reduce(((t,e)=>{const[r,s]=e;return t[r]={invoke:async t=>{let e=[];s&&s.length>0&&(e=s.toString().match(/\((.+?)\)/)?.[1].split(",")??[],s.length>1&&0===e.length&&"___args"in t&&Array.isArray(t.___args)&&(e=["___args"]));for(const r of e)if(r.trim()in t==!1)throw new Error(`Missing input: ${r.trim()}. Valid inputs are: ${Object.keys(t).join(", ")}`);const r=e.filter((t=>0==t.startsWith("___"))).map((e=>t[e.trim()])),n=e[e.length-1];null!=n&&n.startsWith("___")&&r.push(...t[n]);const o=await s(...r);return"object"!=typeof o||Array.isArray(o)?{result:o}:{...o}}},t}),{});return new lt(t).build(r)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const ft=globalThis.process?t=>Buffer.from(t,"base64").toString("binary"):globalThis.atob,wt=globalThis.process?t=>Buffer.from(t,"binary").toString("base64"):globalThis.btoa;class mt{outputName;from;to;when;constructor(t,e,r,s={}){this.outputName=t,this.from=e,this.to=r,this.when=s}getInputNames(){const t=Object.keys(this.when);return 0===t.length?[this.outputName]:t}matches(t){return Object.entries(this.when).every((([e,r])=>{const s=t[e];return"string"==typeof r?s===r:"string"==typeof s&&r.test(s)}))}}const yt=(t,e)=>Object.fromEntries(Object.entries(e).map((([e,r])=>"string"==typeof r?[e,[new mt(e,t,r)]]:Array.isArray(r)?[e,r.map((r=>"string"==typeof r?new mt(e,t,r):new mt(e,t,r.to,r.when)))]:[e,[new mt(e,t,r.to,r.when)]]))),gt=Math.round(Date.now()/6048e5).toString(36),bt=`T-${gt}-`,vt=`-${gt}-T`,$t=new RegExp(`(${bt}.*?${vt})`,"gm"),kt=new RegExp(`^${bt}(.+?)${vt}$`),St=async(t,e,r)=>{const s=JSON.stringify(t),n=s.split($t).filter(Boolean).map((t=>{const e=t.match(kt);if(e){const t=e[1].split("~"),[r,s,n]=t;return{nodeType:r,outputName:s,inputs:ft(n)}}return{value:t}}));const o=await Promise.all(n.map((async t=>{if("inputs"in t){const s=JSON.parse(t.inputs),{nodeType:n,outputName:o}=t,i=e?await r(n,s):{[o]:"VALUE_BLOCKED"};if(!i)return"";let a=JSON.stringify(i[o]);return a.startsWith('"')&&(a=a.slice(1,-1)),a=JSON.stringify(a),a.slice(1,-1)}return t.value})));return JSON.parse(o.join(""))},Et=(t,e)=>{const r=Object.fromEntries(Object.entries(e).map((([e,r])=>{const s=t[e];return s?[e,async(t,n)=>((t,e,r)=>{if(t)return Object.fromEntries(Object.entries(t).map((([t,s])=>t in e?[t,r(t,s)]:[t,s])))})(await $(r,t,n),s,(r=>((t,e,r)=>{const s=wt(JSON.stringify(r)).replace("=","");return`${bt}${t}~${e}~${s}${vt}`})(e,r,t)))]:[e,r]}))),s=(t=>Object.entries(t).flatMap((([t,e])=>Object.entries(e).flatMap((([t,e])=>e.map((t=>[t.to,t])))))).reduce(((t,[e,r])=>(t[e]||(t[e]=[]),t[e].push(r),t)),{}))(t),n=Object.fromEntries(Object.entries(r).map((([t,r])=>{const n=s[t];return n?[t,async(t,s)=>$(r,await(async(t,e,r)=>{const s=e.some((e=>e.matches(t)));return Object.fromEntries(await Promise.all(Object.entries(t).map((async([t,e])=>[t,await r(e,s)]))))})(t,n,(async(t,r)=>St(t,r,(async(t,r)=>$(e[t],r,s))))),s)]:[t,r]})));return{url:"tunnel-kit",handlers:n}},Ot=(t,e=[])=>{const r=e.find((e=>"string"==typeof e?e===t:e.node===t));return"string"==typeof r?{node:r}:r};class xt{#A;constructor(t){this.#A=t}async serve(t){const{kits:e}=t,r=this.#A.createServerStream(),s=Et((t=>t.proxy?Object.fromEntries(t.proxy.map((t=>{if("string"!=typeof t&&t.tunnel)return[t.node,yt(t.node,t.tunnel)]})).filter(Boolean)):{})(t),k(e)),n=s.handlers;for await(const e of ot(r.writableResponses,r.readableRequests)){const[r]=e.data;if("end"===r)break;if("proxy"!==r){e.reply(["error",{error:"Expected proxy request.",timestamp:u()}]);continue}const[,{node:s,inputs:o}]=e.data,i=Ot(s.type,t.proxy)?n[s.type]:void 0;if(i)try{const t=await $(i,o,{descriptor:s});if(!t){e.reply(["error",{error:"Handler returned nothing.",timestamp:u()}]);continue}e.reply(["proxy",{outputs:t}])}catch(t){e.reply(["error",{error:t.message,timestamp:u()}])}else e.reply(["error",{error:"Can't proxy a node of this node type.",timestamp:u()}])}}}class Pt{#A;constructor(t){this.#A=t}shutdownServer(){const t=this.#A.createClientStream().writableRequests.getWriter();t.write(["end",{timestamp:u()}]),t.close()}async proxy(t,e){const r=this.#A.createClientStream(),s=r.writableRequests.getWriter(),n=r.readableResponses.getReader();s.write(["proxy",{node:t,inputs:e}]),s.close();const o=await n.read();if(o.done)throw new Error("Unexpected proxy failure: empty response.");const[i]=o.value;if("proxy"===i){const[,{outputs:t}]=o.value;return t}if("error"===i){const[,{error:t}]=o.value;throw new Error(JSON.stringify(t))}throw new Error(`Unexpected proxy failure: unknown response type "${i}".`)}createProxyKit(t=[]){const e=t.map((t=>"string"==typeof t?t:t.node)),r=Object.fromEntries(e.map((t=>[t,{invoke:async(t,e)=>{const r=e.descriptor;return await this.proxy(r,t)}}])));return H(new lt({url:"proxy"}).build(r))}}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Nt=t=>t.base?t.base:"window"in self?new URL(self.location.href):new URL(import.meta.url);class jt{#D;constructor(t){this.#D=t}client(t){return new pt(this.#D.send(t))}server(t){return new ht(this.#D.receive(t))}}const It=async t=>{if("worker"!==t.transport)throw new Error("Only worker transport is supported at this time.");const e="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:(()=>{throw new Error("Not implemented")})(),r=new jt(new dt(e)),s=((t,e)=>t.map((t=>"proxy"in t?new Pt(e.client("proxy")).createProxyKit(t.proxy):t)))(t.kits,r),n=new it(r.server("run")),o=await(async(t,e)=>{const r=t.url;if(r)return r;const s=new V(e.server("load"));return await s.serve()})(t,r),i=Nt(t),a=await G.load(o,{base:i});return n.serve(a,!!t.diagnostics,{kits:s})},Rt=t=>t;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class qt{}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Ct=new U;class At extends qt{id;type;outgoing=[];incoming=[];configuration={};#_;#z;constructor(t,e,r={}){super(),this.#z=e,"string"==typeof t?this.type=t:(this.type="fn",this.#_=t);const{$id:s,...n}=r;this.id=s??Ct.vendId(e,this.type),this.configuration=n}addIncomingEdge(t,e,r,s,n){if(t.#z!==this.#z)throw new Error("Can't connect nodes from different scopes");const o={to:this,from:t,out:e,in:r,schema:n};s&&(o.constant=!0),this.incoming.push(o),t.outgoing.push(o)}#H(t){const e=this.#_??t.getHandler(this.type);return e&&"function"!=typeof e?e.describe:void 0}async invoke(t,e){const r=e??this.#z,s=this.#_??r.getHandler(this.type);let n;const o="function"==typeof s?s:s?.invoke;if(o)n=await o(t,this);else{if(!s||"function"==typeof s||!s.graph)throw new Error(`Can't find handler for ${this.id}`);{const e=s.graph.getPinnedNodes();if(1!==e.length)throw new Error("Expected exactly one graph");n=await r.invokeOneRound(t,e[0])}}return n}async describe(t=this.#z,e,r,s){const n=this.#H(t);return n?await n(e,r,s):void 0}async serialize(t){return this.#z.serialize(t,this)}async serializeNode(){return[{id:this.id,type:this.type,configuration:this.configuration}]}}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Tt{queue=[];inputs=new Map;constants=new Map;controlWires=new Map;haveRun=new Set;queueUp(t){this.queue.includes(t)||this.queue.push(t)}next(){if(!this.queue.length)throw new Error("No nodes in queue");return this.queue.shift()}done(){return 0===this.queue.length}missingInputs(t){if(0===t.incoming.length&&this.haveRun.has(t))return[];const e=new Set(t.incoming.map((t=>t.in))),r=new Set([...Object.keys(t.configuration),...Object.keys(this.constants.get(t)??{})]);for(const[e,s]of(this.inputs.get(t)??new Map).entries())s.length&&r.add(e);this.controlWires.get(t)?.length&&r.add("");const s=[...e].filter((t=>!r.has(t)));return!!s.length&&s}shiftInputs(t){const e={...t.configuration,...this.constants.get(t)},r=this.inputs.get(t)??new Map;for(const[t,s]of r.entries())s.length>0&&(e[t]=s.shift());return this.haveRun.add(t),this.controlWires.delete(t),e}processResult(t,e){const r={nodes:[],unused:[]},s=new Set(Object.keys(e));for(const n of t.outgoing){const t=this.distributeResults(n,e);t.forEach((t=>s.delete(t)));const o=this.missingInputs(n.to);o||this.queueUp(n.to),r.nodes.push({node:n.to,received:t,missing:o})}return r.unused=[...s],r}distributeResults(t,e){const r="*"===t.out?e:""===t.out?{}:void 0!==e[t.out]?{[t.in]:e[t.out]}:{};t.constant&&this.constants.set(t.to,{...this.constants.get(t.to),...r}),this.inputs.has(t.to)||this.inputs.set(t.to,new Map);const s=this.inputs.get(t.to);for(const t of Object.keys(r))s?.has(t)||s?.set(t,[]),s?.get(t)?.push(r[t]);return""===t.in&&this.controlWires.set(t.to,[...this.controlWires.get(t.to)??[],t.from]),Object.keys(r)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Mt{parentLexicalScope;parentDynamicScope;#J={};#G=[];#V=[];constructor(t={}){this.parentLexicalScope=t.lexicalScope,this.parentDynamicScope=t.dynamicScope}addHandlers(t){Object.entries(t).forEach((([t,e])=>this.#J[t]=e))}getHandler(t){return this.#J[t]||this.parentDynamicScope?.getHandler(t)||this.parentLexicalScope?.getHandler(t)}pin(t){this.#G.push(t)}compactPins(){const t=new Set,e=[];for(const r of this.#G){if(t.has(r))continue;e.push(r);this.#K(r).forEach((e=>t.add(e)))}this.#G=e}getPinnedNodes(){return this.#G}addCallbacks(t){this.#V.push(t)}#Q(){return[...this.#V,...this.parentDynamicScope?this.parentDynamicScope.#Q():[]]}async invoke(t,e=new Tt){try{!1!==t&&(t?t instanceof Array?t:[t]:this.#G).flatMap((t=>this.#K(t).filter((t=>!1===e?.missingInputs(t))))).forEach((t=>e?.queueUp(t)));const r=this.#Q();for(;!e.done();){for(const t of r)if(await(t.stop?.(this,e)))return;const t=e.next(),s=e.shiftInputs(t);let n;for(const e of r)n??=await(e.before?.(this,t,s));const o=n??await t.invoke(s,this).catch((t=>({$error:{type:"error",error:t}}))),i=e.processResult(t,o);for(const e of r)await(e.after?.(this,t,s,o,i));if(i.unused.includes("$error"))throw o.$error.error}}finally{for(const t of this.#V)await(t.done?.())}}invokeOneRound(t={},e=void 0,r){let s;"$state"in t&&(r=t.$state,delete t.$state);const n=new Promise((t=>{s=t})),o=new Mt({dynamicScope:this});let i;o.addHandlers({input:async()=>t,output:async t=>(s?.(await t),s=void 0,t)});const a=new Map;let c;o.addCallbacks({stop:(t,e)=>(s||(c=e),!s),after:(t,e,r,s,n)=>{i=e;for(const{node:t,missing:e}of n.nodes)e?a.set(t.id,e.join(", ")):a.delete(t.id)},done:()=>{s?.({$error:{type:"error",error:new Error(`Output node never reach. Last node was ${i?.id}.\n\nThese nodes had inputs missing:\n${Array.from(a,(([t,e])=>`  ${t}: ${e}`)).join("\n")}`)}})}});const u=o.invoke(void 0!==e?e:this.#G,r);return Promise.all([n,u]).then((([t])=>({...t,...c?{$state:c}:{}})))}async serialize(t,e){const r=(e?[e]:this.#G).flatMap((t=>this.#K(t))),s={},n=await Promise.all(r.map((async t=>{const[e,r]=await t.serializeNode();if(r&&(s[e.id]=r),("input"===e.type||"output"===e.type)&&!e.configuration?.schema){const r=await this.#X(t);Object.entries(r.properties??{}).length>0&&(e.configuration={...e.configuration,schema:r})}return e}))),o=r.flatMap((t=>t.outgoing.map((t=>({from:t.from.id,to:t.to.id,out:t.out,in:t.in,...t.constant?{constant:!0}:{}})))));return{...t,edges:o,nodes:n,graphs:s}}#K(t){const e=new Set,r=[t];for(;r.length;){const t=r.shift();e.has(t)||(e.add(t),t.incoming.forEach((t=>r.push(t.from))),t.outgoing.forEach((t=>r.push(t.to))))}return[...e]}async#Y(t){const e=Object.fromEntries(t.incoming.filter((t=>""!==t.out&&"*"!==t.out)).map((t=>[t.out,t.schema??{}]))),r=Object.fromEntries(t.outgoing.filter((t=>""!==t.out&&"*"!==t.out)).map((t=>[t.out,t.schema??{}])));return await t.describe(this,t.configuration,{properties:e},{properties:r})}async#X(t){const e={},r=new Set;if("input"===t.type){const s=new Set;for(const n of t.outgoing)"*"!==n.out&&""!==n.out&&(s.add(n.to),r.add(n.out),n.schema&&(e[n.out]=n.schema));for(const r of s){const s=await this.#Y(r),n=s?.inputSchema?.properties;if(n)for(const s of r.incoming)s.from===t&&n[s.in]&&(e[s.out]={...n[s.in],...e[s.out]})}}else{if("output"!==t.type)throw new Error("Can't yet derive schema for non-input/output nodes");{const s=new Set;for(const n of t.incoming)"*"!==n.out&&""!==n.out&&(s.add(n.from),r.add(n.in),n.schema&&(e[n.in]=n.schema));for(const r of s){const s=await this.#Y(r),n=s?.outputSchema?.properties;if(n)for(const s of r.outgoing)s.to===t&&n[s.out]&&(e[s.in]={...n[s.out],...e[s.in]})}}}for(const t of r)e[t]?(e[t].type||="string",e[t].title||=t):e[t]={type:"string",title:t};const s=(t=>Object.entries(t).map((([t,e])=>{const r=e;if(!r.$optional)return t;delete r.$optional})).filter(Boolean))(e);return{type:"object",properties:e,required:s}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let Ft;function Wt(){return Ft||(Ft=new Lt),Ft}function Bt(t){const e=Wt();return Ft=t,e}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Lt extends Mt{#Z;#tt=[];parentLambdaNode;constructor(t={}){super(t),this.#Z=t.serialize??!1,this.parentLambdaNode=t.parentLambda}async serialize(t,e){return super.serialize(t,e&&"function"==typeof e.unProxy?e.unProxy():e)}serializing(){return this.#Z}asScopeFor(t){return(...e)=>{const r=Bt(this);try{return t(...e)}finally{Bt(r)}}}addClosureEdge(t){this.#tt.push(t)}getClosureEdges(){return this.#tt}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ut{}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Dt=Symbol("IsValue");function _t(t){return("object"==typeof t||"function"==typeof t)&&void 0!==t[Dt]}class zt extends Ut{#et;#z;#rt;#st;#nt;constructor(t,e,r,s=!1,n={}){super(),this.#et=t,this.#z=e,this.#rt="string"==typeof r?{[r]:r}:r,this[Dt]=this,this.#st=s,this.#nt=n}then(t,e){if(1!==Object.keys(this.#rt).length)throw Error("Can't `await` for multiple values");return this.#et.then((e=>e&&t&&this.#z.asScopeFor(t)(e[Object.keys(this.#rt)[0]])),e&&this.#z.asScopeFor(e))}asNodeInput(){return[this.#et.unProxy(),this.#rt,this.#st,this.#nt]}to(t,e){const r=Jt(t)?t.unProxy():new Ht(t,this.#z,e);return r.addInputsFromNode(this.#et,this.#rt,this.#st,this.#nt),r.asProxy()}in(t){let e=Object.fromEntries(Object.entries(this.#rt).map((([t,e])=>[e,t])));_t(t)?(e=t.#ot(e),this.#et.addInputsFromNode(t.#et,e,t.#st,t.#nt)):Jt(t)?this.#et.addInputsFromNode(t.unProxy(),e):this.#et.addInputsAsValues(t)}as(t){let e;if("string"==typeof t){if(1!==Object.keys(this.#rt).length)throw new Error("Can't rename multiple values with a single string");e={[Object.keys(this.#rt)[0]]:t}}else e=this.#ot(t);return new zt(this.#et,this.#z,e,this.#st,this.#nt)}memoize(){return new zt(this.#et,this.#z,this.#rt,!0,this.#nt)}invoke(t){return new Ht("invoke",this.#z,{...t,$board:this}).asProxy()}isUnknown(){return delete this.#nt.type,this}isString(){return this.#nt.type="string",this}isNumber(){return this.#nt.type="number",this}isBoolean(){return this.#nt.type="boolean",this}isArray(){return this.#nt.type="array",this}isImage(t="image/png"){return this.#nt.type=t,this}isObject(){return this.#nt.type="object",this}title(t){return this.#nt.title=t,this}description(t){return this.#nt.description=t,this}format(t){return this.#nt.format=t,this}examples(...t){return this.#nt.examples=t,this}default(t){return this.#nt.default=t,this}optional(){return this.#nt.$optional=!0,this}transient(){return this.#nt.$optional=!0,this}#ot(t){const e={...this.#rt};return Object.entries(t).forEach((([t,r])=>{this.#rt[r]?(e[t]=this.#rt[r],delete this.#rt[r]):e[t]=r})),e}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ht extends At{#it;#at;#ct;#z;#_;constructor(t,e,r={}){const s=!Jt(r)&&!(r instanceof qt)&&!Vt(r)&&!_t(r)&&r.$id;super(t,e,s?{$id:s}:{}),this.#z=e,"string"!=typeof t&&(this.#_=t),Jt(r)?this.addInputsFromNode(r.unProxy()):r instanceof qt?this.addInputsFromNode(r):Vt(r)?this.addInputsAsValues({$board:r.getBoardCapabilityAsValue()}):_t(r)?this.addInputsFromNode(...r.asNodeInput()):(void 0!==r.$id&&delete r.$id,this.addInputsAsValues(r)),this[this.#ut()]=this,this.#it=new Promise(((t,e)=>{this.#at=t,this.#ct=e}))}addInputsAsValues(t){const e={},r=[];Object.entries(t).forEach((([t,s])=>{Vt(s)&&(s=s.getBoardCapabilityAsValue()),_t(s)?r.push(s.as(t).asNodeInput()):s instanceof qt||Jt(s)?r.push([Jt(s)?s.unProxy():s,{[t]:t},!1,void 0]):e[t]=s})),this.configuration={...this.configuration,...e},r.forEach((t=>this.unProxy().addInputsFromNode(...t)))}addInputsFromNode(t,e={"*":""},r,s){const n=Object.entries(e);0===n.length?this.addIncomingEdge(t,"","",r):n.forEach((([e,n])=>{e.startsWith("*-")&&(e="*",n=""),this.unProxy().addIncomingEdge(Jt(t)?t.unProxy():t,e,n,r,s)}))}addIncomingEdge(t,e,r,s,n){const o=t.#z;if(o!==this.#z){for(let t=this.#z;t!==o;t=t.parentLexicalScope)if(!t)throw new Error("Only wires from parent scopes allowed");if("*"===e||""===e)throw new Error("Can't use * or empty wires from parent scopes");this.#z.addClosureEdge({scope:o,from:t,to:this,out:e,in:r})}else super.addIncomingEdge(t,e,r,s,n)}async invoke(t,e){const r=new Lt({dynamicScope:e,lexicalScope:this.#z});return r.asScopeFor((async()=>{try{const e=this.#_??r.getHandler(this.type);let s;const n="function"==typeof e?e:e?.invoke;if(n)s=await n(t,this);else{if(!e||"function"==typeof e||!e.graph)throw new Error(`Can't find handler for ${this.id}`);{const n=e.graph.getPinnedNodes();if(1!==n.length)throw new Error("Expected exactly one graph");s=await r.invokeOneRound(t,n[0])}}for(const[t,e]of Object.entries(s))e instanceof Ht?s[t]=(await e)[t]:_t(e)?s[t]=await e:Vt(e)&&(s[t]=await e.getBoardCapabilityAsValue());return this.#at&&(this.#at(s),this.#at=this.#ct=void 0),s}catch(t){throw this.#ct&&(this.#ct(t),this.#at=this.#ct=void 0),t}}))()}async serializeNode(){for(const[t,e]of Object.entries(this.configuration))e instanceof Promise&&(this.configuration[t]=await e);if("fn"!==this.type)return super.serializeNode();const t=new Lt({lexicalScope:this.#z,serialize:!0}),e=this.#_??t.getHandler(this.type);if(e&&"function"!=typeof e&&e.graph){const r={id:this.id,type:"invoke",configuration:{...this.configuration,path:"#"+this.id}},s=e.graph.getPinnedNodes();if(1!==s.length)throw new Error("Expected exactly one graph");return[r,await t.serialize({},s[0])]}const r="function"==typeof e?e:e?.invoke;if(!r)throw new Error(`Handler for ${this.type} in ${this.id} not found`);let s=r.toString(),n=this.id.replace(/-/g,"_");const o=/(?:async\s*)?(\w+|\([^)]*\))\s*=>\s*/,i=/(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)\s*\{/;if(o.test(s))s=s.replace(o,((t,e)=>{const r=s.trim().startsWith("async")?"async ":"",o=e.startsWith("(")?e:`(${e})`;return`${r}function ${n}${o} `}));else{const t=i.exec(s);if(null===t)throw new Error("Unexpected seralization: "+s);n=t[1]||n}const a=await this.describe(t),c={edges:[{from:`${this.id}-input`,to:`${this.id}-run`,out:"*"},{from:`${this.id}-run`,to:`${this.id}-output`,out:"*"}],nodes:[{id:`${this.id}-input`,type:"input",configuration:a?.inputSchema?{schema:a.inputSchema}:{}},{id:`${this.id}-run`,type:"runJavascript",configuration:{...this.configuration,code:s,name:n,raw:!0}},{id:`${this.id}-output`,type:"output",configuration:a?.outputSchema?{schema:a.outputSchema}:{}}]};return[{id:this.id,type:"invoke",configuration:{path:"#"+this.id}},c]}asProxy(){return new Proxy(this,{get(t,e,r){if("string"==typeof e){const r=new zt(t,t.#z,e);let s=t[e];return s=s&&"function"==typeof s?s.bind(t):(t=>r.invoke(t)).bind(r),new Proxy(s,{get(t,e,s){const n=Reflect.get(r,e,r);return"function"==typeof n?n.bind(r):n},ownKeys:t=>Reflect.ownKeys(r).filter((t=>"string"==typeof t))})}return Reflect.get(t,e,r)},ownKeys:t=>[t.#ut()]})}unProxy(){return this}then(t,e){if(this.#z.serializing())throw new Error(`Can't \`await\` on ${this.id} in board declaration. Did you mean to use \`code\` instead of \`board\`?`);try{return this.#z.invoke(this).catch((t=>{if(e)return Promise.reject(t).catch(this.#z.asScopeFor(e));throw t})),this.#it.then(t&&this.#z.asScopeFor(t),e&&this.#z.asScopeFor(e))}catch(t){if(e)return Promise.reject(t).catch(this.#z.asScopeFor(e));throw t}}to(t,e){const r=Jt(t)?t.unProxy():new Ht(t,this.#z,e);return r.addInputsFromNode(this,{"*":""}),r.asProxy()}in(t){return t instanceof At?this.addInputsFromNode(t):_t(t)?this.addInputsFromNode(...t.asNodeInput()):this.addInputsAsValues(t),this.asProxy()}as(t){return new zt(this,this.#z,t)}keys(){return[this.#ut()]}#ut(){return"*-"+this.id}}function Jt(t){return"function"==typeof t.unProxy}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Gt(t,e){return t&&function(t,e){Wt().addHandlers({[t]:e})}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */(t,e),r=>new Ht(t??e,Wt(),r).asProxy()}function Vt(t){return"function"==typeof t&&"function"==typeof t.getBoardCapabilityAsValue}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Kt=async()=>{throw new Error("Reserved word handler should never be invoked")};Gt("input",Kt),Gt("output",Kt);class Qt{#dt;#pt;#ht;constructor(t,e){this.#dt=t,this.#pt={...e,method:"POST",headers:{"Content-Type":"application/json"}},this.#ht=this.#pt.fetch??globalThis.fetch.bind(globalThis)}createClientStream(){let t;const e=new Promise((e=>{t=e})),r=this;return{readableResponses:new ReadableStream({async pull(t){const r=(await e).getReader();for(;;){const e=await r.read();if(e.done)break;console.log("%cServer-Sent Event Chunk","background: #009; color: #FFF",e.value),t.enqueue(e.value)}t.close()}}),writableRequests:new WritableStream({async write(e,s){if(!t)throw new Error("HTTPClientTransport supports only one write per stream instance.");const n=await r.#ht(r.#dt,{...r.#pt,body:JSON.stringify(e)});n.ok||s.error(new Error(`HTTP error: ${n.status}`)),t(n.body?.pipeThrough(new TextDecoderStream).pipeThrough((()=>{let t=[];return new TransformStream({transform(e,r){const s=!e.endsWith("\n"),n=e.split("\n").filter(Boolean);for(t.length&&!s&&(r.enqueue(`${t.join("")}${n.shift()}`),t=[]);n.length>1;)r.enqueue(n.shift());const o=n.shift();o&&(s?t.push(o):r.enqueue(o))},flush(){if(t.length)throw new Error("Unexpected end of stream.")}})})()).pipeThrough(new TransformStream({transform(t,e){t.startsWith("data: ")&&e.enqueue(t.slice(6))}})).pipeThrough((()=>{const t=new TransformStream,e=t.writable.getWriter();return new TransformStream({transform(r,s){const n=tt(r,(e=>{if(0!==e)throw new Error("HTTPClientTransport does not support multiple streams at the moment.");return t.readable})),[o]=Array.isArray(n)?n:[];"http-stream-chunk"===o?e.write(n[1].chunk):"http-stream-end"===o?e.close():s.enqueue(n)}})})())),t=void 0}})}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Xt=t=>{const e=(()=>{if("nodestart"===t.type)return t.state})(),r=structuredClone(t.data);return{type:t.type,data:r,state:e,reply:async()=>{}}},Yt=t=>{const{type:e,node:r,timestamp:s}=t;if("input"===e){const{inputArguments:s}=t;return{type:e,data:{node:r,inputArguments:s},reply:async e=>{t.inputs=e.inputs}}}if("output"===e){const{outputs:n}=t;return{type:e,data:{node:r,outputs:n,timestamp:s},reply:async()=>{}}}throw new Error(`Unknown result type "${e}".`)},Zt=()=>({type:"end",data:{timestamp:u()},reply:async()=>{}}),te=t=>({type:"error",data:{error:t,timestamp:u()},reply:async()=>{}});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ee=t=>{const e=new lt({url:"secret-asking-kit"}).build({secrets:async e=>{const{keys:r}=e;if(!r)return{};let s={};return await t({type:"secret",data:{keys:r,timestamp:u()},reply:async t=>{s=t.inputs}}),s}});return H(e)},re=t=>{const e=new URL(t,location.href),r=new Blob([`import "${e}";`],{type:"text/javascript"}),s=URL.createObjectURL(r);return new Worker(s,{type:"module"})};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const se=t=>{const e=t.proxy?.[0];if(!e)return t.kits;if("http"!==e.location)throw new Error("Only HTTP node proxy server is supported at this time.");if(!e.url)throw new Error("No node proxy server URL provided.");return[new Pt(new Qt(e.url)).createProxyKit(e.nodes),...t.kits]};async function*ne(t){if(t.remote){if("worker"!==t.remote.type)throw new Error(`Unsupported harness configuration: ${JSON.stringify(t,null,2)}`);{const e=t.remote&&t.remote.url;if(!e)throw new Error("Worker harness requires a worker URL");yield*async function*(t,e,r){const s=re(t),n=new dt(s),o=new K(new pt(n.send("load"))),i=new xt(new ht(n.receive("proxy"))),a=new ct(new pt(n.send("run")));await o.load(e.url),yield*M((async t=>{const s=[ee(t),...e.kits],n=e.proxy?.[0]?.nodes;i.serve({kits:s,proxy:n});for await(const e of a.run(r))await t(e)}))}(e,t)}}else yield*M((async e=>{const r=[ee(e),...se(t)];for await(const s of async function*(t,e){yield*M((async r=>{const s=Nt(t),n=await G.load(t.url,{base:s});try{const s=t.diagnostics?new Q((async t=>{await r(Xt(t))})):void 0;for await(const t of n.run({probe:s,kits:e}))await r(Yt(t));await r(Zt())}catch(t){let e=t,s="";for(;e?.cause;)e=e.cause.error??{name:"Unexpected Error",message:JSON.stringify(e.cause,null,2)},e&&"message"in e&&(s+=`\n${e.message}`);console.error(s,e),await r(te(s))}}))}(t,r))await e(s)}))}export{ee as createSecretAskingKit,re as createWorker,Rt as defineServeConfig,ne as run,It as serve};
//# sourceMappingURL=harness.min.js.map
