/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class e{static computeMissingInputs(e,t,s){const r=[...new Set(e.filter((e=>!!e.in&&!e.optional)).map((e=>e.in||"")))],n=new Set;return Object.keys(t).forEach((e=>n.add(e))),s.configuration&&Object.keys(s.configuration).forEach((e=>n.add(e))),r.filter((e=>!n.has(e)))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class t{state=new Map;constants=new Map;#e(e,t,s,r){let n=e.get(t);n||(n=new Map,e.set(t,n));let a=n.get(s);a||(a=[],n.set(s,a)),a.push(r)}wireOutputs(e,t){if(0!==e.filter((t=>t.from!=e[0].from)).length)throw new Error("All opportunities must be from the same node");e.forEach((e=>{const s=e.to,r=e.out,n=e.constant?this.constants:this.state;if(r)if("*"===r)for(const e in t){const r=t[e];null!=r&&null!=r&&this.#e(n,s,e,r)}else if(e.in){const a=t[r];null!=a&&null!=a&&this.#e(n,s,e.in,a)}}))}getAvailableInputs(e){const t={};for(const s of[this.constants.get(e),this.state.get(e)])if(s)for(const[e,r]of s.entries())0!==r.length&&(t[e]=r[0]);return t}useInputs(e,t){const s=this.state.get(e);if(s)for(const e in t){const t=s.get(e);t&&t.shift()}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class s{descriptor;inputs;missingInputs;opportunities;newOpportunities;state;outputsPromise;pendingOutputs;constructor(e,t,s,r,n,a,i){this.descriptor=e,this.inputs=t,this.missingInputs=s,this.opportunities=r,this.newOpportunities=n,this.state=a,this.pendingOutputs=i}get skip(){return this.missingInputs.length>0}static fromObject(e){const r=new t;return r.constants=e.state.constants,r.state=e.state.state,new s(e.descriptor,e.inputs,e.missingInputs,e.opportunities,e.newOpportunities,r,e.pendingOutputs)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class r{graph;#t;#s;constructor(e,t,s=!0){this.graph=e,this.#t=t,this.#s=s}static#r(e,t){const{promiseId:s,outputs:r,newOpportunities:n}=t;e.pendingOutputs.delete(s);const a=r.$error?n.filter((e=>"$error"===e.out)):n;if(e.opportunities.push(...a),e.state.wireOutputs(a,r),r.$error){if(0===a.length)throw new Error("Uncaught exception in node handler. Catch by wiring up the $error output.",{cause:r.$error});globalThis.console.warn("Error in node handler, passing to the wired $error output.",r.$error,a)}}static async processAllPendingNodes(e){return(await Promise.all(e.pendingOutputs.values())).forEach((t=>{r.#r(e,t)})),e}async next(){if(!this.#t.skip){const{inputs:e,outputsPromise:t,newOpportunities:s,descriptor:r}=this.#t;this.#t.state.useInputs(r.id,this.#t.inputs);const n=Symbol(),a=new Promise((a=>{(t||Promise.resolve({})).then((t=>{if(t.$error){const s=t.$error;t.$error={descriptor:r,...s,inputs:{...e,...s.inputs}}}a({promiseId:n,outputs:t,newOpportunities:s})})).catch((t=>{a({promiseId:n,outputs:{$error:{kind:"error",error:t,inputs:e,descriptor:r}},newOpportunities:s.filter((e=>"$error"===e.out))})}))}));this.#t.pendingOutputs.set(n,a)}for(;(0===this.#t.opportunities.length||this.#s)&&this.#t.pendingOutputs.size>0;)r.#r(this.#t,await Promise.race(this.#t.pendingOutputs.values()));if(0===this.#t.opportunities.length)return{done:!0,value:null};const t=this.#t.opportunities.shift(),{heads:n,nodes:a,tails:i}=this.graph,o=t.to,c=a.get(o);if(!c)throw new Error(`No node found for id "${o}"`);const d=n.get(o)||[],u=this.#t.state.getAvailableInputs(o),p=e.computeMissingInputs(d,u,c),l=i.get(o)||[],h={...c.configuration,...u};return this.#t=new s(c,h,p,this.#t.opportunities,l,this.#t.state,this.#t.pendingOutputs),{done:!1,value:this.#t}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class n{tails=new Map;heads=new Map;nodes=new Map;entries=[];constructor(e){this.tails=e.edges.reduce(((e,t)=>{const s=t.from;return e.has(s)?e.get(s)?.push(t):e.set(s,[t]),e}),new Map),this.heads=e.edges.reduce(((e,t)=>{const s=t.to;return e.has(s)?e.get(s)?.push(t):e.set(s,[t]),e}),new Map),this.nodes=e.nodes.reduce(((e,t)=>(e.set(t.id,t),e)),new Map),this.entries=Array.from(this.tails.keys()).filter((e=>!this.heads.has(e)||0===this.heads.get(e)?.length))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class a{graph;previousResult;constructor(e,t){this.graph=new n(e),this.previousResult=t}[Symbol.asyncIterator](){return this.start()}start(){if(this.previousResult)return new r(this.graph,this.previousResult);const{entries:e}=this.graph;if(0===e.length)throw new Error("No entry node found in graph.");const n=e.map((e=>({from:"$entry",to:e}))),a=new s({id:"$empty",type:"$empty"},{},[],n,[],new t,new Map);return new r(this.graph,a)}static async prepareToSave(e){return await r.processAllPendingNodes(e)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const i=(e,t)=>t instanceof Map?{$type:"Map",value:Array.from(t.entries())}:t,o=(e,t)=>{const{$type:s}=t||{};return"Map"==s&&t.value?new Map(t.value):t},c=async(e,t)=>{const s=await a.prepareToSave(t);return JSON.stringify({state:s,type:e},i)},d=e=>{const{state:t,type:r}=JSON.parse(e,o);return{state:s.fromObject(t),type:r}},u=()=>globalThis.performance.now()
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */;class p{#n;#a;#i;#o;constructor(e,t,s,r){this.#a=e,this.#n=t,this.#i=s,this.#o=r}get invocationId(){return this.#o}get type(){return this.#n}get node(){return this.#a.descriptor}get inputArguments(){return this.#a.inputs}set inputs(e){this.#a.outputsPromise=Promise.resolve(e)}get outputs(){return this.#a.inputs}get state(){return this.#a}async save(){return c(this.#n,this.#a)}get runState(){return this.#i}get timestamp(){return u()}isAtExitNode(){return 0===this.#a.newOpportunities.length&&0===this.#a.opportunities.length&&0===this.#a.pendingOutputs.size}static load(e){const{state:t,type:s}=d(e);return new p(t,s,void 0,0)}}class l extends p{constructor(e,t,s){super(e,"input",t,s)}get outputs(){throw new Error('Outputs are not available in the "input" stage')}}class h extends p{constructor(e,t){super(e,"output",void 0,t)}get inputArguments(){throw new Error('Input arguments are not available in the "output" stage')}set inputs(e){throw new Error('Setting inputs is not available in the "output" stage')}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const f=(e,t,s)=>{const r=new URL(t,e),n=r.hash,a=r.href,i="file:"===r.protocol?decodeURIComponent(r.pathname):void 0,o=e.href.replace(e.hash,""),c=a.replace(n,"");if(o==c&&n)return s.push({type:"hash",location:n.substring(1),href:a}),!0;const d=i?{type:"file",location:i,href:a}:a?{type:"fetch",location:c,href:a}:{type:"unknown",location:"",href:a};return s.push(d),!n},m=async e=>{if(void 0===globalThis.process)throw new Error("Unable to use `path` when not running in node");let t;if("function"==typeof require){const{readFile:e}=require("node:fs/promises");t=e}else{const{readFile:e}=await import("node:fs/promises");t=e}return JSON.parse(await t(e,"utf-8"))},g=async e=>{const t=await fetch(e);return await t.json()};class y{loaders;graphs;constructor(e){this.loaders={file:m,fetch:g,hash:async t=>{if(!e)throw new Error("No sub-graphs to load from");return e[t]},unknown:async()=>{throw new Error("Unable to determine Board loader type")}}}async load(e){const t=await this.loaders[e.type](e.location);return t.url=e.href,t}}class v{#c;#d;constructor({base:e,graphs:t}){this.#c=e,this.#d=t}async load(e){const t=[];let s,r=this.#c;for(;!f(r,e,t);)r=new URL(t[t.length-1].href);let n=this.#d,a=!0;for(const e of t){"file"!==e.type&&"fetch"!==e.type||(a=!1);const t=new y(n);s=await t.load(e),n=s.graphs}if(!s)throw new Error("BoardLoader failed to load a graph. This error likely indicates a bug in the BoardLoader.");return{graph:s,isSubgraph:a}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ReadableStream.prototype[Symbol.asyncIterator]||(ReadableStream.prototype[Symbol.asyncIterator]=async function*(){const e=this.getReader();try{for(;;){const{done:t,value:s}=await e.read();if(t)return;yield s}}finally{e.releaseLock()}});class b{writable;readable;controller=null;constructor(){this.writable=new WritableStream({write:e=>this.write(e)}),this.readable=new ReadableStream({start:e=>{this.controller=e}})}write(e){(new TextDecoder).decode(e).split("\n").map((e=>e.trim())).filter((e=>e.length>0)).forEach((e=>{try{if("stop"===e)return void this.controller?.close();const t=JSON.parse(e);this.controller?.enqueue(t)}catch(e){console.error(e)}}))}}const _=async(e,t,s)=>{const r=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inputs:t,state:s})});return r.body?.pipeThrough(new b)};async function*w(e){let t,s;for(;;){const r=await _(e,t,s);if(!r)break;for await(const e of r)s=JSON.stringify(e.state),yield e,t=e.inputs;if(!s)break}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const k=async(e,t,s)=>{const r=(e=>{if(e instanceof Function)return e;if(e.invoke)return e.invoke;throw new Error("Invalid handler")})(e);return new Promise((e=>{r(t,s).then(e).catch((t=>{e({$error:{error:t}})}))}))},x=e=>e&&e.replace(/-/g,""),S=(e,t="")=>{if(!e)return"";const s=e.id,r=`${t?`${x(t)}_`:""}${x(s)}`,n=e.type,a=`"${n} <br> id='${s}'"`;switch(n){case"include":return`${r}[[${a}]]:::include`;case"slot":return`${r}((${a})):::slot`;case"passthrough":return`${r}((${a})):::passthrough`;case"input":return`${r}[/${a}/]:::input`;case"secrets":return`${r}(${a}):::secrets`;case"output":return`${r}{{${a}}}:::output`;default:return`${r}[${a}]`}};class P{nodeMap;edges;nodes;idPrefix;subgraphs;constructor(e,t=""){const{edges:s,nodes:r}=e;this.nodeMap=new Map(r.map((e=>[e.id,e]))),this.edges=s,this.nodes=r,this.idPrefix=t,this.subgraphs=e.graphs||{}}handleSlotted(e,t){const s=t?`${x(t)}_`:"";if("include"!==e.type)return"";const r=e.configuration?.slotted;if(!r)return"";return Object.entries(r).map((([t,r])=>this.describeSubgraph(r,t,"slotted",e,`${s}${e.id}`))).join("\n")}handleLambda(e,t){const s=t?`${x(t)}_`:"",r=e.configuration?.board;if(!r)return"";const n=r;if("board"!==n.kind)return"";const a=n.board;return this.describeSubgraph(a,e.id,"lamdba",e,`${s}${e.id}`)}describeSubgraphs(e,t=""){const s=this.nodeMap.get(e.from);if(!s)return"";const r=this.handleLambda(s,t);return`${this.handleSlotted(s,t)}${r}`}describeSubgraph(e,t,s,r,n){const a=new P(e,n).describeGraph(),i=this.idPrefix?`${x(this.idPrefix)}_`:"",o=s&&r?`sg_${x(t)}:::slotted -- "${s}->${s}" --o ${i}${x(r.id)}\n`:"";return`\nsubgraph sg_${x(t)} [${t}]\n${a}\nend\n${o}`}describeGraph(e=!1){return[...this.edges.map((t=>{const s=((e,t,s="")=>{const r=e.from,n=S(t.get(r),s),a=e.to,i=S(t.get(a),s),o=e.in,c=e.out,d=e.optional,u=e.constant;return"*"===c?`${n} -- all --\x3e ${i}`:c&&o?d?`${n} -. "${c}->${o}" .-> ${i}`:u?`${n} -- "${c}->${o}" --o ${i}`:`${n} -- "${c}->${o}" --\x3e ${i}`:`${n} --\x3e ${i}`})(t,this.nodeMap,this.idPrefix);return`${s}${e?"":this.describeSubgraphs(t,this.idPrefix)}`})),...e?"":Object.entries(this.subgraphs).map((([e,t])=>this.describeSubgraph(t,e,void 0,void 0,`${e}${this.idPrefix}`)))].join("\n")}}const O=(e,t="TD",s=!1,r=!1)=>{const n=new P(e).describeGraph(r);return s?((e,t)=>`graph ${t};\n${e}`)(n,t):((e,t)=>`%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%\ngraph ${t};\n${e}\nclassDef default stroke:#ffab40,fill:#fff2ccff,color:#000\nclassDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000\nclassDef output stroke:#38761d,fill:#b6d7a8ff,color:#000\nclassDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef slot stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef config stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef secrets stroke:#db4437,fill:#f4cccc,color:#000\nclassDef slotted stroke:#a64d79`)(n,t)},E=e=>null==e?"null":Array.isArray(e)?"array":typeof e;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Z{additionalProperties=!1;required=[];properties={};build(){const e={type:"object",properties:this.properties,additionalProperties:this.additionalProperties};return this.required.length>0&&(e.required=this.required),e}setAdditionalProperties(e){return void 0!==e&&(this.additionalProperties=e),this}addInputs(e){return e?(Object.entries(e).forEach((([e,t])=>{this.addProperty(e,{type:E(t)})})),this):this}addProperty(e,t){return this.properties[e]=t,this}addProperties(e){return Object.entries(e).forEach((([e,t])=>{this.addProperty(e,t)})),this}addRequired(e){return e?("string"==typeof e?this.required=[...this.required,e]:Array.isArray(e)&&e.length>0&&(this.required=[...this.required,...e]),this):this}static empty(e=!1){return(new Z).setAdditionalProperties(e).build()}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const $=(e,t={},s)=>{const r=t.title??t?.url;return`Missing ${s?"required ":""}input "${e}"${r?` for board "${r}".`:"."}`},N=async(e,t,s,r)=>{if(!t.requestInput)return;const n=await r.outputsPromise??{},a=new T(n,r.inputs);r.outputsPromise=a.read(j(e,t,s))},j=(e,t,s)=>async(r,n,a)=>{if(a)throw new Error($(r,e,a));if(void 0!==n.default)return"type"in n&&"string"!==n.type?JSON.parse(n.default):n.default;const i=await(t.requestInput?.(r,n,s));if(void 0===i)throw new Error($(r,e,a));return i};class T{#u;#p;constructor(e,t){this.#u=e,this.#p=t}async read(e){if(!("schema"in this.#p))return this.#u;const t=this.#p.schema;if(!t.properties)return this.#u;const s=Object.entries(t.properties),r={};for(const[n,a]of s){if(n in this.#u){r[n]=this.#u[n];continue}const s=t.required?.includes(n)??!1,i=await e(n,a,s);r[n]=i}return{...this.#u,...r}}}class I{#l;#h=new Map;constructor(e){this.#l=e}createHandler(e,t){return async(s,r,n)=>{const a=this.#h.get(s);if(void 0!==a)return a;const i={id:n.id,type:n.type},o={...t,descriptor:i,inputs:{schema:{type:"object",properties:{[s]:r}}}};await e(new l(o,void 0,-1));const c=await o.outputsPromise;let d=c&&c[s];return void 0===d&&(d=await(this.#l.requestInput?.(s,r,i))),r.transient||this.#h.set(s,d),d}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const C=()=>{};class A{#f=[];#m=C;#g;#y;abort=C;constructor(){this.#v()}#v(){this.#g=new Promise(((e,t)=>{this.#m=e,this.abort=t}))}#b(e){this.#f.push(e),1==this.#f.length&&(this.#m(),this.#v())}async write(e){return new Promise((t=>{this.#b({value:e,receipt:t})}))}async read(){this.#y&&this.#y(),0===this.#f.length&&await this.#g;const e=this.#f.shift();if(!e)throw new Error("asyncGen queue should never be empty.");return this.#y=e.receipt,e.value?{done:!1,value:e.value}:{done:!0,value:void 0}}close(){this.#b({value:void 0,receipt:C})}}class M{#_;#w=!0;#f=new A;constructor(e){this.#_=e}async#k(e){return this.#f.write(e)}async next(){return this.#w&&(this.#w=!1,this.#_(this.#k.bind(this)).then((()=>{this.#f.close()})).catch((e=>{this.#f.abort(e)}))),this.#f.read()}}const R=e=>({[Symbol.asyncIterator]:()=>new M(e)});
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class L{#x;#S;constructor(e){this.#x=structuredClone(e)||[]}onGraphStart(){this.#x.push({graph:0,node:0})}onNodeStart(e){this.#x[this.#x.length-1].node++,this.#S=e}onNodeEnd(){}onGraphEnd(){}async state(){const e=structuredClone(this.#x);return this.#S&&(e[e.length-1].state=await c("nodestart",this.#S)),e}}const z=e=>{const{state:t}=e[e.length-1];return t?d(t).state:void 0};var q="https://raw.githubusercontent.com/breadboard-ai/breadboard/@google-labs/breadboard-schema@1.2.0/packages/schema/breadboard.schema.json";
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class D{url;title;description;$schema;version;edges=[];nodes=[];kits=[];graphs;args;#P={};#O=[];#E;constructor({url:e,title:t,description:s,version:r,$schema:n}={$schema:q}){Object.assign(this,{$schema:n??q,url:e,title:t,description:s,version:r})}async*run(e={},t){const s=e.base||new URL(this.url||"",import.meta.url);yield*R((async r=>{const{probe:n}=e,i=await D.handlersFromBoard(this,e.kits),o={...this.#P,...e.slots};this.#O.forEach((e=>e.addGraph(this)));const c=new a(this,t?.state),d=new I(e),p=e.invocationPath||[],f=new L(e.state);await(n?.report?.({type:"graphstart",data:{metadata:this,path:p,timestamp:u()}}));let m=0;f.onGraphStart();const g=()=>[...p,m];for await(const t of c){m++;const{inputs:a,descriptor:c,missingInputs:p}=t;if(t.skip){await(n?.report?.({type:"skip",data:{node:c,inputs:a,missingInputs:p,path:g(),timestamp:u()}}));continue}let y;if(f.onNodeStart(t),await(n?.report?.({type:"nodestart",data:{node:c,inputs:a,path:g(),timestamp:u()},state:await f.state()})),"input"===c.type)await r(new l(t,await f.state(),m)),await N(this,e,c,t),y=t.outputsPromise;else if("output"===c.type)await r(new h(t,m)),y=t.outputsPromise;else{const n=i[c.type];if(!n)throw new Error(`No handler for node type "${c.type}"`);const u={...e,board:this,descriptor:c,outerGraph:this.#E||this,base:s,slots:o,kits:[...e.kits||[],...this.kits],requestInput:d.createHandler(r,t),invocationPath:g(),state:await f.state()};y=k(n,a,u)}f.onNodeEnd(),await(n?.report?.({type:"nodeend",data:{node:c,inputs:a,outputs:await y,validatorMetadata:this.#O.map((e=>e.getValidatorMetadata(c))),path:g(),timestamp:u()}})),t.outputsPromise=y}f.onGraphEnd(),await(n?.report?.({type:"graphend",data:{metadata:this,path:p,timestamp:u()}}))}))}get validators(){return this.#O}async runOnce(e,t={}){const s={...e,...this.args},{probe:r}=t;if(t.board&&t.descriptor)for(const e of t.board.validators)this.addValidator(e.getSubgraphValidator(t.descriptor,Object.keys(s)));try{let e={};const n=t.invocationPath||[];for await(const a of this.run(t))if("input"===a.type)a.inputs=s;else if("output"===a.type){e=a.outputs,await(r?.report?.({type:"nodeend",data:{node:a.node,inputs:a.inputs,outputs:e,path:[...n,a.invocationId],timestamp:u()}})),await(r?.report?.({type:"graphend",data:{metadata:this,path:n,timestamp:u()}}));break}return e}catch(e){if(e.cause)return{$error:e.cause};throw e}}addValidator(e){this.#O.push(e)}mermaid(e="TD",t=!1,s=!1){return O(this,e,t,s)}static async fromGraphDescriptor(e){const t=new D(e);return t.edges=e.edges,t.nodes=e.nodes,t.graphs=e.graphs,t.args=e.args,t}static async load(e,t){const{base:s,slotted:r,outerGraph:n}=t||{},a=new v({base:s,graphs:n?.graphs}),{isSubgraph:i,graph:o}=await a.load(e),c=await D.fromGraphDescriptor(o);return i&&(c.#E=n),c.#P=r||{},c}static async fromBreadboardCapability(e){if("board"!==e.kind||!e.board)throw new Error(`Expected a "board" Capability, but got ${e}`);const t=e.board;if(!(t.edges&&t.kits&&t.nodes))throw new Error('Supplied "board" Capability argument is not actually a board');let s=e.board;return s.runOnce||(s=await D.fromGraphDescriptor(t)),s}static async handlersFromBoard(e,t=[]){return(e=>e.reduce(((e,t)=>({...t.handlers,...e})),{}))([new F,...t,...e.kits])}static runRemote=w}class F{handlers;constructor(){this.handlers={lambda:{describe:async e=>({inputSchema:(new Z).setAdditionalProperties(!0).addInputs(e).addProperty("board",{title:"board",description:"The board to run.",type:"object"}).build(),outputSchema:(new Z).addProperty("board",{title:"board",description:"The now-runnable board.",type:"object"}).build()}),invoke:async e=>{const{board:t,...s}=e;if(!t||"board"!==t.kind||!t.board)throw new Error('Lambda node requires a BoardCapability as "board" input');const r={...await D.fromBreadboardCapability(t),args:s};return{board:{...t,board:r}}}}}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class V{#Z=new Map;vendId(e,t){let s=this.#Z.get(e)||0;return s++,this.#Z.set(e,s),`${t}-${s}`}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const U=/^((?<a>.*)(?<dir><-|->))?(?<b>[^(.|?)]*)(?<q>\.|\?)?$/m,B=new V;class K{#$;#N;constructor(e,t,s,r,n){if(this.#N=e.currentBoardToAddTo(),this.#$={id:n??B.vendId(this.#N,s),type:s},r&&(e=>Object.values(e).length>0)(r)){const e=Object.entries(r).filter((([e,t])=>t instanceof K));for(const[t,s]of e){if(delete r[t],-1!==t.indexOf("->"))throw Error("Cannot pass output wire in confdig");this.wire(-1===t.indexOf("<-")?`${t}<-.`:t,s)}this.#$.configuration=r}t?.url&&!this.#N.kits.find((e=>e.url===t.url))&&this.#N.kits.push(t),this.#N.addNode(this.#$)}wire(e,t){const{ltr:s,edge:r}=(e=>{const t={ltr:!0},s=e.match(U);if(!s)throw new Error(`Invalid edge spec: ${e}`);const{a:r,b:n,dir:a,q:i}=s?.groups,o="<-"!==a;t.ltr=o;const c="?"===i,d="."===i;return t.edge={},d&&(t.edge.constant=!0),c&&(t.edge.optional=!0),r||n?"*"===r||"*"===n?(t.edge.out="*",t):r?n?(o?(t.edge.out=r,t.edge.in=n):(t.edge.out=n,t.edge.in=r),t):(t.edge.out=r,t.edge.in=r,t):(t.edge.out=n,t.edge.in=n,t):t})(e),[n,a]=s?[this,t]:[t,this],i={from:n.#$.id,to:a.#$.id,...r};return n.#N!==a.#N?a.#N.addEdgeAcrossBoards(i,n.#N,a.#N):this.#N.addEdge(i),this}get id(){return this.#$.id}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const W=e=>new e({create:()=>{throw Error("Node instantiation can't (yet) happen during runtime")}}),G=(e,t)=>{const s=void 0!==t.nodes&&void 0!==t.edges&&void 0!==t.kits,r=s||"function"==typeof t||t instanceof K||"board"===t.kind&&t.board?{board:s?{kind:"board",board:t}:t}:t;return"function"==typeof r.board&&(r.board=e.lambda(r.board)),r};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class H extends D{#j=[];#T;#I=[];input(e={}){const{$id:t,...s}=e;return new K(this,void 0,"input",{...s},t)}output(e={}){const{$id:t,...s}=e;return new K(this,void 0,"output",{...s},t)}lambda(e,t={}){const{$id:s,...r}=t;let n,a;if("function"==typeof e){n=new H,a=n.input();const t=n.output();n.#T=this.#T??this,n.#T.#j.push(n),e(n,a,t),n.#T.#j.pop()}else n=e;const i=new K(this,void 0,"lambda",{board:{kind:"board",board:n},...r},s);if(a&&n.#I.length>0){for(const{edge:e,from:t,to:s}of n.#I){if(s!==n||!e.constant)throw new Error("Across board wires: Must be constant and from parent to child");const r=`$l-${e.to}-${e.in}`;n.addEdge({...e,from:a.id,out:r});const o={...e,to:i.id,in:r};t===this?this.addEdge(o):this.addEdgeAcrossBoards(o,t,this)}n.#I=[]}return i}addEdge(e){this.edges.push(e)}addNode(e){this.nodes.push(e)}addKit(e){const t=((e,t)=>new e({create:(...e)=>new K(t,...e),getConfigWithLambda:e=>G(t,e)}))(e,this);return this.kits.push(t),t}currentBoardToAddTo(){const e=this.#T?this.#T.#j:this.#j;return 0===e.length?this:e[e.length-1]}addEdgeAcrossBoards(e,t,s){if("*"===e.out)throw new Error("Across board wires: * wires not supported");if(!e.constant)throw new Error("Across board wires: Must be constant for now");if(s!==this)throw new Error("Across board wires: Must be invoked on to board");const r=this.#T?this.#T.#j:this.#j;if(t!==this.#T&&!r.includes(t))throw new Error("Across board wires: From must be parent of to");this.#I.push({edge:e,from:t,to:s})}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const J="stream";class Q{kind=J;stream;constructor(e){this.stream=e}}const Y=e=>{const[t,s]=e.stream.tee();return e.stream=t,s},X=e=>{const t=e;return t&&t.kind&&t.kind===J&&t.stream instanceof ReadableStream},ee=()=>{ReadableStream.prototype[Symbol.asyncIterator]||(ReadableStream.prototype[Symbol.asyncIterator]=async function*(){const e=this.getReader();try{for(;;){const{done:t,value:s}=await e.read();if(t)return;yield s}}finally{e.releaseLock()}})},te=e=>new ReadableStream({async pull(t){const{value:s,done:r}=await e.next();r?t.close():t.enqueue(s)}});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function se(e){return Object.fromEntries(Object.entries(e.handlers).map((([e,t])=>{const s=t instanceof Function?t:t.invoke,r=t instanceof Function?void 0:t.describe;return[e,{invoke:async e=>s(await e,{}),...r?{describe:r}:{}}]})))}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class re{}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const ne=new V;class ae extends re{id;type;outgoing=[];incoming=[];configuration={};#C;#A;constructor(e,t,s={}){super(),this.#A=t,"string"==typeof e?this.type=e:(this.type="fn",this.#C=e);const{$id:r,...n}=s;this.id=r??ne.vendId(t,this.type),this.configuration=n}addIncomingEdge(e,t,s,r,n){if(e.#A!==this.#A)throw new Error("Can't connect nodes from different scopes");const a={to:this,from:e,out:t,in:s,schema:n};r&&(a.constant=!0),this.incoming.push(a),e.outgoing.push(a)}#M(e){const t=this.#C??e.getHandler(this.type);return t&&"function"!=typeof t?t.describe:void 0}async invoke(e,t){const s=t??this.#A,r=this.#C??s.getHandler(this.type);let n;const a="function"==typeof r?r:r?.invoke;if(a)n=await a(e,this);else{if(!r||"function"==typeof r||!r.graph)throw new Error(`Can't find handler for ${this.id}`);{const t=r.graph.getPinnedNodes();if(1!==t.length)throw new Error("Expected exactly one graph");n=await s.invokeOneRound(e,t[0])}}return n}async describe(e=this.#A,t,s,r){const n=this.#M(e);return n?await n(t,s,r):void 0}async serialize(e){return this.#A.serialize(e,this)}async serializeNode(){return[{id:this.id,type:this.type,configuration:this.configuration}]}}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class ie{queue=[];inputs=new Map;constants=new Map;controlWires=new Map;haveRun=new Set;queueUp(e){this.queue.includes(e)||this.queue.push(e)}next(){if(!this.queue.length)throw new Error("No nodes in queue");return this.queue.shift()}done(){return 0===this.queue.length}missingInputs(e){if(0===e.incoming.length&&this.haveRun.has(e))return[];const t=new Set(e.incoming.map((e=>e.in))),s=new Set([...Object.keys(e.configuration),...Object.keys(this.constants.get(e)??{})]);for(const[t,r]of(this.inputs.get(e)??new Map).entries())r.length&&s.add(t);this.controlWires.get(e)?.length&&s.add("");const r=[...t].filter((e=>!s.has(e)));return!!r.length&&r}shiftInputs(e){const t={...e.configuration,...this.constants.get(e)},s=this.inputs.get(e)??new Map;for(const[e,r]of s.entries())r.length>0&&(t[e]=r.shift());return this.haveRun.add(e),this.controlWires.delete(e),t}processResult(e,t){const s={nodes:[],unused:[]},r=new Set(Object.keys(t));for(const n of e.outgoing){const e=this.distributeResults(n,t);e.forEach((e=>r.delete(e)));const a=this.missingInputs(n.to);a||this.queueUp(n.to),s.nodes.push({node:n.to,received:e,missing:a})}return s.unused=[...r],s}distributeResults(e,t){const s="*"===e.out?t:""===e.out?{}:void 0!==t[e.out]?{[e.in]:t[e.out]}:{};e.constant&&this.constants.set(e.to,{...this.constants.get(e.to),...s}),this.inputs.has(e.to)||this.inputs.set(e.to,new Map);const r=this.inputs.get(e.to);for(const e of Object.keys(s))r?.has(e)||r?.set(e,[]),r?.get(e)?.push(s[e]);return""===e.in&&this.controlWires.set(e.to,[...this.controlWires.get(e.to)??[],e.from]),Object.keys(s)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class oe{parentLexicalScope;parentDynamicScope;#R={};#L=[];#z=[];constructor(e={}){this.parentLexicalScope=e.lexicalScope,this.parentDynamicScope=e.dynamicScope}addHandlers(e){Object.entries(e).forEach((([e,t])=>this.#R[e]=t))}getHandler(e){return this.#R[e]||this.parentDynamicScope?.getHandler(e)||this.parentLexicalScope?.getHandler(e)}pin(e){this.#L.push(e)}compactPins(){const e=new Set,t=[];for(const s of this.#L){if(e.has(s))continue;t.push(s);this.#q(s).forEach((t=>e.add(t)))}this.#L=t}getPinnedNodes(){return this.#L}addCallbacks(e){this.#z.push(e)}#D(){return[...this.#z,...this.parentDynamicScope?this.parentDynamicScope.#D():[]]}async invoke(e,t=new ie){try{!1!==e&&(e?e instanceof Array?e:[e]:this.#L).flatMap((e=>this.#q(e).filter((e=>!1===t?.missingInputs(e))))).forEach((e=>t?.queueUp(e)));const s=this.#D();for(;!t.done();){for(const e of s)if(await(e.stop?.(this,t)))return;const e=t.next(),r=t.shiftInputs(e);let n;for(const t of s)n??=await(t.before?.(this,e,r));const a=n??await e.invoke(r,this).catch((e=>({$error:{type:"error",error:e}}))),i=t.processResult(e,a);for(const t of s)await(t.after?.(this,e,r,a,i));if(i.unused.includes("$error"))throw a.$error.error}}finally{for(const e of this.#z)await(e.done?.())}}invokeOneRound(e={},t=void 0,s){let r;"$state"in e&&(s=e.$state,delete e.$state);const n=new Promise((e=>{r=e})),a=new oe({dynamicScope:this});let i;a.addHandlers({input:async()=>e,output:async e=>(r?.(await e),r=void 0,e)});const o=new Map;let c;a.addCallbacks({stop:(e,t)=>(r||(c=t),!r),after:(e,t,s,r,n)=>{i=t;for(const{node:e,missing:t}of n.nodes)t?o.set(e.id,t.join(", ")):o.delete(e.id)},done:()=>{r?.({$error:{type:"error",error:new Error(`Output node never reach. Last node was ${i?.id}.\n\nThese nodes had inputs missing:\n${Array.from(o,(([e,t])=>`  ${e}: ${t}`)).join("\n")}`)}})}});const d=a.invoke(void 0!==t?t:this.#L,s);return Promise.all([n,d]).then((([e])=>({...e,...c?{$state:c}:{}})))}async serialize(e,t){const s=(t?[t]:this.#L).flatMap((e=>this.#q(e))),r={},n=await Promise.all(s.map((async e=>{const[t,s]=await e.serializeNode();if(s&&(r[t.id]=s),("input"===t.type||"output"===t.type)&&!t.configuration?.schema){const s=await this.#F(e);Object.entries(s.properties??{}).length>0&&(t.configuration={...t.configuration,schema:s})}return t}))),a=s.flatMap((e=>e.outgoing.map((e=>({from:e.from.id,to:e.to.id,out:e.out,in:e.in,...e.constant?{constant:!0}:{}})))));return{...e,edges:a,nodes:n,graphs:r}}#q(e){const t=new Set,s=[e];for(;s.length;){const e=s.shift();t.has(e)||(t.add(e),e.incoming.forEach((e=>s.push(e.from))),e.outgoing.forEach((e=>s.push(e.to))))}return[...t]}async#V(e){const t=Object.fromEntries(e.incoming.filter((e=>""!==e.out&&"*"!==e.out)).map((e=>[e.out,e.schema??{}]))),s=Object.fromEntries(e.outgoing.filter((e=>""!==e.out&&"*"!==e.out)).map((e=>[e.out,e.schema??{}])));return await e.describe(this,e.configuration,{properties:t},{properties:s})}async#F(e){const t={},s=new Set;if("input"===e.type){const r=new Set;for(const n of e.outgoing)"*"!==n.out&&""!==n.out&&(r.add(n.to),s.add(n.out),n.schema&&(t[n.out]=n.schema));for(const s of r){const r=await this.#V(s),n=r?.inputSchema?.properties;if(n)for(const r of s.incoming)r.from===e&&n[r.in]&&(t[r.out]={...n[r.in],...t[r.out]})}}else{if("output"!==e.type)throw new Error("Can't yet derive schema for non-input/output nodes");{const r=new Set;for(const n of e.incoming)"*"!==n.out&&""!==n.out&&(r.add(n.from),s.add(n.in),n.schema&&(t[n.in]=n.schema));for(const s of r){const r=await this.#V(s),n=r?.outputSchema?.properties;if(n)for(const r of s.outgoing)r.to===e&&n[r.out]&&(t[r.in]={...n[r.out],...t[r.in]})}}}for(const e of s)t[e]?(t[e].type||="string",t[e].title||=e):t[e]={type:"string",title:e};const r=(e=>Object.entries(e).map((([e,t])=>{const s=t;if(!s.$optional)return e;delete s.$optional})).filter(Boolean))(t);return{type:"object",properties:t,required:r}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ce(e){const t=new Map;let s;return{before:async(t,s,r)=>{const n={descriptor:{id:s.id,type:s.type,configuration:s.configuration},inputs:r,outputs:Promise.resolve({})};return e.dispatchEvent(new CustomEvent("nodestart",{detail:n,cancelable:!0}))?void 0:n.outputs},after:(r,n,a,i,o)=>{const c={descriptor:{id:n.id,type:n.type,configuration:n.configuration},inputs:a,outputs:i,receivingNodes:Object.fromEntries(o.nodes.filter((e=>e.received.length>0)).map((e=>[e.node.id,e.received]))),incompleteNodes:Object.fromEntries(o.nodes.filter((e=>!1!==e.missing)).map((e=>[e.node.id,e.missing]))),unusedKeys:o.unused};e.dispatchEvent(new CustomEvent("node",{detail:c})),Object.entries(c.incompleteNodes).length>0?t.set(n.id,c):t.delete(n.id),s=c},done:()=>{e.dispatchEvent(new CustomEvent("done",{detail:{last:s,incompleteNextNodes:[...t.values()]}}))}}}class de{kits=[];edges=[];nodes=[];args;#A;#U;constructor(){this.#A=new oe}async*run({probe:e,kits:t}){if(!this.#U)throw new Error("Can't run board without any nodes in it");const s=new oe({lexicalScope:this.#A});let r;const n=new ReadableStream({start(e){r=e}});s.addHandlers({input:async(t,s)=>{let n;const a=new Promise((e=>{n=e})),i={type:s.type,id:s.id},o=await t,c={type:"input",node:i,inputArguments:o,set inputs(e){n(e)},state:{skip:!1}};return r.enqueue(c),a.then((t=>e?.dispatchEvent(new CustomEvent("input",{detail:{descriptor:i,inputs:o,outputs:t}})))),a},output:async(t,s)=>{const n={type:s.type,id:s.id},a={type:"output",node:n,outputs:await t,state:{skip:!1}};return e?.dispatchEvent(new CustomEvent("output",{detail:{descriptor:n,inputs:await t},cancelable:!0})),r.enqueue(a),{}}}),t?.forEach((e=>s.addHandlers(se(e)))),e&&s.addCallbacks(ce(e)),s.invoke(this.#U).finally((()=>r.close()));const a=n.getReader();for(;;){const{done:e,value:t}=await a.read();if(e)break;yield t}}async runOnce(e,t){if(!this.#U)throw new Error("Can't run board without any nodes in it");const s={...e,...this.args},r=new oe({lexicalScope:this.#A});return t?.kits?.forEach((e=>r.addHandlers(se(e)))),t?.probe&&r.addCallbacks(ce(t.probe)),r.invokeOneRound(s,this.#U)}addValidator(e){}static async fromGraphDescriptor(e){const t=new de;t.nodes=e.nodes,t.edges=e.edges,t.args=e.args;const s=new Map;return e.nodes.forEach((e=>{const r=new ae(e.type,t.#A,e.configuration);s.set(e.id,r),t.#U||(t.#U=r)})),e.edges.forEach((e=>{const t={from:s.get(e.from),to:s.get(e.to),out:e.out,in:e.in,constant:e.constant};t.from.outgoing.push(t),t.to.incoming.push(t)})),t}static async load(e,t){const s=await D.load(e,t);return await de.fromGraphDescriptor(s)}}var ue,pe;!function(e){e.assertEqual=e=>e,e.assertIs=function(e){},e.assertNever=function(e){throw new Error},e.arrayToEnum=e=>{const t={};for(const s of e)t[s]=s;return t},e.getValidEnumValues=t=>{const s=e.objectKeys(t).filter((e=>"number"!=typeof t[t[e]])),r={};for(const e of s)r[e]=t[e];return e.objectValues(r)},e.objectValues=t=>e.objectKeys(t).map((function(e){return t[e]})),e.objectKeys="function"==typeof Object.keys?e=>Object.keys(e):e=>{const t=[];for(const s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.push(s);return t},e.find=(e,t)=>{for(const s of e)if(t(s))return s},e.isInteger="function"==typeof Number.isInteger?e=>Number.isInteger(e):e=>"number"==typeof e&&isFinite(e)&&Math.floor(e)===e,e.joinValues=function(e,t=" | "){return e.map((e=>"string"==typeof e?`'${e}'`:e)).join(t)},e.jsonStringifyReplacer=(e,t)=>"bigint"==typeof t?t.toString():t}(ue||(ue={})),function(e){e.mergeShapes=(e,t)=>({...e,...t})}(pe||(pe={}));const le=ue.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),he=e=>{switch(typeof e){case"undefined":return le.undefined;case"string":return le.string;case"number":return isNaN(e)?le.nan:le.number;case"boolean":return le.boolean;case"function":return le.function;case"bigint":return le.bigint;case"symbol":return le.symbol;case"object":return Array.isArray(e)?le.array:null===e?le.null:e.then&&"function"==typeof e.then&&e.catch&&"function"==typeof e.catch?le.promise:"undefined"!=typeof Map&&e instanceof Map?le.map:"undefined"!=typeof Set&&e instanceof Set?le.set:"undefined"!=typeof Date&&e instanceof Date?le.date:le.object;default:return le.unknown}},fe=ue.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]);class me extends Error{constructor(e){super(),this.issues=[],this.addIssue=e=>{this.issues=[...this.issues,e]},this.addIssues=(e=[])=>{this.issues=[...this.issues,...e]};const t=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,t):this.__proto__=t,this.name="ZodError",this.issues=e}get errors(){return this.issues}format(e){const t=e||function(e){return e.message},s={_errors:[]},r=e=>{for(const n of e.issues)if("invalid_union"===n.code)n.unionErrors.map(r);else if("invalid_return_type"===n.code)r(n.returnTypeError);else if("invalid_arguments"===n.code)r(n.argumentsError);else if(0===n.path.length)s._errors.push(t(n));else{let e=s,r=0;for(;r<n.path.length;){const s=n.path[r];r===n.path.length-1?(e[s]=e[s]||{_errors:[]},e[s]._errors.push(t(n))):e[s]=e[s]||{_errors:[]},e=e[s],r++}}};return r(this),s}toString(){return this.message}get message(){return JSON.stringify(this.issues,ue.jsonStringifyReplacer,2)}get isEmpty(){return 0===this.issues.length}flatten(e=(e=>e.message)){const t={},s=[];for(const r of this.issues)r.path.length>0?(t[r.path[0]]=t[r.path[0]]||[],t[r.path[0]].push(e(r))):s.push(e(r));return{formErrors:s,fieldErrors:t}}get formErrors(){return this.flatten()}}me.create=e=>new me(e);const ge=(e,t)=>{let s;switch(e.code){case fe.invalid_type:s=e.received===le.undefined?"Required":`Expected ${e.expected}, received ${e.received}`;break;case fe.invalid_literal:s=`Invalid literal value, expected ${JSON.stringify(e.expected,ue.jsonStringifyReplacer)}`;break;case fe.unrecognized_keys:s=`Unrecognized key(s) in object: ${ue.joinValues(e.keys,", ")}`;break;case fe.invalid_union:s="Invalid input";break;case fe.invalid_union_discriminator:s=`Invalid discriminator value. Expected ${ue.joinValues(e.options)}`;break;case fe.invalid_enum_value:s=`Invalid enum value. Expected ${ue.joinValues(e.options)}, received '${e.received}'`;break;case fe.invalid_arguments:s="Invalid function arguments";break;case fe.invalid_return_type:s="Invalid function return type";break;case fe.invalid_date:s="Invalid date";break;case fe.invalid_string:"object"==typeof e.validation?"includes"in e.validation?(s=`Invalid input: must include "${e.validation.includes}"`,"number"==typeof e.validation.position&&(s=`${s} at one or more positions greater than or equal to ${e.validation.position}`)):"startsWith"in e.validation?s=`Invalid input: must start with "${e.validation.startsWith}"`:"endsWith"in e.validation?s=`Invalid input: must end with "${e.validation.endsWith}"`:ue.assertNever(e.validation):s="regex"!==e.validation?`Invalid ${e.validation}`:"Invalid";break;case fe.too_small:s="array"===e.type?`Array must contain ${e.exact?"exactly":e.inclusive?"at least":"more than"} ${e.minimum} element(s)`:"string"===e.type?`String must contain ${e.exact?"exactly":e.inclusive?"at least":"over"} ${e.minimum} character(s)`:"number"===e.type?`Number must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${e.minimum}`:"date"===e.type?`Date must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(e.minimum))}`:"Invalid input";break;case fe.too_big:s="array"===e.type?`Array must contain ${e.exact?"exactly":e.inclusive?"at most":"less than"} ${e.maximum} element(s)`:"string"===e.type?`String must contain ${e.exact?"exactly":e.inclusive?"at most":"under"} ${e.maximum} character(s)`:"number"===e.type?`Number must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:"bigint"===e.type?`BigInt must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:"date"===e.type?`Date must be ${e.exact?"exactly":e.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(e.maximum))}`:"Invalid input";break;case fe.custom:s="Invalid input";break;case fe.invalid_intersection_types:s="Intersection results could not be merged";break;case fe.not_multiple_of:s=`Number must be a multiple of ${e.multipleOf}`;break;case fe.not_finite:s="Number must be finite";break;default:s=t.defaultError,ue.assertNever(e)}return{message:s}};let ye=ge;function ve(){return ye}const be=e=>{const{data:t,path:s,errorMaps:r,issueData:n}=e,a=[...s,...n.path||[]],i={...n,path:a};let o="";const c=r.filter((e=>!!e)).slice().reverse();for(const e of c)o=e(i,{data:t,defaultError:o}).message;return{...n,path:a,message:n.message||o}};function _e(e,t){const s=be({issueData:t,data:e.data,path:e.path,errorMaps:[e.common.contextualErrorMap,e.schemaErrorMap,ve(),ge].filter((e=>!!e))});e.common.issues.push(s)}class we{constructor(){this.value="valid"}dirty(){"valid"===this.value&&(this.value="dirty")}abort(){"aborted"!==this.value&&(this.value="aborted")}static mergeArray(e,t){const s=[];for(const r of t){if("aborted"===r.status)return ke;"dirty"===r.status&&e.dirty(),s.push(r.value)}return{status:e.value,value:s}}static async mergeObjectAsync(e,t){const s=[];for(const e of t)s.push({key:await e.key,value:await e.value});return we.mergeObjectSync(e,s)}static mergeObjectSync(e,t){const s={};for(const r of t){const{key:t,value:n}=r;if("aborted"===t.status)return ke;if("aborted"===n.status)return ke;"dirty"===t.status&&e.dirty(),"dirty"===n.status&&e.dirty(),"__proto__"===t.value||void 0===n.value&&!r.alwaysSet||(s[t.value]=n.value)}return{status:e.value,value:s}}}const ke=Object.freeze({status:"aborted"}),xe=e=>({status:"dirty",value:e}),Se=e=>({status:"valid",value:e}),Pe=e=>"aborted"===e.status,Oe=e=>"dirty"===e.status,Ee=e=>"valid"===e.status,Ze=e=>"undefined"!=typeof Promise&&e instanceof Promise;var $e;!function(e){e.errToObj=e=>"string"==typeof e?{message:e}:e||{},e.toString=e=>"string"==typeof e?e:null==e?void 0:e.message}($e||($e={}));class Ne{constructor(e,t,s,r){this._cachedPath=[],this.parent=e,this.data=t,this._path=s,this._key=r}get path(){return this._cachedPath.length||(this._key instanceof Array?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const je=(e,t)=>{if(Ee(t))return{success:!0,data:t.value};if(!e.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const t=new me(e.common.issues);return this._error=t,this._error}}};function Te(e){if(!e)return{};const{errorMap:t,invalid_type_error:s,required_error:r,description:n}=e;if(t&&(s||r))throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');if(t)return{errorMap:t,description:n};return{errorMap:(e,t)=>"invalid_type"!==e.code?{message:t.defaultError}:void 0===t.data?{message:null!=r?r:t.defaultError}:{message:null!=s?s:t.defaultError},description:n}}class Ie{constructor(e){this.spa=this.safeParseAsync,this._def=e,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this)}get description(){return this._def.description}_getType(e){return he(e.data)}_getOrReturnCtx(e,t){return t||{common:e.parent.common,data:e.data,parsedType:he(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}_processInputParams(e){return{status:new we,ctx:{common:e.parent.common,data:e.data,parsedType:he(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}}_parseSync(e){const t=this._parse(e);if(Ze(t))throw new Error("Synchronous parse encountered promise.");return t}_parseAsync(e){const t=this._parse(e);return Promise.resolve(t)}parse(e,t){const s=this.safeParse(e,t);if(s.success)return s.data;throw s.error}safeParse(e,t){var s;const r={common:{issues:[],async:null!==(s=null==t?void 0:t.async)&&void 0!==s&&s,contextualErrorMap:null==t?void 0:t.errorMap},path:(null==t?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:he(e)},n=this._parseSync({data:e,path:r.path,parent:r});return je(r,n)}async parseAsync(e,t){const s=await this.safeParseAsync(e,t);if(s.success)return s.data;throw s.error}async safeParseAsync(e,t){const s={common:{issues:[],contextualErrorMap:null==t?void 0:t.errorMap,async:!0},path:(null==t?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:he(e)},r=this._parse({data:e,path:s.path,parent:s}),n=await(Ze(r)?r:Promise.resolve(r));return je(s,n)}refine(e,t){const s=e=>"string"==typeof t||void 0===t?{message:t}:"function"==typeof t?t(e):t;return this._refinement(((t,r)=>{const n=e(t),a=()=>r.addIssue({code:fe.custom,...s(t)});return"undefined"!=typeof Promise&&n instanceof Promise?n.then((e=>!!e||(a(),!1))):!!n||(a(),!1)}))}refinement(e,t){return this._refinement(((s,r)=>!!e(s)||(r.addIssue("function"==typeof t?t(s,r):t),!1)))}_refinement(e){return new _t({schema:this,typeName:Tt.ZodEffects,effect:{type:"refinement",refinement:e}})}superRefine(e){return this._refinement(e)}optional(){return wt.create(this,this._def)}nullable(){return kt.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return tt.create(this,this._def)}promise(){return bt.create(this,this._def)}or(e){return nt.create([this,e],this._def)}and(e){return ct.create(this,e,this._def)}transform(e){return new _t({...Te(this._def),schema:this,typeName:Tt.ZodEffects,effect:{type:"transform",transform:e}})}default(e){const t="function"==typeof e?e:()=>e;return new xt({...Te(this._def),innerType:this,defaultValue:t,typeName:Tt.ZodDefault})}brand(){return new Et({typeName:Tt.ZodBranded,type:this,...Te(this._def)})}catch(e){const t="function"==typeof e?e:()=>e;return new St({...Te(this._def),innerType:this,catchValue:t,typeName:Tt.ZodCatch})}describe(e){return new(0,this.constructor)({...this._def,description:e})}pipe(e){return Zt.create(this,e)}readonly(){return $t.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const Ce=/^c[^\s-]{8,}$/i,Ae=/^[a-z][a-z0-9]*$/,Me=/^[0-9A-HJKMNP-TV-Z]{26}$/,Re=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,Le=/^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;let ze;const qe=/^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,De=/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;class Fe extends Ie{_parse(e){this._def.coerce&&(e.data=String(e.data));if(this._getType(e)!==le.string){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.string,received:t.parsedType}),ke}const t=new we;let s;for(const i of this._def.checks)if("min"===i.kind)e.data.length<i.value&&(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.too_small,minimum:i.value,type:"string",inclusive:!0,exact:!1,message:i.message}),t.dirty());else if("max"===i.kind)e.data.length>i.value&&(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.too_big,maximum:i.value,type:"string",inclusive:!0,exact:!1,message:i.message}),t.dirty());else if("length"===i.kind){const r=e.data.length>i.value,n=e.data.length<i.value;(r||n)&&(s=this._getOrReturnCtx(e,s),r?_e(s,{code:fe.too_big,maximum:i.value,type:"string",inclusive:!0,exact:!0,message:i.message}):n&&_e(s,{code:fe.too_small,minimum:i.value,type:"string",inclusive:!0,exact:!0,message:i.message}),t.dirty())}else if("email"===i.kind)Le.test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{validation:"email",code:fe.invalid_string,message:i.message}),t.dirty());else if("emoji"===i.kind)ze||(ze=new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$","u")),ze.test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{validation:"emoji",code:fe.invalid_string,message:i.message}),t.dirty());else if("uuid"===i.kind)Re.test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{validation:"uuid",code:fe.invalid_string,message:i.message}),t.dirty());else if("cuid"===i.kind)Ce.test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{validation:"cuid",code:fe.invalid_string,message:i.message}),t.dirty());else if("cuid2"===i.kind)Ae.test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{validation:"cuid2",code:fe.invalid_string,message:i.message}),t.dirty());else if("ulid"===i.kind)Me.test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{validation:"ulid",code:fe.invalid_string,message:i.message}),t.dirty());else if("url"===i.kind)try{new URL(e.data)}catch(r){s=this._getOrReturnCtx(e,s),_e(s,{validation:"url",code:fe.invalid_string,message:i.message}),t.dirty()}else if("regex"===i.kind){i.regex.lastIndex=0;i.regex.test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{validation:"regex",code:fe.invalid_string,message:i.message}),t.dirty())}else if("trim"===i.kind)e.data=e.data.trim();else if("includes"===i.kind)e.data.includes(i.value,i.position)||(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.invalid_string,validation:{includes:i.value,position:i.position},message:i.message}),t.dirty());else if("toLowerCase"===i.kind)e.data=e.data.toLowerCase();else if("toUpperCase"===i.kind)e.data=e.data.toUpperCase();else if("startsWith"===i.kind)e.data.startsWith(i.value)||(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.invalid_string,validation:{startsWith:i.value},message:i.message}),t.dirty());else if("endsWith"===i.kind)e.data.endsWith(i.value)||(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.invalid_string,validation:{endsWith:i.value},message:i.message}),t.dirty());else if("datetime"===i.kind){((a=i).precision?a.offset?new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${a.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`):new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${a.precision}}Z$`):0===a.precision?a.offset?new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"):new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$"):a.offset?new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"):new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$")).test(e.data)||(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.invalid_string,validation:"datetime",message:i.message}),t.dirty())}else"ip"===i.kind?(r=e.data,("v4"!==(n=i.version)&&n||!qe.test(r))&&("v6"!==n&&n||!De.test(r))&&(s=this._getOrReturnCtx(e,s),_e(s,{validation:"ip",code:fe.invalid_string,message:i.message}),t.dirty())):ue.assertNever(i);var r,n,a;return{status:t.value,value:e.data}}_regex(e,t,s){return this.refinement((t=>e.test(t)),{validation:t,code:fe.invalid_string,...$e.errToObj(s)})}_addCheck(e){return new Fe({...this._def,checks:[...this._def.checks,e]})}email(e){return this._addCheck({kind:"email",...$e.errToObj(e)})}url(e){return this._addCheck({kind:"url",...$e.errToObj(e)})}emoji(e){return this._addCheck({kind:"emoji",...$e.errToObj(e)})}uuid(e){return this._addCheck({kind:"uuid",...$e.errToObj(e)})}cuid(e){return this._addCheck({kind:"cuid",...$e.errToObj(e)})}cuid2(e){return this._addCheck({kind:"cuid2",...$e.errToObj(e)})}ulid(e){return this._addCheck({kind:"ulid",...$e.errToObj(e)})}ip(e){return this._addCheck({kind:"ip",...$e.errToObj(e)})}datetime(e){var t;return"string"==typeof e?this._addCheck({kind:"datetime",precision:null,offset:!1,message:e}):this._addCheck({kind:"datetime",precision:void 0===(null==e?void 0:e.precision)?null:null==e?void 0:e.precision,offset:null!==(t=null==e?void 0:e.offset)&&void 0!==t&&t,...$e.errToObj(null==e?void 0:e.message)})}regex(e,t){return this._addCheck({kind:"regex",regex:e,...$e.errToObj(t)})}includes(e,t){return this._addCheck({kind:"includes",value:e,position:null==t?void 0:t.position,...$e.errToObj(null==t?void 0:t.message)})}startsWith(e,t){return this._addCheck({kind:"startsWith",value:e,...$e.errToObj(t)})}endsWith(e,t){return this._addCheck({kind:"endsWith",value:e,...$e.errToObj(t)})}min(e,t){return this._addCheck({kind:"min",value:e,...$e.errToObj(t)})}max(e,t){return this._addCheck({kind:"max",value:e,...$e.errToObj(t)})}length(e,t){return this._addCheck({kind:"length",value:e,...$e.errToObj(t)})}nonempty(e){return this.min(1,$e.errToObj(e))}trim(){return new Fe({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new Fe({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new Fe({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find((e=>"datetime"===e.kind))}get isEmail(){return!!this._def.checks.find((e=>"email"===e.kind))}get isURL(){return!!this._def.checks.find((e=>"url"===e.kind))}get isEmoji(){return!!this._def.checks.find((e=>"emoji"===e.kind))}get isUUID(){return!!this._def.checks.find((e=>"uuid"===e.kind))}get isCUID(){return!!this._def.checks.find((e=>"cuid"===e.kind))}get isCUID2(){return!!this._def.checks.find((e=>"cuid2"===e.kind))}get isULID(){return!!this._def.checks.find((e=>"ulid"===e.kind))}get isIP(){return!!this._def.checks.find((e=>"ip"===e.kind))}get minLength(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxLength(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}}function Ve(e,t){const s=(e.toString().split(".")[1]||"").length,r=(t.toString().split(".")[1]||"").length,n=s>r?s:r;return parseInt(e.toFixed(n).replace(".",""))%parseInt(t.toFixed(n).replace(".",""))/Math.pow(10,n)}Fe.create=e=>{var t;return new Fe({checks:[],typeName:Tt.ZodString,coerce:null!==(t=null==e?void 0:e.coerce)&&void 0!==t&&t,...Te(e)})};class Ue extends Ie{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(e){this._def.coerce&&(e.data=Number(e.data));if(this._getType(e)!==le.number){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.number,received:t.parsedType}),ke}let t;const s=new we;for(const r of this._def.checks)if("int"===r.kind)ue.isInteger(e.data)||(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.invalid_type,expected:"integer",received:"float",message:r.message}),s.dirty());else if("min"===r.kind){(r.inclusive?e.data<r.value:e.data<=r.value)&&(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.too_small,minimum:r.value,type:"number",inclusive:r.inclusive,exact:!1,message:r.message}),s.dirty())}else if("max"===r.kind){(r.inclusive?e.data>r.value:e.data>=r.value)&&(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.too_big,maximum:r.value,type:"number",inclusive:r.inclusive,exact:!1,message:r.message}),s.dirty())}else"multipleOf"===r.kind?0!==Ve(e.data,r.value)&&(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.not_multiple_of,multipleOf:r.value,message:r.message}),s.dirty()):"finite"===r.kind?Number.isFinite(e.data)||(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.not_finite,message:r.message}),s.dirty()):ue.assertNever(r);return{status:s.value,value:e.data}}gte(e,t){return this.setLimit("min",e,!0,$e.toString(t))}gt(e,t){return this.setLimit("min",e,!1,$e.toString(t))}lte(e,t){return this.setLimit("max",e,!0,$e.toString(t))}lt(e,t){return this.setLimit("max",e,!1,$e.toString(t))}setLimit(e,t,s,r){return new Ue({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:s,message:$e.toString(r)}]})}_addCheck(e){return new Ue({...this._def,checks:[...this._def.checks,e]})}int(e){return this._addCheck({kind:"int",message:$e.toString(e)})}positive(e){return this._addCheck({kind:"min",value:0,inclusive:!1,message:$e.toString(e)})}negative(e){return this._addCheck({kind:"max",value:0,inclusive:!1,message:$e.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:0,inclusive:!0,message:$e.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:0,inclusive:!0,message:$e.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:$e.toString(t)})}finite(e){return this._addCheck({kind:"finite",message:$e.toString(e)})}safe(e){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:$e.toString(e)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:$e.toString(e)})}get minValue(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}get isInt(){return!!this._def.checks.find((e=>"int"===e.kind||"multipleOf"===e.kind&&ue.isInteger(e.value)))}get isFinite(){let e=null,t=null;for(const s of this._def.checks){if("finite"===s.kind||"int"===s.kind||"multipleOf"===s.kind)return!0;"min"===s.kind?(null===t||s.value>t)&&(t=s.value):"max"===s.kind&&(null===e||s.value<e)&&(e=s.value)}return Number.isFinite(t)&&Number.isFinite(e)}}Ue.create=e=>new Ue({checks:[],typeName:Tt.ZodNumber,coerce:(null==e?void 0:e.coerce)||!1,...Te(e)});class Be extends Ie{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(e){this._def.coerce&&(e.data=BigInt(e.data));if(this._getType(e)!==le.bigint){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.bigint,received:t.parsedType}),ke}let t;const s=new we;for(const r of this._def.checks)if("min"===r.kind){(r.inclusive?e.data<r.value:e.data<=r.value)&&(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.too_small,type:"bigint",minimum:r.value,inclusive:r.inclusive,message:r.message}),s.dirty())}else if("max"===r.kind){(r.inclusive?e.data>r.value:e.data>=r.value)&&(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.too_big,type:"bigint",maximum:r.value,inclusive:r.inclusive,message:r.message}),s.dirty())}else"multipleOf"===r.kind?e.data%r.value!==BigInt(0)&&(t=this._getOrReturnCtx(e,t),_e(t,{code:fe.not_multiple_of,multipleOf:r.value,message:r.message}),s.dirty()):ue.assertNever(r);return{status:s.value,value:e.data}}gte(e,t){return this.setLimit("min",e,!0,$e.toString(t))}gt(e,t){return this.setLimit("min",e,!1,$e.toString(t))}lte(e,t){return this.setLimit("max",e,!0,$e.toString(t))}lt(e,t){return this.setLimit("max",e,!1,$e.toString(t))}setLimit(e,t,s,r){return new Be({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:s,message:$e.toString(r)}]})}_addCheck(e){return new Be({...this._def,checks:[...this._def.checks,e]})}positive(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:$e.toString(e)})}negative(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:$e.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:$e.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:$e.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:$e.toString(t)})}get minValue(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}}Be.create=e=>{var t;return new Be({checks:[],typeName:Tt.ZodBigInt,coerce:null!==(t=null==e?void 0:e.coerce)&&void 0!==t&&t,...Te(e)})};class Ke extends Ie{_parse(e){this._def.coerce&&(e.data=Boolean(e.data));if(this._getType(e)!==le.boolean){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.boolean,received:t.parsedType}),ke}return Se(e.data)}}Ke.create=e=>new Ke({typeName:Tt.ZodBoolean,coerce:(null==e?void 0:e.coerce)||!1,...Te(e)});class We extends Ie{_parse(e){this._def.coerce&&(e.data=new Date(e.data));if(this._getType(e)!==le.date){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.date,received:t.parsedType}),ke}if(isNaN(e.data.getTime())){return _e(this._getOrReturnCtx(e),{code:fe.invalid_date}),ke}const t=new we;let s;for(const r of this._def.checks)"min"===r.kind?e.data.getTime()<r.value&&(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.too_small,message:r.message,inclusive:!0,exact:!1,minimum:r.value,type:"date"}),t.dirty()):"max"===r.kind?e.data.getTime()>r.value&&(s=this._getOrReturnCtx(e,s),_e(s,{code:fe.too_big,message:r.message,inclusive:!0,exact:!1,maximum:r.value,type:"date"}),t.dirty()):ue.assertNever(r);return{status:t.value,value:new Date(e.data.getTime())}}_addCheck(e){return new We({...this._def,checks:[...this._def.checks,e]})}min(e,t){return this._addCheck({kind:"min",value:e.getTime(),message:$e.toString(t)})}max(e,t){return this._addCheck({kind:"max",value:e.getTime(),message:$e.toString(t)})}get minDate(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return null!=e?new Date(e):null}get maxDate(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return null!=e?new Date(e):null}}We.create=e=>new We({checks:[],coerce:(null==e?void 0:e.coerce)||!1,typeName:Tt.ZodDate,...Te(e)});class Ge extends Ie{_parse(e){if(this._getType(e)!==le.symbol){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.symbol,received:t.parsedType}),ke}return Se(e.data)}}Ge.create=e=>new Ge({typeName:Tt.ZodSymbol,...Te(e)});class He extends Ie{_parse(e){if(this._getType(e)!==le.undefined){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.undefined,received:t.parsedType}),ke}return Se(e.data)}}He.create=e=>new He({typeName:Tt.ZodUndefined,...Te(e)});class Je extends Ie{_parse(e){if(this._getType(e)!==le.null){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.null,received:t.parsedType}),ke}return Se(e.data)}}Je.create=e=>new Je({typeName:Tt.ZodNull,...Te(e)});class Qe extends Ie{constructor(){super(...arguments),this._any=!0}_parse(e){return Se(e.data)}}Qe.create=e=>new Qe({typeName:Tt.ZodAny,...Te(e)});class Ye extends Ie{constructor(){super(...arguments),this._unknown=!0}_parse(e){return Se(e.data)}}Ye.create=e=>new Ye({typeName:Tt.ZodUnknown,...Te(e)});class Xe extends Ie{_parse(e){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.never,received:t.parsedType}),ke}}Xe.create=e=>new Xe({typeName:Tt.ZodNever,...Te(e)});class et extends Ie{_parse(e){if(this._getType(e)!==le.undefined){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.void,received:t.parsedType}),ke}return Se(e.data)}}et.create=e=>new et({typeName:Tt.ZodVoid,...Te(e)});class tt extends Ie{_parse(e){const{ctx:t,status:s}=this._processInputParams(e),r=this._def;if(t.parsedType!==le.array)return _e(t,{code:fe.invalid_type,expected:le.array,received:t.parsedType}),ke;if(null!==r.exactLength){const e=t.data.length>r.exactLength.value,n=t.data.length<r.exactLength.value;(e||n)&&(_e(t,{code:e?fe.too_big:fe.too_small,minimum:n?r.exactLength.value:void 0,maximum:e?r.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:r.exactLength.message}),s.dirty())}if(null!==r.minLength&&t.data.length<r.minLength.value&&(_e(t,{code:fe.too_small,minimum:r.minLength.value,type:"array",inclusive:!0,exact:!1,message:r.minLength.message}),s.dirty()),null!==r.maxLength&&t.data.length>r.maxLength.value&&(_e(t,{code:fe.too_big,maximum:r.maxLength.value,type:"array",inclusive:!0,exact:!1,message:r.maxLength.message}),s.dirty()),t.common.async)return Promise.all([...t.data].map(((e,s)=>r.type._parseAsync(new Ne(t,e,t.path,s))))).then((e=>we.mergeArray(s,e)));const n=[...t.data].map(((e,s)=>r.type._parseSync(new Ne(t,e,t.path,s))));return we.mergeArray(s,n)}get element(){return this._def.type}min(e,t){return new tt({...this._def,minLength:{value:e,message:$e.toString(t)}})}max(e,t){return new tt({...this._def,maxLength:{value:e,message:$e.toString(t)}})}length(e,t){return new tt({...this._def,exactLength:{value:e,message:$e.toString(t)}})}nonempty(e){return this.min(1,e)}}function st(e){if(e instanceof rt){const t={};for(const s in e.shape){const r=e.shape[s];t[s]=wt.create(st(r))}return new rt({...e._def,shape:()=>t})}return e instanceof tt?new tt({...e._def,type:st(e.element)}):e instanceof wt?wt.create(st(e.unwrap())):e instanceof kt?kt.create(st(e.unwrap())):e instanceof dt?dt.create(e.items.map((e=>st(e)))):e}tt.create=(e,t)=>new tt({type:e,minLength:null,maxLength:null,exactLength:null,typeName:Tt.ZodArray,...Te(t)});class rt extends Ie{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(null!==this._cached)return this._cached;const e=this._def.shape(),t=ue.objectKeys(e);return this._cached={shape:e,keys:t}}_parse(e){if(this._getType(e)!==le.object){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.object,received:t.parsedType}),ke}const{status:t,ctx:s}=this._processInputParams(e),{shape:r,keys:n}=this._getCached(),a=[];if(!(this._def.catchall instanceof Xe&&"strip"===this._def.unknownKeys))for(const e in s.data)n.includes(e)||a.push(e);const i=[];for(const e of n){const t=r[e],n=s.data[e];i.push({key:{status:"valid",value:e},value:t._parse(new Ne(s,n,s.path,e)),alwaysSet:e in s.data})}if(this._def.catchall instanceof Xe){const e=this._def.unknownKeys;if("passthrough"===e)for(const e of a)i.push({key:{status:"valid",value:e},value:{status:"valid",value:s.data[e]}});else if("strict"===e)a.length>0&&(_e(s,{code:fe.unrecognized_keys,keys:a}),t.dirty());else if("strip"!==e)throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const e=this._def.catchall;for(const t of a){const r=s.data[t];i.push({key:{status:"valid",value:t},value:e._parse(new Ne(s,r,s.path,t)),alwaysSet:t in s.data})}}return s.common.async?Promise.resolve().then((async()=>{const e=[];for(const t of i){const s=await t.key;e.push({key:s,value:await t.value,alwaysSet:t.alwaysSet})}return e})).then((e=>we.mergeObjectSync(t,e))):we.mergeObjectSync(t,i)}get shape(){return this._def.shape()}strict(e){return $e.errToObj,new rt({...this._def,unknownKeys:"strict",...void 0!==e?{errorMap:(t,s)=>{var r,n,a,i;const o=null!==(a=null===(n=(r=this._def).errorMap)||void 0===n?void 0:n.call(r,t,s).message)&&void 0!==a?a:s.defaultError;return"unrecognized_keys"===t.code?{message:null!==(i=$e.errToObj(e).message)&&void 0!==i?i:o}:{message:o}}}:{}})}strip(){return new rt({...this._def,unknownKeys:"strip"})}passthrough(){return new rt({...this._def,unknownKeys:"passthrough"})}extend(e){return new rt({...this._def,shape:()=>({...this._def.shape(),...e})})}merge(e){return new rt({unknownKeys:e._def.unknownKeys,catchall:e._def.catchall,shape:()=>({...this._def.shape(),...e._def.shape()}),typeName:Tt.ZodObject})}setKey(e,t){return this.augment({[e]:t})}catchall(e){return new rt({...this._def,catchall:e})}pick(e){const t={};return ue.objectKeys(e).forEach((s=>{e[s]&&this.shape[s]&&(t[s]=this.shape[s])})),new rt({...this._def,shape:()=>t})}omit(e){const t={};return ue.objectKeys(this.shape).forEach((s=>{e[s]||(t[s]=this.shape[s])})),new rt({...this._def,shape:()=>t})}deepPartial(){return st(this)}partial(e){const t={};return ue.objectKeys(this.shape).forEach((s=>{const r=this.shape[s];e&&!e[s]?t[s]=r:t[s]=r.optional()})),new rt({...this._def,shape:()=>t})}required(e){const t={};return ue.objectKeys(this.shape).forEach((s=>{if(e&&!e[s])t[s]=this.shape[s];else{let e=this.shape[s];for(;e instanceof wt;)e=e._def.innerType;t[s]=e}})),new rt({...this._def,shape:()=>t})}keyof(){return gt(ue.objectKeys(this.shape))}}rt.create=(e,t)=>new rt({shape:()=>e,unknownKeys:"strip",catchall:Xe.create(),typeName:Tt.ZodObject,...Te(t)}),rt.strictCreate=(e,t)=>new rt({shape:()=>e,unknownKeys:"strict",catchall:Xe.create(),typeName:Tt.ZodObject,...Te(t)}),rt.lazycreate=(e,t)=>new rt({shape:e,unknownKeys:"strip",catchall:Xe.create(),typeName:Tt.ZodObject,...Te(t)});class nt extends Ie{_parse(e){const{ctx:t}=this._processInputParams(e),s=this._def.options;if(t.common.async)return Promise.all(s.map((async e=>{const s={...t,common:{...t.common,issues:[]},parent:null};return{result:await e._parseAsync({data:t.data,path:t.path,parent:s}),ctx:s}}))).then((function(e){for(const t of e)if("valid"===t.result.status)return t.result;for(const s of e)if("dirty"===s.result.status)return t.common.issues.push(...s.ctx.common.issues),s.result;const s=e.map((e=>new me(e.ctx.common.issues)));return _e(t,{code:fe.invalid_union,unionErrors:s}),ke}));{let e;const r=[];for(const n of s){const s={...t,common:{...t.common,issues:[]},parent:null},a=n._parseSync({data:t.data,path:t.path,parent:s});if("valid"===a.status)return a;"dirty"!==a.status||e||(e={result:a,ctx:s}),s.common.issues.length&&r.push(s.common.issues)}if(e)return t.common.issues.push(...e.ctx.common.issues),e.result;const n=r.map((e=>new me(e)));return _e(t,{code:fe.invalid_union,unionErrors:n}),ke}}get options(){return this._def.options}}nt.create=(e,t)=>new nt({options:e,typeName:Tt.ZodUnion,...Te(t)});const at=e=>e instanceof ft?at(e.schema):e instanceof _t?at(e.innerType()):e instanceof mt?[e.value]:e instanceof yt?e.options:e instanceof vt?Object.keys(e.enum):e instanceof xt?at(e._def.innerType):e instanceof He?[void 0]:e instanceof Je?[null]:null;class it extends Ie{_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==le.object)return _e(t,{code:fe.invalid_type,expected:le.object,received:t.parsedType}),ke;const s=this.discriminator,r=t.data[s],n=this.optionsMap.get(r);return n?t.common.async?n._parseAsync({data:t.data,path:t.path,parent:t}):n._parseSync({data:t.data,path:t.path,parent:t}):(_e(t,{code:fe.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[s]}),ke)}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(e,t,s){const r=new Map;for(const s of t){const t=at(s.shape[e]);if(!t)throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);for(const n of t){if(r.has(n))throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(n)}`);r.set(n,s)}}return new it({typeName:Tt.ZodDiscriminatedUnion,discriminator:e,options:t,optionsMap:r,...Te(s)})}}function ot(e,t){const s=he(e),r=he(t);if(e===t)return{valid:!0,data:e};if(s===le.object&&r===le.object){const s=ue.objectKeys(t),r=ue.objectKeys(e).filter((e=>-1!==s.indexOf(e))),n={...e,...t};for(const s of r){const r=ot(e[s],t[s]);if(!r.valid)return{valid:!1};n[s]=r.data}return{valid:!0,data:n}}if(s===le.array&&r===le.array){if(e.length!==t.length)return{valid:!1};const s=[];for(let r=0;r<e.length;r++){const n=ot(e[r],t[r]);if(!n.valid)return{valid:!1};s.push(n.data)}return{valid:!0,data:s}}return s===le.date&&r===le.date&&+e==+t?{valid:!0,data:e}:{valid:!1}}class ct extends Ie{_parse(e){const{status:t,ctx:s}=this._processInputParams(e),r=(e,r)=>{if(Pe(e)||Pe(r))return ke;const n=ot(e.value,r.value);return n.valid?((Oe(e)||Oe(r))&&t.dirty(),{status:t.value,value:n.data}):(_e(s,{code:fe.invalid_intersection_types}),ke)};return s.common.async?Promise.all([this._def.left._parseAsync({data:s.data,path:s.path,parent:s}),this._def.right._parseAsync({data:s.data,path:s.path,parent:s})]).then((([e,t])=>r(e,t))):r(this._def.left._parseSync({data:s.data,path:s.path,parent:s}),this._def.right._parseSync({data:s.data,path:s.path,parent:s}))}}ct.create=(e,t,s)=>new ct({left:e,right:t,typeName:Tt.ZodIntersection,...Te(s)});class dt extends Ie{_parse(e){const{status:t,ctx:s}=this._processInputParams(e);if(s.parsedType!==le.array)return _e(s,{code:fe.invalid_type,expected:le.array,received:s.parsedType}),ke;if(s.data.length<this._def.items.length)return _e(s,{code:fe.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),ke;!this._def.rest&&s.data.length>this._def.items.length&&(_e(s,{code:fe.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),t.dirty());const r=[...s.data].map(((e,t)=>{const r=this._def.items[t]||this._def.rest;return r?r._parse(new Ne(s,e,s.path,t)):null})).filter((e=>!!e));return s.common.async?Promise.all(r).then((e=>we.mergeArray(t,e))):we.mergeArray(t,r)}get items(){return this._def.items}rest(e){return new dt({...this._def,rest:e})}}dt.create=(e,t)=>{if(!Array.isArray(e))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new dt({items:e,typeName:Tt.ZodTuple,rest:null,...Te(t)})};class ut extends Ie{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:t,ctx:s}=this._processInputParams(e);if(s.parsedType!==le.object)return _e(s,{code:fe.invalid_type,expected:le.object,received:s.parsedType}),ke;const r=[],n=this._def.keyType,a=this._def.valueType;for(const e in s.data)r.push({key:n._parse(new Ne(s,e,s.path,e)),value:a._parse(new Ne(s,s.data[e],s.path,e))});return s.common.async?we.mergeObjectAsync(t,r):we.mergeObjectSync(t,r)}get element(){return this._def.valueType}static create(e,t,s){return new ut(t instanceof Ie?{keyType:e,valueType:t,typeName:Tt.ZodRecord,...Te(s)}:{keyType:Fe.create(),valueType:e,typeName:Tt.ZodRecord,...Te(t)})}}class pt extends Ie{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:t,ctx:s}=this._processInputParams(e);if(s.parsedType!==le.map)return _e(s,{code:fe.invalid_type,expected:le.map,received:s.parsedType}),ke;const r=this._def.keyType,n=this._def.valueType,a=[...s.data.entries()].map((([e,t],a)=>({key:r._parse(new Ne(s,e,s.path,[a,"key"])),value:n._parse(new Ne(s,t,s.path,[a,"value"]))})));if(s.common.async){const e=new Map;return Promise.resolve().then((async()=>{for(const s of a){const r=await s.key,n=await s.value;if("aborted"===r.status||"aborted"===n.status)return ke;"dirty"!==r.status&&"dirty"!==n.status||t.dirty(),e.set(r.value,n.value)}return{status:t.value,value:e}}))}{const e=new Map;for(const s of a){const r=s.key,n=s.value;if("aborted"===r.status||"aborted"===n.status)return ke;"dirty"!==r.status&&"dirty"!==n.status||t.dirty(),e.set(r.value,n.value)}return{status:t.value,value:e}}}}pt.create=(e,t,s)=>new pt({valueType:t,keyType:e,typeName:Tt.ZodMap,...Te(s)});class lt extends Ie{_parse(e){const{status:t,ctx:s}=this._processInputParams(e);if(s.parsedType!==le.set)return _e(s,{code:fe.invalid_type,expected:le.set,received:s.parsedType}),ke;const r=this._def;null!==r.minSize&&s.data.size<r.minSize.value&&(_e(s,{code:fe.too_small,minimum:r.minSize.value,type:"set",inclusive:!0,exact:!1,message:r.minSize.message}),t.dirty()),null!==r.maxSize&&s.data.size>r.maxSize.value&&(_e(s,{code:fe.too_big,maximum:r.maxSize.value,type:"set",inclusive:!0,exact:!1,message:r.maxSize.message}),t.dirty());const n=this._def.valueType;function a(e){const s=new Set;for(const r of e){if("aborted"===r.status)return ke;"dirty"===r.status&&t.dirty(),s.add(r.value)}return{status:t.value,value:s}}const i=[...s.data.values()].map(((e,t)=>n._parse(new Ne(s,e,s.path,t))));return s.common.async?Promise.all(i).then((e=>a(e))):a(i)}min(e,t){return new lt({...this._def,minSize:{value:e,message:$e.toString(t)}})}max(e,t){return new lt({...this._def,maxSize:{value:e,message:$e.toString(t)}})}size(e,t){return this.min(e,t).max(e,t)}nonempty(e){return this.min(1,e)}}lt.create=(e,t)=>new lt({valueType:e,minSize:null,maxSize:null,typeName:Tt.ZodSet,...Te(t)});class ht extends Ie{constructor(){super(...arguments),this.validate=this.implement}_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==le.function)return _e(t,{code:fe.invalid_type,expected:le.function,received:t.parsedType}),ke;function s(e,s){return be({data:e,path:t.path,errorMaps:[t.common.contextualErrorMap,t.schemaErrorMap,ve(),ge].filter((e=>!!e)),issueData:{code:fe.invalid_arguments,argumentsError:s}})}function r(e,s){return be({data:e,path:t.path,errorMaps:[t.common.contextualErrorMap,t.schemaErrorMap,ve(),ge].filter((e=>!!e)),issueData:{code:fe.invalid_return_type,returnTypeError:s}})}const n={errorMap:t.common.contextualErrorMap},a=t.data;if(this._def.returns instanceof bt){const e=this;return Se((async function(...t){const i=new me([]),o=await e._def.args.parseAsync(t,n).catch((e=>{throw i.addIssue(s(t,e)),i})),c=await Reflect.apply(a,this,o);return await e._def.returns._def.type.parseAsync(c,n).catch((e=>{throw i.addIssue(r(c,e)),i}))}))}{const e=this;return Se((function(...t){const i=e._def.args.safeParse(t,n);if(!i.success)throw new me([s(t,i.error)]);const o=Reflect.apply(a,this,i.data),c=e._def.returns.safeParse(o,n);if(!c.success)throw new me([r(o,c.error)]);return c.data}))}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...e){return new ht({...this._def,args:dt.create(e).rest(Ye.create())})}returns(e){return new ht({...this._def,returns:e})}implement(e){return this.parse(e)}strictImplement(e){return this.parse(e)}static create(e,t,s){return new ht({args:e||dt.create([]).rest(Ye.create()),returns:t||Ye.create(),typeName:Tt.ZodFunction,...Te(s)})}}class ft extends Ie{get schema(){return this._def.getter()}_parse(e){const{ctx:t}=this._processInputParams(e);return this._def.getter()._parse({data:t.data,path:t.path,parent:t})}}ft.create=(e,t)=>new ft({getter:e,typeName:Tt.ZodLazy,...Te(t)});class mt extends Ie{_parse(e){if(e.data!==this._def.value){const t=this._getOrReturnCtx(e);return _e(t,{received:t.data,code:fe.invalid_literal,expected:this._def.value}),ke}return{status:"valid",value:e.data}}get value(){return this._def.value}}function gt(e,t){return new yt({values:e,typeName:Tt.ZodEnum,...Te(t)})}mt.create=(e,t)=>new mt({value:e,typeName:Tt.ZodLiteral,...Te(t)});class yt extends Ie{_parse(e){if("string"!=typeof e.data){const t=this._getOrReturnCtx(e),s=this._def.values;return _e(t,{expected:ue.joinValues(s),received:t.parsedType,code:fe.invalid_type}),ke}if(-1===this._def.values.indexOf(e.data)){const t=this._getOrReturnCtx(e),s=this._def.values;return _e(t,{received:t.data,code:fe.invalid_enum_value,options:s}),ke}return Se(e.data)}get options(){return this._def.values}get enum(){const e={};for(const t of this._def.values)e[t]=t;return e}get Values(){const e={};for(const t of this._def.values)e[t]=t;return e}get Enum(){const e={};for(const t of this._def.values)e[t]=t;return e}extract(e){return yt.create(e)}exclude(e){return yt.create(this.options.filter((t=>!e.includes(t))))}}yt.create=gt;class vt extends Ie{_parse(e){const t=ue.getValidEnumValues(this._def.values),s=this._getOrReturnCtx(e);if(s.parsedType!==le.string&&s.parsedType!==le.number){const e=ue.objectValues(t);return _e(s,{expected:ue.joinValues(e),received:s.parsedType,code:fe.invalid_type}),ke}if(-1===t.indexOf(e.data)){const e=ue.objectValues(t);return _e(s,{received:s.data,code:fe.invalid_enum_value,options:e}),ke}return Se(e.data)}get enum(){return this._def.values}}vt.create=(e,t)=>new vt({values:e,typeName:Tt.ZodNativeEnum,...Te(t)});class bt extends Ie{unwrap(){return this._def.type}_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==le.promise&&!1===t.common.async)return _e(t,{code:fe.invalid_type,expected:le.promise,received:t.parsedType}),ke;const s=t.parsedType===le.promise?t.data:Promise.resolve(t.data);return Se(s.then((e=>this._def.type.parseAsync(e,{path:t.path,errorMap:t.common.contextualErrorMap}))))}}bt.create=(e,t)=>new bt({type:e,typeName:Tt.ZodPromise,...Te(t)});class _t extends Ie{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===Tt.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(e){const{status:t,ctx:s}=this._processInputParams(e),r=this._def.effect||null,n={addIssue:e=>{_e(s,e),e.fatal?t.abort():t.dirty()},get path(){return s.path}};if(n.addIssue=n.addIssue.bind(n),"preprocess"===r.type){const e=r.transform(s.data,n);return s.common.issues.length?{status:"dirty",value:s.data}:s.common.async?Promise.resolve(e).then((e=>this._def.schema._parseAsync({data:e,path:s.path,parent:s}))):this._def.schema._parseSync({data:e,path:s.path,parent:s})}if("refinement"===r.type){const e=e=>{const t=r.refinement(e,n);if(s.common.async)return Promise.resolve(t);if(t instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return e};if(!1===s.common.async){const r=this._def.schema._parseSync({data:s.data,path:s.path,parent:s});return"aborted"===r.status?ke:("dirty"===r.status&&t.dirty(),e(r.value),{status:t.value,value:r.value})}return this._def.schema._parseAsync({data:s.data,path:s.path,parent:s}).then((s=>"aborted"===s.status?ke:("dirty"===s.status&&t.dirty(),e(s.value).then((()=>({status:t.value,value:s.value}))))))}if("transform"===r.type){if(!1===s.common.async){const e=this._def.schema._parseSync({data:s.data,path:s.path,parent:s});if(!Ee(e))return e;const a=r.transform(e.value,n);if(a instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:t.value,value:a}}return this._def.schema._parseAsync({data:s.data,path:s.path,parent:s}).then((e=>Ee(e)?Promise.resolve(r.transform(e.value,n)).then((e=>({status:t.value,value:e}))):e))}ue.assertNever(r)}}_t.create=(e,t,s)=>new _t({schema:e,typeName:Tt.ZodEffects,effect:t,...Te(s)}),_t.createWithPreprocess=(e,t,s)=>new _t({schema:t,effect:{type:"preprocess",transform:e},typeName:Tt.ZodEffects,...Te(s)});class wt extends Ie{_parse(e){return this._getType(e)===le.undefined?Se(void 0):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}wt.create=(e,t)=>new wt({innerType:e,typeName:Tt.ZodOptional,...Te(t)});class kt extends Ie{_parse(e){return this._getType(e)===le.null?Se(null):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}kt.create=(e,t)=>new kt({innerType:e,typeName:Tt.ZodNullable,...Te(t)});class xt extends Ie{_parse(e){const{ctx:t}=this._processInputParams(e);let s=t.data;return t.parsedType===le.undefined&&(s=this._def.defaultValue()),this._def.innerType._parse({data:s,path:t.path,parent:t})}removeDefault(){return this._def.innerType}}xt.create=(e,t)=>new xt({innerType:e,typeName:Tt.ZodDefault,defaultValue:"function"==typeof t.default?t.default:()=>t.default,...Te(t)});class St extends Ie{_parse(e){const{ctx:t}=this._processInputParams(e),s={...t,common:{...t.common,issues:[]}},r=this._def.innerType._parse({data:s.data,path:s.path,parent:{...s}});return Ze(r)?r.then((e=>({status:"valid",value:"valid"===e.status?e.value:this._def.catchValue({get error(){return new me(s.common.issues)},input:s.data})}))):{status:"valid",value:"valid"===r.status?r.value:this._def.catchValue({get error(){return new me(s.common.issues)},input:s.data})}}removeCatch(){return this._def.innerType}}St.create=(e,t)=>new St({innerType:e,typeName:Tt.ZodCatch,catchValue:"function"==typeof t.catch?t.catch:()=>t.catch,...Te(t)});class Pt extends Ie{_parse(e){if(this._getType(e)!==le.nan){const t=this._getOrReturnCtx(e);return _e(t,{code:fe.invalid_type,expected:le.nan,received:t.parsedType}),ke}return{status:"valid",value:e.data}}}Pt.create=e=>new Pt({typeName:Tt.ZodNaN,...Te(e)});const Ot=Symbol("zod_brand");class Et extends Ie{_parse(e){const{ctx:t}=this._processInputParams(e),s=t.data;return this._def.type._parse({data:s,path:t.path,parent:t})}unwrap(){return this._def.type}}class Zt extends Ie{_parse(e){const{status:t,ctx:s}=this._processInputParams(e);if(s.common.async){return(async()=>{const e=await this._def.in._parseAsync({data:s.data,path:s.path,parent:s});return"aborted"===e.status?ke:"dirty"===e.status?(t.dirty(),xe(e.value)):this._def.out._parseAsync({data:e.value,path:s.path,parent:s})})()}{const e=this._def.in._parseSync({data:s.data,path:s.path,parent:s});return"aborted"===e.status?ke:"dirty"===e.status?(t.dirty(),{status:"dirty",value:e.value}):this._def.out._parseSync({data:e.value,path:s.path,parent:s})}}static create(e,t){return new Zt({in:e,out:t,typeName:Tt.ZodPipeline})}}class $t extends Ie{_parse(e){const t=this._def.innerType._parse(e);return Ee(t)&&(t.value=Object.freeze(t.value)),t}}$t.create=(e,t)=>new $t({innerType:e,typeName:Tt.ZodReadonly,...Te(t)});const Nt=(e,t={},s)=>e?Qe.create().superRefine(((r,n)=>{var a,i;if(!e(r)){const e="function"==typeof t?t(r):"string"==typeof t?{message:t}:t,o=null===(i=null!==(a=e.fatal)&&void 0!==a?a:s)||void 0===i||i,c="string"==typeof e?{message:e}:e;n.addIssue({code:"custom",...c,fatal:o})}})):Qe.create(),jt={object:rt.lazycreate};var Tt;!function(e){e.ZodString="ZodString",e.ZodNumber="ZodNumber",e.ZodNaN="ZodNaN",e.ZodBigInt="ZodBigInt",e.ZodBoolean="ZodBoolean",e.ZodDate="ZodDate",e.ZodSymbol="ZodSymbol",e.ZodUndefined="ZodUndefined",e.ZodNull="ZodNull",e.ZodAny="ZodAny",e.ZodUnknown="ZodUnknown",e.ZodNever="ZodNever",e.ZodVoid="ZodVoid",e.ZodArray="ZodArray",e.ZodObject="ZodObject",e.ZodUnion="ZodUnion",e.ZodDiscriminatedUnion="ZodDiscriminatedUnion",e.ZodIntersection="ZodIntersection",e.ZodTuple="ZodTuple",e.ZodRecord="ZodRecord",e.ZodMap="ZodMap",e.ZodSet="ZodSet",e.ZodFunction="ZodFunction",e.ZodLazy="ZodLazy",e.ZodLiteral="ZodLiteral",e.ZodEnum="ZodEnum",e.ZodEffects="ZodEffects",e.ZodNativeEnum="ZodNativeEnum",e.ZodOptional="ZodOptional",e.ZodNullable="ZodNullable",e.ZodDefault="ZodDefault",e.ZodCatch="ZodCatch",e.ZodPromise="ZodPromise",e.ZodBranded="ZodBranded",e.ZodPipeline="ZodPipeline",e.ZodReadonly="ZodReadonly"}(Tt||(Tt={}));const It=Fe.create,Ct=Ue.create,At=Pt.create,Mt=Be.create,Rt=Ke.create,Lt=We.create,zt=Ge.create,qt=He.create,Dt=Je.create,Ft=Qe.create,Vt=Ye.create,Ut=Xe.create,Bt=et.create,Kt=tt.create,Wt=rt.create,Gt=rt.strictCreate,Ht=nt.create,Jt=it.create,Qt=ct.create,Yt=dt.create,Xt=ut.create,es=pt.create,ts=lt.create,ss=ht.create,rs=ft.create,ns=mt.create,as=yt.create,is=vt.create,os=bt.create,cs=_t.create,ds=wt.create,us=kt.create,ps=_t.createWithPreprocess,ls=Zt.create,hs={string:e=>Fe.create({...e,coerce:!0}),number:e=>Ue.create({...e,coerce:!0}),boolean:e=>Ke.create({...e,coerce:!0}),bigint:e=>Be.create({...e,coerce:!0}),date:e=>We.create({...e,coerce:!0})},fs=ke;var ms=Object.freeze({__proto__:null,defaultErrorMap:ge,setErrorMap:function(e){ye=e},getErrorMap:ve,makeIssue:be,EMPTY_PATH:[],addIssueToContext:_e,ParseStatus:we,INVALID:ke,DIRTY:xe,OK:Se,isAborted:Pe,isDirty:Oe,isValid:Ee,isAsync:Ze,get util(){return ue},get objectUtil(){return pe},ZodParsedType:le,getParsedType:he,ZodType:Ie,ZodString:Fe,ZodNumber:Ue,ZodBigInt:Be,ZodBoolean:Ke,ZodDate:We,ZodSymbol:Ge,ZodUndefined:He,ZodNull:Je,ZodAny:Qe,ZodUnknown:Ye,ZodNever:Xe,ZodVoid:et,ZodArray:tt,ZodObject:rt,ZodUnion:nt,ZodDiscriminatedUnion:it,ZodIntersection:ct,ZodTuple:dt,ZodRecord:ut,ZodMap:pt,ZodSet:lt,ZodFunction:ht,ZodLazy:ft,ZodLiteral:mt,ZodEnum:yt,ZodNativeEnum:vt,ZodPromise:bt,ZodEffects:_t,ZodTransformer:_t,ZodOptional:wt,ZodNullable:kt,ZodDefault:xt,ZodCatch:St,ZodNaN:Pt,BRAND:Ot,ZodBranded:Et,ZodPipeline:Zt,ZodReadonly:$t,custom:Nt,Schema:Ie,ZodSchema:Ie,late:jt,get ZodFirstPartyTypeKind(){return Tt},coerce:hs,any:Ft,array:Kt,bigint:Mt,boolean:Rt,date:Lt,discriminatedUnion:Jt,effect:cs,enum:as,function:ss,instanceof:(e,t={message:`Input not instance of ${e.name}`})=>Nt((t=>t instanceof e),t),intersection:Qt,lazy:rs,literal:ns,map:es,nan:At,nativeEnum:is,never:Ut,null:Dt,nullable:us,number:Ct,object:Wt,oboolean:()=>Rt().optional(),onumber:()=>Ct().optional(),optional:ds,ostring:()=>It().optional(),pipeline:ls,preprocess:ps,promise:os,record:Xt,set:ts,strictObject:Gt,string:It,symbol:zt,transformer:cs,tuple:Yt,undefined:qt,union:Ht,unknown:Vt,void:Bt,NEVER:fs,ZodIssueCode:fe,quotelessJson:e=>JSON.stringify(e,null,2).replace(/"([^"]+)":/g,"$1:"),ZodError:me});function gs(e,t,s,r){r?.errorMessages&&s&&(e.errorMessage={...e.errorMessage,[t]:s})}function ys(e,t,s,r,n){e[t]=s,gs(e,t,r,n)}const vs={name:void 0,$refStrategy:"root",basePath:["#"],effectStrategy:"input",pipeStrategy:"all",dateStrategy:"string",mapStrategy:"entries",definitionPath:"definitions",target:"jsonSchema7",strictUnions:!1,definitions:{},errorMessages:!1,markdownDescription:!1,patternStrategy:"escape",emailStrategy:"format:email"};const bs=(e,t)=>{const s={type:"integer",format:"unix-time"};for(const r of e.checks)switch(r.kind){case"min":"jsonSchema7"===t.target&&ys(s,"minimum",r.value,r.message,t);break;case"max":"jsonSchema7"===t.target&&ys(s,"maximum",r.value,r.message,t)}return s};const _s={cuid:"^[cC][^\\s-]{8,}$",cuid2:"^[a-z][a-z0-9]*$",ulid:"^[0-9A-HJKMNP-TV-Z]{26}$",email:"^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",emoji:"^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",uuid:"^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",ipv4:"^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",ipv6:"^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"};function ws(e,t){const s={type:"string"};function r(e){return"escape"===t.patternStrategy?ks(e):e}if(e.checks)for(const n of e.checks)switch(n.kind){case"min":ys(s,"minLength","number"==typeof s.minLength?Math.max(s.minLength,n.value):n.value,n.message,t);break;case"max":ys(s,"maxLength","number"==typeof s.maxLength?Math.min(s.maxLength,n.value):n.value,n.message,t);break;case"email":switch(t.emailStrategy){case"format:email":xs(s,"email",n.message,t);break;case"format:idn-email":xs(s,"idn-email",n.message,t);break;case"pattern:zod":Ss(s,_s.email,n.message,t)}break;case"url":xs(s,"uri",n.message,t);break;case"uuid":xs(s,"uuid",n.message,t);break;case"regex":Ss(s,n.regex.source,n.message,t);break;case"cuid":Ss(s,_s.cuid,n.message,t);break;case"cuid2":Ss(s,_s.cuid2,n.message,t);break;case"startsWith":Ss(s,"^"+r(n.value),n.message,t);break;case"endsWith":Ss(s,r(n.value)+"$",n.message,t);break;case"datetime":xs(s,"date-time",n.message,t);break;case"length":ys(s,"minLength","number"==typeof s.minLength?Math.max(s.minLength,n.value):n.value,n.message,t),ys(s,"maxLength","number"==typeof s.maxLength?Math.min(s.maxLength,n.value):n.value,n.message,t);break;case"includes":Ss(s,r(n.value),n.message,t);break;case"ip":"v6"!==n.version&&xs(s,"ipv4",n.message,t),"v4"!==n.version&&xs(s,"ipv6",n.message,t);break;case"emoji":Ss(s,_s.emoji,n.message,t);break;case"ulid":Ss(s,_s.ulid,n.message,t)}return s}const ks=e=>Array.from(e).map((e=>/[a-zA-Z0-9]/.test(e)?e:`\\${e}`)).join(""),xs=(e,t,s,r)=>{e.format||e.anyOf?.some((e=>e.format))?(e.anyOf||(e.anyOf=[]),e.format&&(e.anyOf.push({format:e.format,...e.errorMessage&&r.errorMessages&&{errorMessage:{format:e.errorMessage.format}}}),delete e.format,e.errorMessage&&(delete e.errorMessage.format,0===Object.keys(e.errorMessage).length&&delete e.errorMessage)),e.anyOf.push({format:t,...s&&r.errorMessages&&{errorMessage:{format:s}}})):ys(e,"format",t,s,r)},Ss=(e,t,s,r)=>{e.pattern||e.allOf?.some((e=>e.pattern))?(e.allOf||(e.allOf=[]),e.pattern&&(e.allOf.push({pattern:e.pattern,...e.errorMessage&&r.errorMessages&&{errorMessage:{pattern:e.errorMessage.pattern}}}),delete e.pattern,e.errorMessage&&(delete e.errorMessage.pattern,0===Object.keys(e.errorMessage).length&&delete e.errorMessage)),e.allOf.push({pattern:t,...s&&r.errorMessages&&{errorMessage:{pattern:s}}})):ys(e,"pattern",t,s,r)};function Ps(e,t){if("openApi3"===t.target&&e.keyType?._def.typeName===Tt.ZodEnum)return{type:"object",required:e.keyType._def.values,properties:e.keyType._def.values.reduce(((s,r)=>({...s,[r]:Zs(e.valueType._def,{...t,currentPath:[...t.currentPath,"properties",r]})??{}})),{}),additionalProperties:!1};const s={type:"object",additionalProperties:Zs(e.valueType._def,{...t,currentPath:[...t.currentPath,"additionalProperties"]})??{}};if("openApi3"===t.target)return s;if(e.keyType?._def.typeName===Tt.ZodString&&e.keyType._def.checks?.length){const r=Object.entries(ws(e.keyType._def,t)).reduce(((e,[t,s])=>"type"===t?e:{...e,[t]:s}),{});return{...s,propertyNames:r}}return e.keyType?._def.typeName===Tt.ZodEnum?{...s,propertyNames:{enum:e.keyType._def.values}}:s}const Os={ZodString:"string",ZodNumber:"number",ZodBigInt:"integer",ZodBoolean:"boolean",ZodNull:"null"};const Es=(e,t)=>{const s=(e.options instanceof Map?Array.from(e.options.values()):e.options).map(((e,s)=>Zs(e._def,{...t,currentPath:[...t.currentPath,"anyOf",`${s}`]}))).filter((e=>!!e&&(!t.strictUnions||"object"==typeof e&&Object.keys(e).length>0)));return s.length?{anyOf:s}:void 0};function Zs(e,t,s=!1){const r=t.seen.get(e);if(r&&!s){const e=$s(r,t);if(void 0!==e)return e}const n={def:e,path:t.currentPath,jsonSchema:void 0};t.seen.set(e,n);const a=js(e,e.typeName,t);return a&&Ts(e,t,a),n.jsonSchema=a,a}const $s=(e,t)=>{switch(t.$refStrategy){case"root":return{$ref:e.path.join("/")};case"relative":return{$ref:Ns(t.currentPath,e.path)};case"none":case"seen":return e.path.length<t.currentPath.length&&e.path.every(((e,s)=>t.currentPath[s]===e))?(console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`),{}):"seen"===t.$refStrategy?{}:void 0}},Ns=(e,t)=>{let s=0;for(;s<e.length&&s<t.length&&e[s]===t[s];s++);return[(e.length-s).toString(),...t.slice(s)].join("/")},js=(e,t,s)=>{switch(t){case Tt.ZodString:return ws(e,s);case Tt.ZodNumber:return function(e,t){const s={type:"number"};if(!e.checks)return s;for(const r of e.checks)switch(r.kind){case"int":s.type="integer",gs(s,"type",r.message,t);break;case"min":"jsonSchema7"===t.target?r.inclusive?ys(s,"minimum",r.value,r.message,t):ys(s,"exclusiveMinimum",r.value,r.message,t):(r.inclusive||(s.exclusiveMinimum=!0),ys(s,"minimum",r.value,r.message,t));break;case"max":"jsonSchema7"===t.target?r.inclusive?ys(s,"maximum",r.value,r.message,t):ys(s,"exclusiveMaximum",r.value,r.message,t):(r.inclusive||(s.exclusiveMaximum=!0),ys(s,"maximum",r.value,r.message,t));break;case"multipleOf":ys(s,"multipleOf",r.value,r.message,t)}return s}(e,s);case Tt.ZodObject:return function(e,t){const s={type:"object",...Object.entries(e.shape()).reduce(((e,[s,r])=>{if(void 0===r||void 0===r._def)return e;const n=Zs(r._def,{...t,currentPath:[...t.currentPath,"properties",s],propertyPath:[...t.currentPath,"properties",s]});return void 0===n?e:{properties:{...e.properties,[s]:n},required:r.isOptional()?e.required:[...e.required,s]}}),{properties:{},required:[]}),additionalProperties:"ZodNever"===e.catchall._def.typeName?"passthrough"===e.unknownKeys:Zs(e.catchall._def,{...t,currentPath:[...t.currentPath,"additionalProperties"]})??!0};return s.required.length||delete s.required,s}(e,s);case Tt.ZodBigInt:return function(e,t){const s={type:"integer",format:"int64"};if(!e.checks)return s;for(const r of e.checks)switch(r.kind){case"min":"jsonSchema7"===t.target?r.inclusive?ys(s,"minimum",r.value,r.message,t):ys(s,"exclusiveMinimum",r.value,r.message,t):(r.inclusive||(s.exclusiveMinimum=!0),ys(s,"minimum",r.value,r.message,t));break;case"max":"jsonSchema7"===t.target?r.inclusive?ys(s,"maximum",r.value,r.message,t):ys(s,"exclusiveMaximum",r.value,r.message,t):(r.inclusive||(s.exclusiveMaximum=!0),ys(s,"maximum",r.value,r.message,t));break;case"multipleOf":ys(s,"multipleOf",r.value,r.message,t)}return s}(e,s);case Tt.ZodBoolean:return{type:"boolean"};case Tt.ZodDate:return function(e,t){return"integer"==t.dateStrategy?bs(e,t):{type:"string",format:"date-time"}}(e,s);case Tt.ZodUndefined:return{not:{}};case Tt.ZodNull:return function(e){return"openApi3"===e.target?{enum:["null"],nullable:!0}:{type:"null"}}(s);case Tt.ZodArray:return function(e,t){const s={type:"array"};return e.type?._def?.typeName!==Tt.ZodAny&&(s.items=Zs(e.type._def,{...t,currentPath:[...t.currentPath,"items"]})),e.minLength&&ys(s,"minItems",e.minLength.value,e.minLength.message,t),e.maxLength&&ys(s,"maxItems",e.maxLength.value,e.maxLength.message,t),e.exactLength&&(ys(s,"minItems",e.exactLength.value,e.exactLength.message,t),ys(s,"maxItems",e.exactLength.value,e.exactLength.message,t)),s}(e,s);case Tt.ZodUnion:case Tt.ZodDiscriminatedUnion:return function(e,t){if("openApi3"===t.target)return Es(e,t);const s=e.options instanceof Map?Array.from(e.options.values()):e.options;if(s.every((e=>e._def.typeName in Os&&(!e._def.checks||!e._def.checks.length)))){const e=s.reduce(((e,t)=>{const s=Os[t._def.typeName];return s&&!e.includes(s)?[...e,s]:e}),[]);return{type:e.length>1?e:e[0]}}if(s.every((e=>"ZodLiteral"===e._def.typeName&&!e.description))){const e=s.reduce(((e,t)=>{const s=typeof t._def.value;switch(s){case"string":case"number":case"boolean":return[...e,s];case"bigint":return[...e,"integer"];case"object":if(null===t._def.value)return[...e,"null"];default:return e}}),[]);if(e.length===s.length){const t=e.filter(((e,t,s)=>s.indexOf(e)===t));return{type:t.length>1?t:t[0],enum:s.reduce(((e,t)=>e.includes(t._def.value)?e:[...e,t._def.value]),[])}}}else if(s.every((e=>"ZodEnum"===e._def.typeName)))return{type:"string",enum:s.reduce(((e,t)=>[...e,...t._def.values.filter((t=>!e.includes(t)))]),[])};return Es(e,t)}(e,s);case Tt.ZodIntersection:return function(e,t){const s=[Zs(e.left._def,{...t,currentPath:[...t.currentPath,"allOf","0"]}),Zs(e.right._def,{...t,currentPath:[...t.currentPath,"allOf","1"]})].filter((e=>!!e));let r="jsonSchema2019-09"===t.target?{unevaluatedProperties:!1}:void 0;const n=[];return s.forEach((e=>{if((e=>(!("type"in e)||"string"!==e.type)&&"allOf"in e)(e))n.push(...e.allOf),void 0===e.unevaluatedProperties&&(r=void 0);else{let t=e;if("additionalProperties"in e&&!1===e.additionalProperties){const{additionalProperties:s,...r}=e;t=r}else r=void 0;n.push(t)}})),n.length?{allOf:n,...r}:void 0}(e,s);case Tt.ZodTuple:return function(e,t){return e.rest?{type:"array",minItems:e.items.length,items:e.items.map(((e,s)=>Zs(e._def,{...t,currentPath:[...t.currentPath,"items",`${s}`]}))).reduce(((e,t)=>void 0===t?e:[...e,t]),[]),additionalItems:Zs(e.rest._def,{...t,currentPath:[...t.currentPath,"additionalItems"]})}:{type:"array",minItems:e.items.length,maxItems:e.items.length,items:e.items.map(((e,s)=>Zs(e._def,{...t,currentPath:[...t.currentPath,"items",`${s}`]}))).reduce(((e,t)=>void 0===t?e:[...e,t]),[])}}(e,s);case Tt.ZodRecord:return Ps(e,s);case Tt.ZodLiteral:return function(e,t){const s=typeof e.value;return"bigint"!==s&&"number"!==s&&"boolean"!==s&&"string"!==s?{type:Array.isArray(e.value)?"array":"object"}:"openApi3"===t.target?{type:"bigint"===s?"integer":s,enum:[e.value]}:{type:"bigint"===s?"integer":s,const:e.value}}(e,s);case Tt.ZodEnum:return function(e){return{type:"string",enum:e.values}}(e);case Tt.ZodNativeEnum:return function(e){const t=e.values,s=Object.keys(e.values).filter((e=>"number"!=typeof t[t[e]])).map((e=>t[e])),r=Array.from(new Set(s.map((e=>typeof e))));return{type:1===r.length?"string"===r[0]?"string":"number":["string","number"],enum:s}}(e);case Tt.ZodNullable:return function(e,t){if(["ZodString","ZodNumber","ZodBigInt","ZodBoolean","ZodNull"].includes(e.innerType._def.typeName)&&(!e.innerType._def.checks||!e.innerType._def.checks.length))return"openApi3"===t.target?{type:Os[e.innerType._def.typeName],nullable:!0}:{type:[Os[e.innerType._def.typeName],"null"]};if("openApi3"===t.target){const s=Zs(e.innerType._def,{...t,currentPath:[...t.currentPath]});return s&&"$ref"in s?{allOf:[s],nullable:!0}:s&&{...s,nullable:!0}}const s=Zs(e.innerType._def,{...t,currentPath:[...t.currentPath,"anyOf","0"]});return s&&{anyOf:[s,{type:"null"}]}}(e,s);case Tt.ZodOptional:return((e,t)=>{if(t.currentPath.toString()===t.propertyPath?.toString())return Zs(e.innerType._def,t);const s=Zs(e.innerType._def,{...t,currentPath:[...t.currentPath,"anyOf","1"]});return s?{anyOf:[{not:{}},s]}:{}})(e,s);case Tt.ZodMap:return function(e,t){return"record"===t.mapStrategy?Ps(e,t):{type:"array",maxItems:125,items:{type:"array",items:[Zs(e.keyType._def,{...t,currentPath:[...t.currentPath,"items","items","0"]})||{},Zs(e.valueType._def,{...t,currentPath:[...t.currentPath,"items","items","1"]})||{}],minItems:2,maxItems:2}}}(e,s);case Tt.ZodSet:return function(e,t){const s={type:"array",uniqueItems:!0,items:Zs(e.valueType._def,{...t,currentPath:[...t.currentPath,"items"]})};return e.minSize&&ys(s,"minItems",e.minSize.value,e.minSize.message,t),e.maxSize&&ys(s,"maxItems",e.maxSize.value,e.maxSize.message,t),s}(e,s);case Tt.ZodLazy:return Zs(e.getter()._def,s);case Tt.ZodPromise:return function(e,t){return Zs(e.type._def,t)}(e,s);case Tt.ZodNaN:case Tt.ZodNever:return{not:{}};case Tt.ZodEffects:return function(e,t){return"input"===t.effectStrategy?Zs(e.schema._def,t):{}}(e,s);case Tt.ZodAny:case Tt.ZodUnknown:return{};case Tt.ZodDefault:return function(e,t){return{...Zs(e.innerType._def,t),default:e.defaultValue()}}(e,s);case Tt.ZodBranded:return function(e,t){return Zs(e.type._def,t)}(e,s);case Tt.ZodReadonly:case Tt.ZodCatch:return((e,t)=>Zs(e.innerType._def,t))(e,s);case Tt.ZodPipeline:return((e,t)=>{if("input"===t.pipeStrategy)return Zs(e.in._def,t);if("output"===t.pipeStrategy)return Zs(e.out._def,t);const s=Zs(e.in._def,{...t,currentPath:[...t.currentPath,"allOf","0"]});return{allOf:[s,Zs(e.out._def,{...t,currentPath:[...t.currentPath,"allOf",s?"1":"0"]})].filter((e=>void 0!==e))}})(e,s);case Tt.ZodFunction:case Tt.ZodVoid:case Tt.ZodSymbol:default:return}},Ts=(e,t,s)=>(e.description&&(s.description=e.description,t.markdownDescription&&(s.markdownDescription=e.description)),s),Is=e=>{const t=(e=>"string"==typeof e?{...vs,name:e}:{...vs,...e})(e),s=void 0!==t.name?[...t.basePath,t.definitionPath,t.name]:t.basePath;return{...t,currentPath:s,propertyPath:void 0,seen:new Map(Object.entries(t.definitions).map((([e,s])=>[s._def,{def:s._def,path:[...t.basePath,t.definitionPath,e],jsonSchema:void 0}])))}},Cs=(e,t)=>{const s=Is(t),r="object"==typeof t&&t.definitions?Object.entries(t.definitions).reduce(((e,[t,r])=>({...e,[t]:Zs(r._def,{...s,currentPath:[...s.basePath,s.definitionPath,t]},!0)??{}})),{}):void 0,n="string"==typeof t?t:t?.name,a=Zs(e._def,void 0===n?s:{...s,currentPath:[...s.basePath,s.definitionPath,n]},!1)??{},i=void 0===n?r?{...a,[s.definitionPath]:r}:a:{$ref:[..."relative"===s.$refStrategy?[]:s.basePath,s.definitionPath,n].join("/"),[s.definitionPath]:{...r,[n]:a}};return"jsonSchema7"===s.target?i.$schema="http://json-schema.org/draft-07/schema#":"jsonSchema2019-09"===s.target&&(i.$schema="https://json-schema.org/draft/2019-09/schema#"),i};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function As(e){if(t=e,"function"!=typeof t?.parse)return e;var t;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const s=Cs(e);delete s.$schema;const r=e=>{if(e.description){const[t,s]=e.description.split(":",2);e.title=t.trim(),e.description=s.trim()}e.properties&&Object.values(e.properties).forEach((e=>r(e)))};return r(s),s}function Ms(e,t){return e.schema&&e.schema instanceof ms.ZodType&&(e.schema=As(e.schema)),t(e)}let Rs;function Ls(){return Rs||(Rs=new qs),Rs}function zs(e){const t=Ls();return Rs=e,t}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class qs extends oe{#B;#K=[];parentLambdaNode;constructor(e={}){super(e),this.#B=e.serialize??!1,this.parentLambdaNode=e.parentLambda}async serialize(e,t){return super.serialize(e,t&&"function"==typeof t.unProxy?t.unProxy():t)}serializing(){return this.#B}asScopeFor(e){return(...t)=>{const s=zs(this);try{return e(...t)}finally{zs(s)}}}addClosureEdge(e){this.#K.push(e)}getClosureEdges(){return this.#K}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ds{}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Fs=Symbol("IsValue");function Vs(e){return("object"==typeof e||"function"==typeof e)&&void 0!==e[Fs]}class Us extends Ds{#W;#A;#G;#H;#J;constructor(e,t,s,r=!1,n={}){super(),this.#W=e,this.#A=t,this.#G="string"==typeof s?{[s]:s}:s,this[Fs]=this,this.#H=r,this.#J=n}then(e,t){if(1!==Object.keys(this.#G).length)throw Error("Can't `await` for multiple values");return this.#W.then((t=>t&&e&&this.#A.asScopeFor(e)(t[Object.keys(this.#G)[0]])),t&&this.#A.asScopeFor(t))}asNodeInput(){return[this.#W.unProxy(),this.#G,this.#H,this.#J]}to(e,t){const s=Ks(e)?e.unProxy():new Bs(e,this.#A,t);return s.addInputsFromNode(this.#W,this.#G,this.#H,this.#J),s.asProxy()}in(e){let t=Object.fromEntries(Object.entries(this.#G).map((([e,t])=>[t,e])));Vs(e)?(t=e.#Q(t),this.#W.addInputsFromNode(e.#W,t,e.#H,e.#J)):Ks(e)?this.#W.addInputsFromNode(e.unProxy(),t):this.#W.addInputsAsValues(e)}as(e){let t;if("string"==typeof e){if(1!==Object.keys(this.#G).length)throw new Error("Can't rename multiple values with a single string");t={[Object.keys(this.#G)[0]]:e}}else t=this.#Q(e);return new Us(this.#W,this.#A,t,this.#H,this.#J)}memoize(){return new Us(this.#W,this.#A,this.#G,!0,this.#J)}invoke(e){return new Bs("invoke",this.#A,{...e,$board:this}).asProxy()}isUnknown(){return delete this.#J.type,this}isString(){return this.#J.type="string",this}isNumber(){return this.#J.type="number",this}isBoolean(){return this.#J.type="boolean",this}isArray(){return this.#J.type="array",this}isImage(e="image/png"){return this.#J.type=e,this}isObject(){return this.#J.type="object",this}title(e){return this.#J.title=e,this}description(e){return this.#J.description=e,this}format(e){return this.#J.format=e,this}examples(...e){return this.#J.examples=e,this}default(e){return this.#J.default=e,this}optional(){return this.#J.$optional=!0,this}transient(){return this.#J.$optional=!0,this}#Q(e){const t={...this.#G};return Object.entries(e).forEach((([e,s])=>{this.#G[s]?(t[e]=this.#G[s],delete this.#G[s]):t[e]=s})),t}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Bs extends ae{#Y;#X;#ee;#A;#C;constructor(e,t,s={}){const r=!Ks(s)&&!(s instanceof re)&&!Xs(s)&&!Vs(s)&&s.$id;super(e,t,r?{$id:r}:{}),this.#A=t,"string"!=typeof e&&(this.#C=e),Ks(s)?this.addInputsFromNode(s.unProxy()):s instanceof re?this.addInputsFromNode(s):Xs(s)?this.addInputsAsValues({$board:s.getBoardCapabilityAsValue()}):Vs(s)?this.addInputsFromNode(...s.asNodeInput()):(void 0!==s.$id&&delete s.$id,this.addInputsAsValues(s)),this[this.#te()]=this,this.#Y=new Promise(((e,t)=>{this.#X=e,this.#ee=t}))}addInputsAsValues(e){const t={},s=[];Object.entries(e).forEach((([e,r])=>{Xs(r)&&(r=r.getBoardCapabilityAsValue()),Vs(r)?s.push(r.as(e).asNodeInput()):r instanceof re||Ks(r)?s.push([Ks(r)?r.unProxy():r,{[e]:e},!1,void 0]):t[e]=r})),this.configuration={...this.configuration,...t},s.forEach((e=>this.unProxy().addInputsFromNode(...e)))}addInputsFromNode(e,t={"*":""},s,r){const n=Object.entries(t);0===n.length?this.addIncomingEdge(e,"","",s):n.forEach((([t,n])=>{t.startsWith("*-")&&(t="*",n=""),this.unProxy().addIncomingEdge(Ks(e)?e.unProxy():e,t,n,s,r)}))}addIncomingEdge(e,t,s,r,n){const a=e.#A;if(a!==this.#A){for(let e=this.#A;e!==a;e=e.parentLexicalScope)if(!e)throw new Error("Only wires from parent scopes allowed");if("*"===t||""===t)throw new Error("Can't use * or empty wires from parent scopes");this.#A.addClosureEdge({scope:a,from:e,to:this,out:t,in:s})}else super.addIncomingEdge(e,t,s,r,n)}async invoke(e,t){const s=new qs({dynamicScope:t,lexicalScope:this.#A});return s.asScopeFor((async()=>{try{const t=this.#C??s.getHandler(this.type);let r;const n="function"==typeof t?t:t?.invoke;if(n)r=await n(e,this);else{if(!t||"function"==typeof t||!t.graph)throw new Error(`Can't find handler for ${this.id}`);{const n=t.graph.getPinnedNodes();if(1!==n.length)throw new Error("Expected exactly one graph");r=await s.invokeOneRound(e,n[0])}}for(const[e,t]of Object.entries(r))t instanceof Bs?r[e]=(await t)[e]:Vs(t)?r[e]=await t:Xs(t)&&(r[e]=await t.getBoardCapabilityAsValue());return this.#X&&(this.#X(r),this.#X=this.#ee=void 0),r}catch(e){throw this.#ee&&(this.#ee(e),this.#X=this.#ee=void 0),e}}))()}async serializeNode(){for(const[e,t]of Object.entries(this.configuration))t instanceof Promise&&(this.configuration[e]=await t);if("fn"!==this.type)return super.serializeNode();const e=new qs({lexicalScope:this.#A,serialize:!0}),t=this.#C??e.getHandler(this.type);if(t&&"function"!=typeof t&&t.graph){const s={id:this.id,type:"invoke",configuration:{...this.configuration,path:"#"+this.id}},r=t.graph.getPinnedNodes();if(1!==r.length)throw new Error("Expected exactly one graph");return[s,await e.serialize({},r[0])]}const s="function"==typeof t?t:t?.invoke;if(!s)throw new Error(`Handler for ${this.type} in ${this.id} not found`);let r=s.toString(),n=this.id.replace(/-/g,"_");const a=/(?:async\s*)?(\w+|\([^)]*\))\s*=>\s*/,i=/(?:async\s+)?function\s+(\w+)\s*\(([^)]*)\)\s*\{/;if(a.test(r))r=r.replace(a,((e,t)=>{const s=r.trim().startsWith("async")?"async ":"",a=t.startsWith("(")?t:`(${t})`;return`${s}function ${n}${a} `}));else{const e=i.exec(r);if(null===e)throw new Error("Unexpected seralization: "+r);n=e[1]||n}const o=await this.describe(e),c={edges:[{from:`${this.id}-input`,to:`${this.id}-run`,out:"*"},{from:`${this.id}-run`,to:`${this.id}-output`,out:"*"}],nodes:[{id:`${this.id}-input`,type:"input",configuration:o?.inputSchema?{schema:o.inputSchema}:{}},{id:`${this.id}-run`,type:"runJavascript",configuration:{...this.configuration,code:r,name:n,raw:!0}},{id:`${this.id}-output`,type:"output",configuration:o?.outputSchema?{schema:o.outputSchema}:{}}]};return[{id:this.id,type:"invoke",configuration:{path:"#"+this.id}},c]}asProxy(){return new Proxy(this,{get(e,t,s){if("string"==typeof t){const s=new Us(e,e.#A,t);let r=e[t];return r=r&&"function"==typeof r?r.bind(e):(e=>s.invoke(e)).bind(s),new Proxy(r,{get(e,t,r){const n=Reflect.get(s,t,s);return"function"==typeof n?n.bind(s):n},ownKeys:e=>Reflect.ownKeys(s).filter((e=>"string"==typeof e))})}return Reflect.get(e,t,s)},ownKeys:e=>[e.#te()]})}unProxy(){return this}then(e,t){if(this.#A.serializing())throw new Error(`Can't \`await\` on ${this.id} in board declaration. Did you mean to use \`code\` instead of \`board\`?`);try{return this.#A.invoke(this).catch((e=>{if(t)return Promise.reject(e).catch(this.#A.asScopeFor(t));throw e})),this.#Y.then(e&&this.#A.asScopeFor(e),t&&this.#A.asScopeFor(t))}catch(e){if(t)return Promise.reject(e).catch(this.#A.asScopeFor(t));throw e}}to(e,t){const s=Ks(e)?e.unProxy():new Bs(e,this.#A,t);return s.addInputsFromNode(this,{"*":""}),s.asProxy()}in(e){return e instanceof ae?this.addInputsFromNode(e):Vs(e)?this.addInputsFromNode(...e.asNodeInput()):this.addInputsAsValues(e),this.asProxy()}as(e){return new Us(this,this.#A,e)}keys(){return[this.#te()]}#te(){return"*-"+this.id}}function Ks(e){return"function"==typeof e.unProxy}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ws(e,t){return e&&Gs(e,t),s=>new Bs(e??t,Ls(),s).asProxy()}function Gs(e,t){Ls().addHandlers({[e]:t})}function Hs(e,t=""){const s=se(new e({})),r=t?e=>e.startsWith(t)?e.slice(t.length):e:e=>e;return Object.fromEntries(Object.entries(s).map((([e,t])=>[r(e),Ws(e,t)])))}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Js=(e,t)=>{const s="object"==typeof e?e:{};return s.graph??="function"==typeof e?e:t,Ys(s)},Qs=e=>Ys({invoke:e});function Ys(e){if(!e.invoke&&!e.graph)throw new Error("Missing invoke or graph definition function");const t=Ls(),s=[],{url:r,title:n,description:a,version:i}=e??{},o={...r?{url:r}:{},...n?{title:n}:{},...a?{description:a}:{},...i?{version:i}:{}},c=e.input&&As(e.input),d=e.output&&As(e.output),u={};if(e.describe?u.describe=e.describe:c&&d&&(u.describe=async()=>({inputSchema:c,outputSchema:d})),e.invoke&&(u.invoke=e.invoke),e.graph){const r=new qs({lexicalScope:t,serialize:!0});if(r.asScopeFor((()=>{const t=new Bs("input",r,c?{schema:c}:{}),s=new Bs("output",r,d?{schema:d}:{}),n=(e,t)=>{const s=new Bs(e,r,t);return r.pin(s),s.asProxy()},a={input:n.bind(null,"input"),output:n.bind(null,"output")},i=e.graph?.(t.asProxy(),a);if(void 0===i)return;if(i instanceof Promise)throw new Error("Graph generation function can't be async");let o=s;if(i instanceof Bs){const e=i.unProxy();"output"===e.type?o=e:s.addInputsFromNode(e)}else{if("object"!=typeof i)throw new Error(`Unexpected return ${typeof i} value from graph declaration`);s.addInputsAsValues(i)}r.pin(o)}))(),r.getClosureEdges().length>0){const e=new Bs("input",r,{$id:"closure-input"});r.pin(e);for(const t of r.getClosureEdges()){const{to:r,out:n,in:a}=t,i=`$l-${n}-${r.id}`;r.addIncomingEdge(e,i,a,!0),s.push({...t,to:e,in:i})}}r.compactPins();const n=r.getPinnedNodes().length;if(1!==n)throw 0===n?new Error("If not returning a graph, use `base.input` and `base.output`."):new Error(`Expected exactly one graph, but got ${n}. Are ${r.getPinnedNodes().map((e=>e.id)).join(", ")} maybe disjoint?`);u.graph=r}let p;e.name&&Gs(e.name,u);const l=e=>!p||0===p.incoming.length&&0==s.length?new Bs(u,Ls(),e).asProxy():new Bs("invoke",Ls(),{...e,$board:p.asProxy().board});function h(){if(p)return p;const e=l.serialize();return p=new Bs("lambda",t,{board:(async()=>({kind:"board",board:{kits:[],...await e}}))()}),l.serialize=async t=>{if(0===p?.incoming.length&&0===s.length)return await e;return new Bs("invoke",Ls(),{$board:p?.asProxy().board}).serialize({...o,...t})},p}l.serialize=async e=>{const s=new Bs(u,t),[r,n]=await s.serializeNode();if(n){if("invoke"!==r.type)throw new Error("Unexpected node with graph");return{...o,...e,...n}}return{...o,...e,edges:[{from:`${r.id}-input`,to:r.id,out:"*"},{from:r.id,to:`${r.id}-output`,out:"*"}],nodes:[{id:`${r.id}-input`,type:"input",configuration:c?{schema:c}:{}},r,{id:`${r.id}-output`,type:"output",configuration:d?{schema:d}:{}}]}},l.getBoardCapabilityAsValue=()=>void 0!==p&&(p.incoming.length>0||s.length>0)?p.asProxy().board:(async()=>({kind:"board",board:{kits:[],...await l.serialize()}}))(),l.unProxy=()=>h().unProxy(),l.in=e=>(h().in(e),l);for(const{scope:e,from:r,out:n,in:a}of s)e===t?h().addIncomingEdge(r,n,a,!0):t.addClosureEdge({scope:e,from:r,to:h(),out:n,in:a});return l}function Xs(e){return"function"==typeof e&&"function"==typeof e.getBoardCapabilityAsValue}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const er=async()=>{throw new Error("Reserved word handler should never be invoked")},tr=Ws("input",er),sr=Ws("output",er),rr={input:e=>Ms(e,tr),output:e=>Ms(e,sr)};export{H as Board,D as BoardRunner,s as MachineResult,K as Node,p as RunResult,de as Runner,Z as SchemaBuilder,Q as StreamCapability,a as TraversalMachine,Hs as addKit,W as asRuntimeKit,R as asyncGen,rr as base,Js as board,k as callHandler,Y as clone,Qs as code,X as isStreamCapability,ee as patchReadableStream,Js as recipe,te as streamFromAsyncGen,O as toMermaid,z as traversalResultFromStack};
//# sourceMappingURL=index.min.js.map
