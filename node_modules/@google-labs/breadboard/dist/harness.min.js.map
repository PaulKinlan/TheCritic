{"version":3,"file":"harness.min.js","sources":["src/traversal/index.js","src/traversal/state.js","src/traversal/result.js","src/traversal/iterator.js","src/traversal/representation.js","src/traversal/machine.js","src/serialization.js","src/timestamp.js","src/run.js","src/loader.js","src/remote.js","src/handler.js","src/mermaid.js","src/schema.js","src/bubble.js","src/utils/async-gen.js","src/stack.js","src/runner.js","src/id.js","src/node.js","src/kits/ctors.js","src/board.js","src/remote/init.js","src/harness/diagnostics.js","src/stream.js","src/remote/run.js","src/remote/worker.js","src/kits/builder.js","src/remote/tunnel.js","src/remote/proxy.js","src/harness/kits.js","src/harness/url.js","src/harness/serve.js","src/new/runner/types.js","src/new/runner/node.js","src/new/runner/state.js","src/new/runner/scope.js","src/new/grammar/default-scope.js","src/new/grammar/scope.js","src/new/grammar/types.js","src/new/grammar/value.js","src/new/grammar/node.js","src/new/grammar/kits.js","src/new/grammar/board.js","src/new/grammar/base.js","src/remote/http.js","src/harness/local.js","src/harness/secrets.js","src/harness/worker.js","src/harness/run.js"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * This class holds important parts of the graph traversal algorithm.\n */\nexport class Traversal {\n    /**\n     * Computes the missing inputs for a node. A missing input is an input that is\n     * required by the node, but is not (yet) available in the current state.\n     * @param heads All the edges that point to the node.\n     * @param inputs The input values that will be passed to the node\n     * @param current The node that is being visited.\n     * @returns Array of missing input names.\n     */\n    static computeMissingInputs(heads, inputs, current) {\n        const requiredInputs = [\n            ...new Set(heads\n                .filter((edge) => !!edge.in && !edge.optional)\n                .map((edge) => edge.in || \"\")),\n        ];\n        const inputsWithConfiguration = new Set();\n        Object.keys(inputs).forEach((key) => inputsWithConfiguration.add(key));\n        if (current.configuration) {\n            Object.keys(current.configuration).forEach((key) => inputsWithConfiguration.add(key));\n        }\n        return requiredInputs.filter((input) => !inputsWithConfiguration.has(input));\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class MachineEdgeState {\n    state = new Map();\n    constants = new Map();\n    #queueOutput(map, node, key, value) {\n        let queuesMap = map.get(node);\n        if (!queuesMap) {\n            queuesMap = new Map();\n            map.set(node, queuesMap);\n        }\n        let queue = queuesMap.get(key);\n        if (!queue) {\n            queue = [];\n            queuesMap.set(key, queue);\n        }\n        queue.push(value);\n    }\n    /**\n     * Processes outputs by wiring them to the destinations according\n     * to the supplied edges. Assumes that the outputs were generated by\n     * the from node.\n     *\n     * @param opportunites {Edge[]} Edges to process\n     * @param outputs {OutputValues} Outputs to wire\n     */\n    wireOutputs(opportunites, outputs) {\n        // Verify that all edges are from the same node.\n        if (opportunites.filter((opportunity) => opportunity.from != opportunites[0].from).length !== 0)\n            throw new Error(\"All opportunities must be from the same node\");\n        opportunites.forEach((opportunity) => {\n            const to = opportunity.to;\n            const out = opportunity.out;\n            const queuesMap = opportunity.constant ? this.constants : this.state;\n            if (!out)\n                return;\n            if (out === \"*\") {\n                for (const key in outputs) {\n                    const output = outputs[key];\n                    if (output != null && output != undefined)\n                        this.#queueOutput(queuesMap, to, key, output);\n                }\n            }\n            else if (opportunity.in) {\n                const output = outputs[out];\n                // TODO: Check and document why we don't allow that\n                if (output != null && output != undefined)\n                    this.#queueOutput(queuesMap, to, opportunity.in, output);\n            }\n        });\n    }\n    /**\n     * Returns the available inputs for a given node.\n     *\n     * @param nodeId {NodeIdentifier} The node to get the inputs for.\n     * @returns {InputValues} The available inputs.\n     */\n    getAvailableInputs(nodeId) {\n        const result = {};\n        for (const queuesMap of [\n            this.constants.get(nodeId), // Constants are overwritten by state.\n            this.state.get(nodeId),\n        ]) {\n            if (!queuesMap)\n                continue;\n            for (const [key, queue] of queuesMap.entries()) {\n                if (queue.length === 0)\n                    continue;\n                result[key] = queue[0];\n            }\n        }\n        return result;\n    }\n    /**\n     * Shifts inputs from the queues. Leaves constants as is.\n     *\n     * @param nodeId {NodeIdentifier} The node to shift the inputs for.\n     * @param inputs {InputValues} The inputs that are used.\n     */\n    useInputs(nodeId, inputs) {\n        const queuesMap = this.state.get(nodeId);\n        if (!queuesMap)\n            return;\n        for (const key in inputs) {\n            const queue = queuesMap.get(key);\n            if (!queue)\n                continue;\n            queue.shift();\n        }\n    }\n}\n//# sourceMappingURL=state.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { MachineEdgeState } from \"./state.js\";\nexport class MachineResult {\n    descriptor;\n    inputs;\n    missingInputs;\n    opportunities;\n    newOpportunities;\n    state;\n    outputsPromise;\n    pendingOutputs;\n    constructor(descriptor, inputs, missingInputs, opportunities, newOpportunities, state, pendingOutputs) {\n        this.descriptor = descriptor;\n        this.inputs = inputs;\n        this.missingInputs = missingInputs;\n        this.opportunities = opportunities;\n        this.newOpportunities = newOpportunities;\n        this.state = state;\n        this.pendingOutputs = pendingOutputs;\n    }\n    /**\n     * `true` if the machine decided that the node should be skipped, rather than\n     * visited.\n     */\n    get skip() {\n        return this.missingInputs.length > 0;\n    }\n    static fromObject(o) {\n        const edgeState = new MachineEdgeState();\n        edgeState.constants = o.state.constants;\n        edgeState.state = o.state.state;\n        return new MachineResult(o.descriptor, o.inputs, o.missingInputs, o.opportunities, o.newOpportunities, edgeState, o.pendingOutputs);\n    }\n}\n//# sourceMappingURL=result.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Traversal } from \"./index.js\";\nimport { MachineResult } from \"./result.js\";\nexport class TraversalMachineIterator {\n    graph;\n    #current;\n    #noParallelExecution;\n    constructor(graph, result, noParallelExecution = true) {\n        this.graph = graph;\n        this.#current = result;\n        this.#noParallelExecution = noParallelExecution;\n    }\n    static #processCompletedNode(result, completedNodeOutput) {\n        const { promiseId, outputs, newOpportunities } = completedNodeOutput;\n        result.pendingOutputs.delete(promiseId);\n        // If there was an error, ignore all other outputs and hence opportunites.\n        const opportunities = outputs.$error\n            ? newOpportunities.filter((e) => e.out === \"$error\")\n            : newOpportunities;\n        // Process outputs.\n        result.opportunities.push(...opportunities);\n        result.state.wireOutputs(opportunities, outputs);\n        if (outputs.$error) {\n            if (opportunities.length === 0) {\n                // If the node threw an exception and it wasn't routed via $error,\n                // throw it again. This will cause the traversal to stop.\n                throw new Error(\"Uncaught exception in node handler. Catch by wiring up the $error output.\", {\n                    cause: outputs.$error,\n                });\n            }\n            else {\n                globalThis.console.warn(\"Error in node handler, passing to the wired $error output.\", outputs.$error, opportunities);\n            }\n        }\n    }\n    static async processAllPendingNodes(result) {\n        const completed = await Promise.all(result.pendingOutputs.values());\n        completed.forEach((completedNodeOutput) => {\n            TraversalMachineIterator.#processCompletedNode(result, completedNodeOutput);\n        });\n        return result;\n    }\n    async next() {\n        // If there are no missing inputs, let's consume the outputs\n        if (!this.#current.skip) {\n            const { inputs, outputsPromise, newOpportunities, descriptor } = this.#current;\n            // Mark inputs as used, i.e. shift inputs queues.\n            this.#current.state.useInputs(descriptor.id, this.#current.inputs);\n            const promiseId = Symbol();\n            const promise = new Promise((resolve) => {\n                (outputsPromise || Promise.resolve({}))\n                    .then((outputs) => {\n                    // If not already present, add inputs and descriptor along for\n                    // context and to support retries. If $error came from another node,\n                    // the descriptor will remain the original, but new inputs will be\n                    // added, though never overwriting prior ones.\n                    if (outputs.$error) {\n                        const $error = outputs.$error;\n                        outputs.$error = {\n                            descriptor,\n                            ...$error,\n                            inputs: { ...inputs, ...$error.inputs },\n                        };\n                    }\n                    resolve({ promiseId, outputs, newOpportunities });\n                })\n                    .catch((error) => {\n                    // If the handler threw an exception, turn it into a $error output.\n                    // Pass the inputs and descriptor along for context and to support\n                    // retries. This Promise will hence always resolve.\n                    resolve({\n                        promiseId,\n                        outputs: {\n                            $error: {\n                                kind: \"error\",\n                                error,\n                                inputs,\n                                descriptor,\n                            },\n                        },\n                        newOpportunities: newOpportunities.filter((edge) => edge.out === \"$error\"),\n                    });\n                });\n            });\n            this.#current.pendingOutputs.set(promiseId, promise);\n        }\n        // If there are no more opportunites or we've disabled parallel execution,\n        // let's wait for pending nodes to be done\n        while ((this.#current.opportunities.length === 0 || this.#noParallelExecution) &&\n            this.#current.pendingOutputs.size > 0) {\n            // Wait for the first pending node to be done.\n            TraversalMachineIterator.#processCompletedNode(this.#current, await Promise.race(this.#current.pendingOutputs.values()));\n        }\n        // If there are no more opportunities and none are pending, we're done.\n        if (this.#current.opportunities.length === 0)\n            return { done: true, value: null };\n        // Now, we're ready to start the next iteration.\n        // Otherwise, let's pop the next opportunity from the queue.\n        const opportunity = this.#current.opportunities.shift();\n        const { heads, nodes, tails } = this.graph;\n        const toNode = opportunity.to;\n        const currentDescriptor = nodes.get(toNode);\n        if (!currentDescriptor)\n            throw new Error(`No node found for id \"${toNode}\"`);\n        const incomingEdges = heads.get(toNode) || [];\n        const inputs = this.#current.state.getAvailableInputs(toNode);\n        const missingInputs = Traversal.computeMissingInputs(incomingEdges, inputs, currentDescriptor);\n        const newOpportunities = tails.get(toNode) || [];\n        // Pour configuration values into inputs. These are effectively like\n        // constants.\n        const inputsWithConfiguration = {\n            ...currentDescriptor.configuration,\n            ...inputs,\n        };\n        this.#current = new MachineResult(currentDescriptor, inputsWithConfiguration, missingInputs, this.#current.opportunities, newOpportunities, this.#current.state, this.#current.pendingOutputs);\n        return { done: false, value: this.#current };\n    }\n}\n//# sourceMappingURL=iterator.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class GraphRepresentation {\n    /**\n     * Tails: a map of all outgoing edges, keyed by node id.\n     */\n    tails = new Map();\n    /**\n     * Heads: a map of all incoming edges, keyed by node id.\n     */\n    heads = new Map();\n    /**\n     * Nodes: a map of all nodes, keyed by node id.\n     */\n    nodes = new Map();\n    /**\n     * Entries: a list of all nodes that have no incoming edges.\n     */\n    entries = [];\n    constructor(descriptor) {\n        this.tails = descriptor.edges.reduce((acc, edge) => {\n            const from = edge.from;\n            acc.has(from) ? acc.get(from)?.push(edge) : acc.set(from, [edge]);\n            return acc;\n        }, new Map());\n        this.heads = descriptor.edges.reduce((acc, edge) => {\n            const to = edge.to;\n            acc.has(to) ? acc.get(to)?.push(edge) : acc.set(to, [edge]);\n            return acc;\n        }, new Map());\n        this.nodes = descriptor.nodes.reduce((acc, node) => {\n            acc.set(node.id, node);\n            return acc;\n        }, new Map());\n        this.entries = Array.from(this.tails.keys()).filter((node) => !this.heads.has(node) || this.heads.get(node)?.length === 0);\n    }\n}\n//# sourceMappingURL=representation.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachineIterator } from \"./iterator.js\";\nimport { GraphRepresentation } from \"./representation.js\";\nimport { MachineResult } from \"./result.js\";\nimport { MachineEdgeState } from \"./state.js\";\nexport class TraversalMachine {\n    graph;\n    previousResult;\n    constructor(descriptor, result) {\n        this.graph = new GraphRepresentation(descriptor);\n        this.previousResult = result;\n    }\n    [Symbol.asyncIterator]() {\n        return this.start();\n    }\n    start() {\n        if (this.previousResult)\n            return new TraversalMachineIterator(this.graph, this.previousResult);\n        const { entries } = this.graph;\n        if (entries.length === 0)\n            throw new Error(\"No entry node found in graph.\");\n        // Create fake edges to represent entry points.\n        const opportunities = entries.map((entry) => ({\n            from: \"$entry\",\n            to: entry,\n        }));\n        const entryResult = new MachineResult({ id: \"$empty\", type: \"$empty\" }, {}, [], opportunities, [], new MachineEdgeState(), new Map());\n        return new TraversalMachineIterator(this.graph, entryResult);\n    }\n    static async prepareToSave(result) {\n        return await TraversalMachineIterator.processAllPendingNodes(result);\n    }\n}\n//# sourceMappingURL=machine.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachine } from \"./traversal/machine.js\";\nimport { MachineResult } from \"./traversal/result.js\";\nexport const replacer = (key, value) => {\n    if (!(value instanceof Map))\n        return value;\n    return { $type: \"Map\", value: Array.from(value.entries()) };\n};\nexport const reviver = (key, value) => {\n    const { $type } = (value || {});\n    return $type == \"Map\" && value.value\n        ? new Map(value.value)\n        : value;\n};\nexport const saveRunnerState = async (type, result) => {\n    const state = await TraversalMachine.prepareToSave(result);\n    return JSON.stringify({ state, type }, replacer);\n};\nexport const loadRunnerState = (s) => {\n    const { state: o, type } = JSON.parse(s, reviver);\n    const state = MachineResult.fromObject(o);\n    return { state, type };\n};\n//# sourceMappingURL=serialization.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const timestamp = () => globalThis.performance.now();\n//# sourceMappingURL=timestamp.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { loadRunnerState, saveRunnerState } from \"./serialization.js\";\nimport { timestamp } from \"./timestamp.js\";\nexport class RunResult {\n    #type;\n    #state;\n    // TODO: Remove #state and rename this to #state\n    #runState;\n    // TODO: Remove this once RunState machinery works\n    #invocationId;\n    constructor(state, type, runState, invocationId) {\n        this.#state = state;\n        this.#type = type;\n        this.#runState = runState;\n        this.#invocationId = invocationId;\n    }\n    get invocationId() {\n        return this.#invocationId;\n    }\n    get type() {\n        return this.#type;\n    }\n    get node() {\n        return this.#state.descriptor;\n    }\n    get inputArguments() {\n        return this.#state.inputs;\n    }\n    set inputs(inputs) {\n        this.#state.outputsPromise = Promise.resolve(inputs);\n    }\n    get outputs() {\n        return this.#state.inputs;\n    }\n    get state() {\n        return this.#state;\n    }\n    async save() {\n        return saveRunnerState(this.#type, this.#state);\n    }\n    get runState() {\n        return this.#runState;\n    }\n    get timestamp() {\n        return timestamp();\n    }\n    isAtExitNode() {\n        return (this.#state.newOpportunities.length === 0 &&\n            this.#state.opportunities.length === 0 &&\n            this.#state.pendingOutputs.size === 0);\n    }\n    static load(stringifiedResult) {\n        const { state, type } = loadRunnerState(stringifiedResult);\n        return new RunResult(state, type, undefined, 0);\n    }\n}\nexport class InputStageResult extends RunResult {\n    constructor(state, runState, invocationId) {\n        super(state, \"input\", runState, invocationId);\n    }\n    get outputs() {\n        throw new Error('Outputs are not available in the \"input\" stage');\n    }\n}\nexport class OutputStageResult extends RunResult {\n    constructor(state, invocationId) {\n        super(state, \"output\", undefined, invocationId);\n    }\n    get inputArguments() {\n        throw new Error('Input arguments are not available in the \"output\" stage');\n    }\n    set inputs(inputs) {\n        throw new Error('Setting inputs is not available in the \"output\" stage');\n    }\n}\n//# sourceMappingURL=run.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const resolveURL = (base, urlString, results) => {\n    const url = new URL(urlString, base);\n    const hash = url.hash;\n    const href = url.href;\n    const path = url.protocol === \"file:\" ? decodeURIComponent(url.pathname) : undefined;\n    const baseWithoutHash = base.href.replace(base.hash, \"\");\n    const hrefWithoutHash = href.replace(hash, \"\");\n    if (baseWithoutHash == hrefWithoutHash && hash) {\n        results.push({ type: \"hash\", location: hash.substring(1), href });\n        return true;\n    }\n    const result = path\n        ? { type: \"file\", location: path, href }\n        : href\n            ? { type: \"fetch\", location: hrefWithoutHash, href }\n            : { type: \"unknown\", location: \"\", href };\n    results.push(result);\n    return !hash;\n};\nexport const loadFromFile = async (path) => {\n    if (typeof globalThis.process === \"undefined\")\n        throw new Error(\"Unable to use `path` when not running in node\");\n    let readFileFn;\n    // The CJS transpilation process for node/vscode seems to miss this import,\n    // and leaves it as an import statement rather than converting it to a\n    // require. We therefore need a runtime check that prefers `require` if it\n    // is available.\n    if (typeof require === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const { readFile } = require(\"node:fs/promises\");\n        readFileFn = readFile;\n    }\n    else {\n        const { readFile } = await import(/* vite-ignore */ \"node:fs/promises\");\n        readFileFn = readFile;\n    }\n    return JSON.parse(await readFileFn(path, \"utf-8\"));\n};\nexport const loadWithFetch = async (url) => {\n    const response = await fetch(url);\n    return await response.json();\n};\nexport class BoardLoadingStep {\n    loaders;\n    graphs;\n    constructor(graphs) {\n        this.loaders = {\n            file: loadFromFile,\n            fetch: loadWithFetch,\n            hash: async (hash) => {\n                if (!graphs)\n                    throw new Error(\"No sub-graphs to load from\");\n                return graphs[hash];\n            },\n            unknown: async () => {\n                throw new Error(\"Unable to determine Board loader type\");\n            },\n        };\n    }\n    async load(result) {\n        const graph = await this.loaders[result.type](result.location);\n        graph.url = result.href;\n        return graph;\n    }\n}\nexport class BoardLoader {\n    #base;\n    #graphs;\n    constructor({ base, graphs }) {\n        this.#base = base;\n        this.#graphs = graphs;\n    }\n    async load(urlString) {\n        const results = [];\n        let base = this.#base;\n        while (!resolveURL(base, urlString, results)) {\n            base = new URL(results[results.length - 1].href);\n        }\n        let graph;\n        let subgraphs = this.#graphs;\n        let isSubgraph = true;\n        for (const result of results) {\n            if (result.type === \"file\" || result.type === \"fetch\")\n                isSubgraph = false;\n            const step = new BoardLoadingStep(subgraphs);\n            graph = await step.load(result);\n            subgraphs = graph.graphs;\n        }\n        if (!graph)\n            throw new Error(\"BoardLoader failed to load a graph. This error likely indicates a bug in the BoardLoader.\");\n        return { graph, isSubgraph };\n    }\n}\n//# sourceMappingURL=loader.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Polyfill to make ReadableStream async iterable\n// See https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n// eslint-disable-next-line\n// @ts-ignore\nReadableStream.prototype[Symbol.asyncIterator] ||\n    // eslint-disable-next-line\n    // @ts-ignore\n    (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {\n        const reader = this.getReader();\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    return;\n                yield value;\n            }\n        }\n        finally {\n            reader.releaseLock();\n        }\n    });\nclass BoardStreamer {\n    writable;\n    readable;\n    controller = null;\n    constructor() {\n        this.writable = new WritableStream({\n            write: (chunk) => this.write(chunk),\n        });\n        this.readable = new ReadableStream({\n            start: (controller) => {\n                this.controller = controller;\n            },\n        });\n    }\n    write(chunk) {\n        const decoder = new TextDecoder();\n        const s = decoder.decode(chunk);\n        s.split(\"\\n\")\n            .map((line) => line.trim())\n            .filter((line) => line.length > 0)\n            .forEach((line) => {\n            try {\n                if (line === \"stop\") {\n                    this.controller?.close();\n                    return;\n                }\n                const data = JSON.parse(line);\n                this.controller?.enqueue(data);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        });\n    }\n}\n/**\n * Posts the inputs to the breadboard-server and returns a stream of results.\n */\nconst post = async (url, inputs, state) => {\n    const response = await fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ inputs, state }),\n    });\n    return response.body?.pipeThrough(new BoardStreamer());\n};\nexport async function* runRemote(url) {\n    let inputs = undefined;\n    let state = undefined;\n    for (;;) {\n        const stream = await post(url, inputs, state);\n        if (!stream)\n            break;\n        for await (const result of stream) {\n            state = JSON.stringify(result.state);\n            yield result;\n            inputs = result.inputs;\n        }\n        if (!state)\n            break;\n    }\n}\n//# sourceMappingURL=remote.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst getHandlerFunction = (handler) => {\n    if (handler instanceof Function)\n        return handler;\n    if (handler.invoke)\n        return handler.invoke;\n    throw new Error(\"Invalid handler\");\n};\nexport const callHandler = async (handler, inputs, context) => {\n    // if (handler instanceof Function) return handler(inputs, context);\n    // if (handler.invoke) return handler.invoke(inputs, context);\n    const handlerFunction = getHandlerFunction(handler);\n    return new Promise((resolve) => {\n        handlerFunction(inputs, context)\n            .then(resolve)\n            .catch((error) => {\n            resolve({ $error: { error } });\n        });\n    });\n};\nexport const handlersFromKits = (kits) => {\n    return kits.reduce((handlers, kit) => {\n        // If multiple kits have the same handler, the kit earlier in the list\n        // gets precedence, including upstream kits getting precedence over kits\n        // defined in the graph.\n        //\n        // TODO: This means kits are fallback, consider non-fallback as well.\n        return { ...kit.handlers, ...handlers };\n    }, {});\n};\n//# sourceMappingURL=handler.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst template = (edges, direction) => {\n    return `%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%\ngraph ${direction};\n${edges}\nclassDef default stroke:#ffab40,fill:#fff2ccff,color:#000\nclassDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000\nclassDef output stroke:#38761d,fill:#b6d7a8ff,color:#000\nclassDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef slot stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef config stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef secrets stroke:#db4437,fill:#f4cccc,color:#000\nclassDef slotted stroke:#a64d79`;\n};\nconst unstyledTemplate = (edges, direction) => {\n    return `graph ${direction};\n${edges}`;\n};\nconst properNodeId = (node) => {\n    // Mermaid gets confused by hyphens in node ids\n    // For example `get-graph` id will throw a syntax error, because it thinks\n    // that it sees the `graph` token.\n    return node && node.replace(/-/g, \"\");\n};\nconst shape = (descriptor, idPrefix = \"\") => {\n    if (!descriptor)\n        return \"\";\n    const node = descriptor.id;\n    const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n    const nodeId = `${prefix}${properNodeId(node)}`;\n    const nodeType = descriptor.type;\n    const text = `\"${nodeType} <br> id='${node}'\"`;\n    switch (nodeType) {\n        case \"include\":\n            return `${nodeId}[[${text}]]:::include`;\n        case \"slot\":\n            return `${nodeId}((${text})):::slot`;\n        case \"passthrough\":\n            return `${nodeId}((${text})):::passthrough`;\n        case \"input\":\n            return `${nodeId}[/${text}/]:::input`;\n        case \"secrets\":\n            return `${nodeId}(${text}):::secrets`;\n        case \"output\":\n            return `${nodeId}{{${text}}}:::output`;\n        default:\n            return `${nodeId}[${text}]`;\n    }\n};\nconst describeEdge = (edge, nodeMap, idPrefix = \"\") => {\n    const from = edge.from;\n    const fromNode = shape(nodeMap.get(from), idPrefix);\n    const to = edge.to;\n    const toNode = shape(nodeMap.get(to), idPrefix);\n    const input = edge.in;\n    const output = edge.out;\n    const optional = edge.optional;\n    const constant = edge.constant;\n    if (output === \"*\") {\n        return `${fromNode} -- all --> ${toNode}`;\n    }\n    if (output && input) {\n        if (optional)\n            return `${fromNode} -. \"${output}->${input}\" .-> ${toNode}`;\n        if (constant)\n            return `${fromNode} -- \"${output}->${input}\" --o ${toNode}`;\n        return `${fromNode} -- \"${output}->${input}\" --> ${toNode}`;\n    }\n    return `${fromNode} --> ${toNode}`;\n};\nclass MermaidGenerator {\n    nodeMap;\n    edges;\n    nodes;\n    idPrefix;\n    subgraphs;\n    constructor(graph, idPrefix = \"\") {\n        const { edges, nodes } = graph;\n        this.nodeMap = new Map(nodes.map((node) => [node.id, node]));\n        this.edges = edges;\n        this.nodes = nodes;\n        this.idPrefix = idPrefix;\n        this.subgraphs = graph.graphs || {};\n    }\n    handleSlotted(fromNode, idPrefix) {\n        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n        const type = fromNode.type;\n        if (type !== \"include\")\n            return \"\";\n        const slotted = fromNode.configuration?.slotted;\n        if (!slotted)\n            return \"\";\n        const subgraphs = Object.entries(slotted).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, \"slotted\", fromNode, `${prefix}${fromNode.id}`));\n        return subgraphs.join(\"\\n\");\n    }\n    handleLambda(fromNode, idPrefix) {\n        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n        const board = fromNode.configuration?.board;\n        if (!board)\n            return \"\";\n        const capability = board;\n        if (capability.kind !== \"board\")\n            return \"\";\n        const graph = capability.board;\n        return this.describeSubgraph(graph, fromNode.id, \"lamdba\", fromNode, `${prefix}${fromNode.id}`);\n    }\n    describeSubgraphs(edge, idPrefix = \"\") {\n        const fromNode = this.nodeMap.get(edge.from);\n        if (!fromNode)\n            return \"\";\n        const lamdba = this.handleLambda(fromNode, idPrefix);\n        const slotted = this.handleSlotted(fromNode, idPrefix);\n        return `${slotted}${lamdba}`;\n    }\n    describeSubgraph(subgraph, name, edgeName, fromNode, idPrefix) {\n        const subgraphGenerator = new MermaidGenerator(subgraph, idPrefix);\n        const edges = subgraphGenerator.describeGraph();\n        const prefix = this.idPrefix ? `${properNodeId(this.idPrefix)}_` : \"\";\n        const subgraphEdge = edgeName && fromNode\n            ? `sg_${properNodeId(name)}:::slotted -- \"${edgeName}->${edgeName}\" --o ${prefix}${properNodeId(fromNode.id)}\\n`\n            : \"\";\n        return `\\nsubgraph sg_${properNodeId(name)} [${name}]\\n${edges}\\nend\\n${subgraphEdge}`;\n    }\n    describeGraph(ignoreSubgraphs = false) {\n        const result = this.edges.map((edge) => {\n            const mermEdge = describeEdge(edge, this.nodeMap, this.idPrefix);\n            const mermSubgraphs = ignoreSubgraphs\n                ? \"\"\n                : this.describeSubgraphs(edge, this.idPrefix);\n            return `${mermEdge}${mermSubgraphs}`;\n        });\n        const subgraphs = ignoreSubgraphs\n            ? \"\"\n            : Object.entries(this.subgraphs).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, undefined, undefined, `${name}${this.idPrefix}`));\n        return [...result, ...subgraphs].join(\"\\n\");\n    }\n}\nexport const toMermaid = (graph, direction = \"TD\", unstyled = false, ignoreSubgraphs = false) => {\n    const generator = new MermaidGenerator(graph);\n    const edges = generator.describeGraph(ignoreSubgraphs);\n    return unstyled\n        ? unstyledTemplate(edges, direction)\n        : template(edges, direction);\n};\n//# sourceMappingURL=mermaid.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const getSchemaType = (value) => {\n    if (value === null || value === undefined) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"array\";\n    }\n    return typeof value;\n};\nexport class SchemaBuilder {\n    additionalProperties = false;\n    required = [];\n    properties = {};\n    build() {\n        const result = {\n            type: \"object\",\n            properties: this.properties,\n            additionalProperties: this.additionalProperties,\n        };\n        if (this.required.length > 0) {\n            result.required = this.required;\n        }\n        return result;\n    }\n    setAdditionalProperties(additionalProperties) {\n        if (additionalProperties !== undefined) {\n            this.additionalProperties = additionalProperties;\n        }\n        return this;\n    }\n    addInputs(inputs) {\n        if (!inputs)\n            return this;\n        Object.entries(inputs).forEach(([name, value]) => {\n            this.addProperty(name, { type: getSchemaType(value) });\n        });\n        return this;\n    }\n    addProperty(name, schema) {\n        this.properties[name] = schema;\n        return this;\n    }\n    addProperties(properties) {\n        Object.entries(properties).forEach(([name, schema]) => {\n            this.addProperty(name, schema);\n        });\n        return this;\n    }\n    addRequired(required) {\n        if (!required)\n            return this;\n        if (typeof required === \"string\") {\n            this.required = [...this.required, required];\n        }\n        else if (Array.isArray(required) && required.length > 0) {\n            this.required = [...this.required, ...required];\n        }\n        return this;\n    }\n    static empty(additionalProperties = false) {\n        return new SchemaBuilder()\n            .setAdditionalProperties(additionalProperties)\n            .build();\n    }\n}\n//# sourceMappingURL=schema.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { InputStageResult } from \"./run.js\";\nexport const createErrorMessage = (inputName, metadata = {}, required) => {\n    const boardTitle = metadata.title ?? metadata?.url;\n    const requiredText = required ? \"required \" : \"\";\n    return `Missing ${requiredText}input \"${inputName}\"${boardTitle ? ` for board \"${boardTitle}\".` : \".\"}`;\n};\nexport const bubbleUpInputsIfNeeded = async (metadata, context, descriptor, result) => {\n    // If we have no way to bubble up inputs, we just return and not\n    // enforce required inputs.\n    if (!context.requestInput)\n        return;\n    const outputs = (await result.outputsPromise) ?? {};\n    const reader = new InputSchemaReader(outputs, result.inputs);\n    result.outputsPromise = reader.read(createBubbleHandler(metadata, context, descriptor));\n};\nexport const createBubbleHandler = (metadata, context, descriptor) => {\n    return (async (name, schema, required) => {\n        if (required) {\n            throw new Error(createErrorMessage(name, metadata, required));\n        }\n        if (schema.default !== undefined) {\n            if (\"type\" in schema && schema.type !== \"string\") {\n                return JSON.parse(schema.default);\n            }\n            return schema.default;\n        }\n        const value = await context.requestInput?.(name, schema, descriptor);\n        if (value === undefined) {\n            throw new Error(createErrorMessage(name, metadata, required));\n        }\n        return value;\n    });\n};\nexport class InputSchemaReader {\n    #currentOutputs;\n    #inputs;\n    constructor(currentOutputs, inputs) {\n        this.#currentOutputs = currentOutputs;\n        this.#inputs = inputs;\n    }\n    async read(handler) {\n        if (!(\"schema\" in this.#inputs))\n            return this.#currentOutputs;\n        const schema = this.#inputs.schema;\n        if (!schema.properties)\n            return this.#currentOutputs;\n        const entries = Object.entries(schema.properties);\n        const newOutputs = {};\n        for (const [name, property] of entries) {\n            if (name in this.#currentOutputs) {\n                newOutputs[name] = this.#currentOutputs[name];\n                continue;\n            }\n            const required = schema.required?.includes(name) ?? false;\n            const value = await handler(name, property, required);\n            newOutputs[name] = value;\n        }\n        return {\n            ...this.#currentOutputs,\n            ...newOutputs,\n        };\n    }\n}\nexport class RequestedInputsManager {\n    #context;\n    #cache = new Map();\n    constructor(context) {\n        this.#context = context;\n    }\n    createHandler(next, result) {\n        return async (name, schema, node) => {\n            const cachedValue = this.#cache.get(name);\n            if (cachedValue !== undefined)\n                return cachedValue;\n            const descriptor = { id: node.id, type: node.type };\n            const requestInputResult = {\n                ...result,\n                descriptor,\n                inputs: {\n                    schema: { type: \"object\", properties: { [name]: schema } },\n                },\n            };\n            //console.log(\"requestInputResult\", requestInputResult);\n            await next(new InputStageResult(requestInputResult, undefined, -1));\n            const outputs = await requestInputResult.outputsPromise;\n            let value = outputs && outputs[name];\n            if (value === undefined) {\n                value = await this.#context.requestInput?.(name, schema, descriptor);\n            }\n            if (!schema.transient)\n                this.#cache.set(name, value);\n            return value;\n        };\n    }\n}\n//# sourceMappingURL=bubble.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// only here for historical purposes. Use asyncGen instead.\n// Remove this when we're sure we don't need it anymore.\nexport const asyncGenOld = (callback) => {\n    let proceedToNext;\n    let nextCalled;\n    let nextThrew;\n    const next = async (result) => {\n        nextCalled(result);\n        return new Promise((resolve) => {\n            proceedToNext = resolve;\n        });\n    };\n    return {\n        [Symbol.asyncIterator]() {\n            let waitForCallbackToCallNext;\n            let done = false;\n            const resolver = (resolve, reject) => {\n                nextCalled = resolve;\n                nextThrew = reject;\n            };\n            waitForCallbackToCallNext = new Promise(resolver);\n            proceedToNext = () => {\n                callback(next)\n                    .then(() => {\n                    done = true;\n                    nextCalled(undefined);\n                })\n                    .catch((err) => {\n                    nextThrew(err);\n                });\n            };\n            return {\n                async next() {\n                    proceedToNext && proceedToNext();\n                    const value = await waitForCallbackToCallNext;\n                    waitForCallbackToCallNext = new Promise(resolver);\n                    return { done, value };\n                },\n            };\n        },\n    };\n};\nconst noop = () => {\n    /* noop */\n};\nclass AsyncGenQueue {\n    #queue = [];\n    #wroteIntoQueue = noop;\n    #whenQueuedUp;\n    #lastReceipt;\n    abort = noop;\n    constructor() {\n        this.#setQueuePromise();\n    }\n    #setQueuePromise() {\n        this.#whenQueuedUp = new Promise((resolve, reject) => {\n            this.#wroteIntoQueue = resolve;\n            this.abort = reject;\n        });\n    }\n    #addToQueue(entry) {\n        this.#queue.push(entry);\n        if (this.#queue.length == 1) {\n            this.#wroteIntoQueue();\n            this.#setQueuePromise();\n        }\n    }\n    async write(value) {\n        return new Promise((receipt) => {\n            this.#addToQueue({ value, receipt });\n        });\n    }\n    async read() {\n        this.#lastReceipt && this.#lastReceipt();\n        if (this.#queue.length === 0) {\n            await this.#whenQueuedUp;\n        }\n        const entry = this.#queue.shift();\n        if (!entry) {\n            throw new Error(\"asyncGen queue should never be empty.\");\n        }\n        this.#lastReceipt = entry.receipt;\n        if (!entry.value) {\n            return { done: true, value: undefined };\n        }\n        return { done: false, value: entry.value };\n    }\n    close() {\n        this.#addToQueue({ value: undefined, receipt: noop });\n    }\n}\nclass AsyncGenIterator {\n    #callback;\n    #firstTime = true;\n    #queue = new AsyncGenQueue();\n    constructor(callback) {\n        this.#callback = callback;\n    }\n    /**\n     * Called by the callback to advance to the next value.\n     * Roughly equivalent to \"yield\":\n     * ```ts\n     * yield value;\n     * ```\n     * same as\n     * ```ts\n     * await next(value);\n     * ```\n     * @param value\n     */\n    async #next(value) {\n        return this.#queue.write(value);\n    }\n    async next() {\n        if (this.#firstTime) {\n            this.#firstTime = false;\n            this.#callback(this.#next.bind(this))\n                .then(() => {\n                this.#queue.close();\n            })\n                .catch((err) => {\n                this.#queue.abort(err);\n            });\n        }\n        return this.#queue.read();\n    }\n}\n/**\n * Converts async/await style code into an async generator.\n * Useful when you need to combine arrow-style functions and yield.\n *\n * Example:\n *\n * ```ts\n * async function* foo() {\n *   yield 1;\n *   yield* asyncGen(async (next) => {\n *     await next(2);\n *     await next(3);\n *   });\n *   yield 4;\n * }\n *\n * for await (const val of foo()) {\n *   console.log(val);\n * }\n * ```\n *\n * This code will print:\n *\n * ```\n * 1\n * 2\n * 3\n * 4\n * ```\n *\n * @param callback A callback that will be called with a `next` function.\n * The callback should call `next` with the next value to yield.\n * @returns An async generator.\n */\nexport const asyncGen = (callback) => {\n    return {\n        [Symbol.asyncIterator]() {\n            return new AsyncGenIterator(callback);\n        },\n    };\n};\n//# sourceMappingURL=async-gen.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { loadRunnerState, saveRunnerState } from \"./serialization.js\";\n// TODO: Support stream serialization somehow.\n// see https://github.com/breadboard-ai/breadboard/issues/423\nexport class StackManager {\n    #stack;\n    #result;\n    constructor(stack) {\n        this.#stack = structuredClone(stack) || [];\n    }\n    onGraphStart() {\n        this.#stack.push({ graph: 0, node: 0 });\n    }\n    onNodeStart(result) {\n        this.#stack[this.#stack.length - 1].node++;\n        this.#result = result;\n    }\n    onNodeEnd() {\n        // TODO: implement\n    }\n    onGraphEnd() {\n        // TODO: implement\n    }\n    async state() {\n        // Assemble the stack from existing pieces.\n        const stack = structuredClone(this.#stack);\n        if (this.#result) {\n            stack[stack.length - 1].state = await saveRunnerState(\"nodestart\", this.#result);\n        }\n        return stack;\n    }\n}\nexport const traversalResultFromStack = (stack) => {\n    const { state } = stack[stack.length - 1];\n    return state ? loadRunnerState(state).state : undefined;\n};\n//# sourceMappingURL=stack.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachine } from \"./traversal/machine.js\";\nimport { InputStageResult, OutputStageResult } from \"./run.js\";\nimport { BoardLoader } from \"./loader.js\";\nimport { runRemote } from \"./remote.js\";\nimport { callHandler, handlersFromKits } from \"./handler.js\";\nimport { toMermaid } from \"./mermaid.js\";\nimport { SchemaBuilder } from \"./schema.js\";\nimport { RequestedInputsManager, bubbleUpInputsIfNeeded } from \"./bubble.js\";\nimport { asyncGen } from \"./utils/async-gen.js\";\nimport { StackManager } from \"./stack.js\";\nimport { timestamp } from \"./timestamp.js\";\nimport breadboardSchema from \"@google-labs/breadboard-schema/breadboard.schema.json\" assert { type: \"json\" };\n/**\n * This class is the main entry point for running a board.\n *\n * It contains everything that is needed to run a board, either loaded from a\n * serialized board or created via the {Board} class.\n *\n * See the {Board} class for a way to build a board that can also be serialized.\n */\nexport class BoardRunner {\n    // GraphDescriptor implementation.\n    url;\n    title;\n    description;\n    $schema;\n    version;\n    edges = [];\n    nodes = [];\n    kits = [];\n    graphs;\n    args;\n    #slots = {};\n    #validators = [];\n    /**\n     * The parent board, if this is board is a subgraph of a larger board.\n     */\n    #outerGraph;\n    /**\n     *\n     * @param metadata - optional metadata for the board. Use this parameter\n     * to provide title, description, version, and URL for the board.\n     */\n    constructor({ url, title, description, version, $schema } = {\n        $schema: breadboardSchema.$id,\n    }) {\n        Object.assign(this, {\n            $schema: $schema ?? breadboardSchema.$id,\n            url,\n            title,\n            description,\n            version,\n        });\n    }\n    /**\n     * Runs the board. This method is an async generator that\n     * yields the results of each stage of the run.\n     *\n     * Conceptually, when we ask the board to run, it will occasionally pause\n     * and give us a chance to interact with it.\n     *\n     * It's typically used like this:\n     *\n     * ```js\n     * for await (const stop of board.run()) {\n     * // do something with `stop`\n     * }\n     * ```\n     *\n     * The `stop` iterator result will be a `RunResult` and provide ability\n     * to influence running of the board.\n     *\n     * The two key use cases are providing input and receiving output.\n     *\n     * If `stop.type` is `input`, the board is waiting for input values.\n     * When that is the case, use `stop.inputs` to provide input values.\n     *\n     * If `stop.type` is `output`, the board is providing output values.\n     * When that is the case, use `stop.outputs` to receive output values.\n     *\n     * See [Chapter 8: Continuous runs](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-8-continuous-runs) of Breadboard tutorial for an example of how to use this method.\n     *\n     * @param probe - an optional probe. If provided, the board will dispatch\n     * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.\n     * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.\n     * @param result - an optional result of a previous run. If provided, the\n     * board will resume from the state of the previous run.\n     * @param kits - an optional map of kits to use when running the board.\n     */\n    async *run(context = {}, result) {\n        const base = context.base || new URL(this.url || \"\", import.meta.url);\n        yield* asyncGen(async (next) => {\n            const { probe } = context;\n            const handlers = await BoardRunner.handlersFromBoard(this, context.kits);\n            const slots = { ...this.#slots, ...context.slots };\n            this.#validators.forEach((validator) => validator.addGraph(this));\n            const machine = new TraversalMachine(this, result?.state);\n            const requestedInputs = new RequestedInputsManager(context);\n            const invocationPath = context.invocationPath || [];\n            const stack = new StackManager(context.state);\n            await probe?.report?.({\n                type: \"graphstart\",\n                data: { metadata: this, path: invocationPath, timestamp: timestamp() },\n            });\n            let invocationId = 0;\n            stack.onGraphStart();\n            const path = () => [...invocationPath, invocationId];\n            for await (const result of machine) {\n                invocationId++;\n                const { inputs, descriptor, missingInputs } = result;\n                if (result.skip) {\n                    await probe?.report?.({\n                        type: \"skip\",\n                        data: {\n                            node: descriptor,\n                            inputs,\n                            missingInputs,\n                            path: path(),\n                            timestamp: timestamp(),\n                        },\n                    });\n                    continue;\n                }\n                stack.onNodeStart(result);\n                await probe?.report?.({\n                    type: \"nodestart\",\n                    data: {\n                        node: descriptor,\n                        inputs,\n                        path: path(),\n                        timestamp: timestamp(),\n                    },\n                    state: await stack.state(),\n                });\n                let outputsPromise = undefined;\n                if (descriptor.type === \"input\") {\n                    await next(new InputStageResult(result, await stack.state(), invocationId));\n                    await bubbleUpInputsIfNeeded(this, context, descriptor, result);\n                    outputsPromise = result.outputsPromise;\n                }\n                else if (descriptor.type === \"output\") {\n                    await next(new OutputStageResult(result, invocationId));\n                    outputsPromise = result.outputsPromise;\n                }\n                else {\n                    const handler = handlers[descriptor.type];\n                    if (!handler)\n                        throw new Error(`No handler for node type \"${descriptor.type}\"`);\n                    const newContext = {\n                        ...context,\n                        board: this,\n                        descriptor,\n                        outerGraph: this.#outerGraph || this,\n                        base,\n                        slots,\n                        kits: [...(context.kits || []), ...this.kits],\n                        requestInput: requestedInputs.createHandler(next, result),\n                        invocationPath: path(),\n                        state: await stack.state(),\n                    };\n                    outputsPromise = callHandler(handler, inputs, newContext);\n                }\n                stack.onNodeEnd();\n                await probe?.report?.({\n                    type: \"nodeend\",\n                    data: {\n                        node: descriptor,\n                        inputs,\n                        outputs: (await outputsPromise),\n                        validatorMetadata: this.#validators.map((validator) => validator.getValidatorMetadata(descriptor)),\n                        path: path(),\n                        timestamp: timestamp(),\n                    },\n                });\n                result.outputsPromise = outputsPromise;\n            }\n            stack.onGraphEnd();\n            await probe?.report?.({\n                type: \"graphend\",\n                data: { metadata: this, path: invocationPath, timestamp: timestamp() },\n            });\n        });\n    }\n    get validators() {\n        return this.#validators;\n    }\n    /**\n     * A simplified version of `run` that runs the board until the board provides\n     * an output, and returns that output.\n     *\n     * This is useful for running boards that don't have multiple outputs\n     * or the the outputs are only expected to be visited once.\n     *\n     * @param inputs - the input values to provide to the board.\n     * @param probe - an optional probe. If provided, the board will dispatch\n     * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.\n     * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.\n     * @param kits - an optional map of kits to use when running the board.\n     * @returns - outputs provided by the board.\n     */\n    async runOnce(inputs, context = {}) {\n        const args = { ...inputs, ...this.args };\n        const { probe } = context;\n        if (context.board && context.descriptor) {\n            // If called from another node in a parent board, add the parent board's\n            // validators to the board, with the current arguments.\n            for (const validator of context.board.validators)\n                this.addValidator(validator.getSubgraphValidator(context.descriptor, Object.keys(args)));\n        }\n        try {\n            let outputs = {};\n            const path = context.invocationPath || [];\n            for await (const result of this.run(context)) {\n                if (result.type === \"input\") {\n                    // Pass the inputs to the board. If there are inputs bound to the\n                    // board (e.g. from a lambda node that had incoming wires), they will\n                    // overwrite supplied inputs.\n                    result.inputs = args;\n                }\n                else if (result.type === \"output\") {\n                    outputs = result.outputs;\n                    // Exit once we receive the first output.\n                    await probe?.report?.({\n                        type: \"nodeend\",\n                        data: {\n                            node: result.node,\n                            inputs: result.inputs,\n                            outputs,\n                            path: [...path, result.invocationId],\n                            timestamp: timestamp(),\n                        },\n                    });\n                    await probe?.report?.({\n                        type: \"graphend\",\n                        data: { metadata: this, path, timestamp: timestamp() },\n                    });\n                    break;\n                }\n            }\n            return outputs;\n        }\n        catch (e) {\n            // Unwrap unhandled error (handled errors are just outputs of the board!)\n            if (e.cause)\n                return { $error: e.cause };\n            else\n                throw e;\n        }\n    }\n    /**\n     * Add validator to the board.\n     * Will call .addGraph() on the validator before executing a graph.\n     *\n     * @param validator - a validator to add to the board.\n     */\n    addValidator(validator) {\n        this.#validators.push(validator);\n    }\n    /**\n     * Returns a [Mermaid](https://mermaid-js.github.io/mermaid/#/) representation\n     * of the board.\n     *\n     * This is useful for visualizing the board.\n     *\n     * @returns - a string containing the Mermaid representation of the board.\n     */\n    mermaid(direction = \"TD\", unstyled = false, ignoreSubgraphs = false) {\n        return toMermaid(this, direction, unstyled, ignoreSubgraphs);\n    }\n    /**\n     * Creates a new board from JSON. If you have a serialized board, you can\n     * use this method to turn it into into a new Board instance.\n     *\n     * @param graph - the JSON representation of the board.\n     * @returns - a new `Board` instance.\n     */\n    static async fromGraphDescriptor(graph) {\n        const breadboard = new BoardRunner(graph);\n        breadboard.edges = graph.edges;\n        breadboard.nodes = graph.nodes;\n        breadboard.graphs = graph.graphs;\n        breadboard.args = graph.args;\n        return breadboard;\n    }\n    /**\n     * Loads a board from a URL or a file path.\n     *\n     * @param url - the URL or a file path to the board.\n     * @param slots - optional slots to provide to the board.\n     * @returns - a new `Board` instance.\n     */\n    static async load(url, options) {\n        const { base, slotted, outerGraph } = options || {};\n        const loader = new BoardLoader({\n            base,\n            graphs: outerGraph?.graphs,\n        });\n        const { isSubgraph, graph } = await loader.load(url);\n        const board = await BoardRunner.fromGraphDescriptor(graph);\n        if (isSubgraph)\n            board.#outerGraph = outerGraph;\n        board.#slots = slotted || {};\n        return board;\n    }\n    /**\n     * Creates a runnable board from a BreadboardCapability,\n     * @param board {BreadboardCapability} A BreadboardCapability including a board\n     * @returns {Board} A runnable board.\n     */\n    static async fromBreadboardCapability(board) {\n        if (board.kind !== \"board\" || !board.board) {\n            throw new Error(`Expected a \"board\" Capability, but got ${board}`);\n        }\n        // TODO: Use JSON schema to validate rather than this hack.\n        const boardish = board.board;\n        if (!(boardish.edges && boardish.kits && boardish.nodes)) {\n            throw new Error('Supplied \"board\" Capability argument is not actually a board');\n        }\n        // If all we got is a GraphDescriptor, build a runnable board from it.\n        // TODO: Use JSON schema to validate rather than this hack.\n        let runnableBoard = board.board;\n        if (!runnableBoard.runOnce) {\n            runnableBoard = await BoardRunner.fromGraphDescriptor(boardish);\n        }\n        return runnableBoard;\n    }\n    static async handlersFromBoard(board, upstreamKits = []) {\n        const core = new Core();\n        const kits = [core, ...upstreamKits, ...board.kits];\n        return handlersFromKits(kits);\n    }\n    static runRemote = runRemote;\n}\n// HACK: Move the Core and Lambda logic into the same file as the BoardRunner to remove the cyclic module dependency (Lambda needs BoardRunner, BoardRunner needs Core).\nclass Core {\n    handlers;\n    constructor() {\n        this.handlers = {\n            lambda: {\n                describe: async (inputs) => ({\n                    inputSchema: new SchemaBuilder()\n                        .setAdditionalProperties(true)\n                        .addInputs(inputs)\n                        .addProperty(\"board\", {\n                        title: \"board\",\n                        description: \"The board to run.\",\n                        type: \"object\",\n                    })\n                        .build(),\n                    outputSchema: new SchemaBuilder()\n                        .addProperty(\"board\", {\n                        title: \"board\",\n                        description: \"The now-runnable board.\",\n                        type: \"object\",\n                    })\n                        .build(),\n                }),\n                invoke: async (inputs) => {\n                    const { board, ...args } = inputs;\n                    if (!board || board.kind !== \"board\" || !board.board)\n                        throw new Error(`Lambda node requires a BoardCapability as \"board\" input`);\n                    const runnableBoard = {\n                        ...(await BoardRunner.fromBreadboardCapability(board)),\n                        args,\n                    };\n                    return {\n                        board: { ...board, board: runnableBoard },\n                    };\n                },\n            },\n        };\n    }\n}\n//# sourceMappingURL=runner.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class IdVendor {\n    #map = new Map();\n    vendId(o, prefix) {\n        let count = this.#map.get(o) || 0;\n        count++;\n        this.#map.set(o, count);\n        return `${prefix}-${count}`;\n    }\n}\n//# sourceMappingURL=id.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { IdVendor } from \"./id.js\";\nconst specRegex = /^((?<a>.*)(?<dir><-|->))?(?<b>[^(.|?)]*)(?<q>\\.|\\?)?$/m;\n/**\n * Parses a given string according to the following grammar:\n * *|[{out}[->{in}][?|.]]\n * - if \"*\" is specified, this is all-value wiring. All available output values\n * will pass through this edge as input values.\n * - if \"out\" is not specified, this is an empty string, which means control-only\n * edge. No data passes through this edge.\n * - if \"in\" is not specified, \"in\" is assumed to be of the same value\n * as \"out\".\n * - if \"?\" is specified, this is an optional edge.\n * - if \".\" is specified, this is a constant edge.\n */\nexport const parseSpec = (spec) => {\n    const result = { ltr: true };\n    const match = spec.match(specRegex);\n    if (!match)\n        throw new Error(`Invalid edge spec: ${spec}`);\n    const { a, b, dir, q } = match?.groups;\n    const ltr = dir !== \"<-\";\n    result.ltr = ltr;\n    const optional = q === \"?\";\n    const constant = q === \".\";\n    result.edge = {};\n    if (constant)\n        result.edge.constant = true;\n    if (optional)\n        result.edge.optional = true;\n    if (!a && !b)\n        return result;\n    if (a === \"*\" || b === \"*\") {\n        result.edge.out = \"*\";\n        return result;\n    }\n    if (!a) {\n        result.edge.out = b;\n        result.edge.in = b;\n        return result;\n    }\n    if (!b) {\n        result.edge.out = a;\n        result.edge.in = a;\n        return result;\n    }\n    if (ltr) {\n        result.edge.out = a;\n        result.edge.in = b;\n    }\n    else {\n        result.edge.out = b;\n        result.edge.in = a;\n    }\n    return result;\n};\nconst nodeIdVendor = new IdVendor();\nexport const hasValues = (configuration) => {\n    return Object.values(configuration).length > 0;\n};\nexport class Node {\n    #descriptor;\n    #breadboard;\n    constructor(breadboard, kit, type, configuration, id) {\n        this.#breadboard = breadboard.currentBoardToAddTo();\n        this.#descriptor = {\n            id: id ?? nodeIdVendor.vendId(this.#breadboard, type),\n            type,\n        };\n        if (configuration && hasValues(configuration)) {\n            // For convenience we allow passing nodes as configuration, which are\n            // instead turned into constant incoming wires behind the scenes.\n            const incomingWiresToAdd = Object.entries(configuration).filter(([_, value]) => value instanceof Node);\n            for (const [wire, from] of incomingWiresToAdd) {\n                delete configuration[wire];\n                if (wire.indexOf(\"->\") !== -1)\n                    throw Error(\"Cannot pass output wire in confdig\");\n                this.wire(wire.indexOf(\"<-\") === -1 ? `${wire}<-.` : wire, from);\n            }\n            this.#descriptor.configuration = configuration;\n        }\n        if (kit?.url && !this.#breadboard.kits.find((k) => k.url === kit.url))\n            this.#breadboard.kits.push(kit);\n        this.#breadboard.addNode(this.#descriptor);\n    }\n    wire(spec, to) {\n        const { ltr, edge } = parseSpec(spec);\n        const [fromNode, toNode] = ltr\n            ? [this, to]\n            : [to, this];\n        const result = {\n            from: fromNode.#descriptor.id,\n            to: toNode.#descriptor.id,\n            ...edge,\n        };\n        if (fromNode.#breadboard !== toNode.#breadboard) {\n            // Note edge on the target board, which is the only currently supported\n            // version. Board.lambda() will use this to create a constant wire from\n            // the input node to this node, and from fromNode to the lambda node in\n            // the parent context, recursively if necessary.\n            toNode.#breadboard.addEdgeAcrossBoards(result, fromNode.#breadboard, toNode.#breadboard);\n        }\n        else {\n            this.#breadboard.addEdge(result);\n        }\n        return this;\n    }\n    get id() {\n        return this.#descriptor.id;\n    }\n}\n//# sourceMappingURL=node.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Node } from \"../node.js\";\n/**\n * Takes a kit constructor and creates a kit instance that can be used at\n * run-time.\n *\n * @param ctor Kit constructor\n * @returns A kit instance prepare for run-time use.\n */\nexport const asRuntimeKit = (ctor) => {\n    return new ctor({\n        create: () => {\n            throw Error(\"Node instantiation can't (yet) happen during runtime\");\n        },\n    });\n};\n/**\n * Takes a kit constructor and creates a kit instance that can be used at\n * compose-time (wiring the graph).\n * @param ctor Kit constructor\n * @param board The board with which the kit is associated.\n * @returns Kit instance prepared for compose-time use.\n */\nexport const asComposeTimeKit = (ctor, board) => {\n    return new ctor({\n        create: (...args) => {\n            return new Node(board, ...args);\n        },\n        getConfigWithLambda: (config) => {\n            return getConfigWithLambda(board, config);\n        },\n    });\n};\n/**\n * Synctactic sugar for node factories that accept lambdas. This allows passing\n * either\n *  - A JS function that is a lambda function defining the board\n *  - A board capability, i.e. the result of calling lambda()\n *  - A board node, which should be a node with a `board` output\n * or\n *  - A regular config, with a `board` property with any of the above.\n *\n * @param config {ConfigOrLambda} the overloaded config\n * @returns {NodeConfigurationConstructor} config with a board property\n */\nconst getConfigWithLambda = (board, config) => {\n    // Did we get a graph?\n    const gotGraph = config.nodes !== undefined &&\n        config.edges !== undefined &&\n        config.kits !== undefined;\n    // Look for functions, nodes and board capabilities.\n    const gotBoard = gotGraph ||\n        typeof config === \"function\" ||\n        config instanceof Node ||\n        (config.kind === \"board\" &&\n            config.board);\n    const result = (gotBoard\n        ? { board: gotGraph ? { kind: \"board\", board: config } : config }\n        : config);\n    // Convert passed JS function into a board node.\n    if (typeof result.board === \"function\")\n        result.board = board.lambda(result.board);\n    return result;\n};\n//# sourceMappingURL=ctors.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BoardRunner } from \"./runner.js\";\nimport { Node } from \"./node.js\";\nimport { asComposeTimeKit } from \"./kits/ctors.js\";\n/**\n * This is the heart of the Breadboard library.\n * Just like for hardware makers, the `Board` is the place where wiring of\n * a prototype happens.\n *\n * To start making, create a new breadboard:\n *\n * ```js\n * const board = new Board();\n * ```\n *\n * For more information on how to use Breadboard, start with [Chapter 1: Hello, world?](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the tutorial.\n */\nexport class Board extends BoardRunner {\n    #closureStack = [];\n    #topClosure;\n    #acrossBoardsEdges = [];\n    /**\n     * Core nodes. Breadboard won't function without these.\n     * These are always included.\n     */\n    /**\n     * Places an `input` node on the board.\n     *\n     * An `input` node is a node that asks for inputs from the user.\n     *\n     * See [`input` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#input) for more information.\n     *\n     * @param config - optional configuration for the node.\n     * @returns - a `Node` object that represents the placed node.\n     */\n    input(config = {}) {\n        const { $id, ...rest } = config;\n        return new Node(this, undefined, \"input\", { ...rest }, $id);\n    }\n    /**\n     * Places an `output` node on the board.\n     *\n     * An `output` node is a node that provides outputs to the user.\n     *\n     * See [`output` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#output) for more information.\n     *\n     * @param config - optional configuration for the node.\n     * @returns - a `Node` object that represents the placed node.\n     */\n    output(config = {}) {\n        const { $id, ...rest } = config;\n        return new Node(this, undefined, \"output\", { ...rest }, $id);\n    }\n    /**\n     * Place a `lambda` node on the board.\n     *\n     * It is a node that represents a subgraph of nodes. It can be passed to\n     * `invoke` or nodes like `map` (defined in another kit) that invoke boards.\n     *\n     * Input wires are made available as input values to the lambda board.\n     *\n     * `board` is the only output and represents a BoardCapability that invoke and\n     * others consume.\n     *\n     * You can either pass a `Board` or a Javascript function to this method. The\n     * JS function is called with a `board` to add things to, and for convenience,\n     * input and output nodes attached to the board.\n     *\n     * Example: board.lambda((board, input, output) => { input.wire( \"item->item\",\n     * kit.someNode().wire( \"value->value\", output));\n     * });\n     *\n     * @param boardOrFunction A board or a function that builds the board\n     * @param config - optional configuration for the node.\n     * @returns - a `Node` object that represents the placed node.\n     */\n    lambda(boardOrFunction, config = {}) {\n        const { $id, ...rest } = config;\n        let board;\n        let input;\n        if (typeof boardOrFunction === \"function\") {\n            board = new Board();\n            input = board.input();\n            const output = board.output();\n            board.#topClosure = this.#topClosure ?? this;\n            board.#topClosure.#closureStack.push(board);\n            boardOrFunction(board, input, output);\n            board.#topClosure.#closureStack.pop();\n        }\n        else {\n            board = boardOrFunction;\n        }\n        const node = new Node(this, undefined, \"lambda\", {\n            board: { kind: \"board\", board },\n            ...rest,\n        }, $id);\n        // Process edges that span lambdas. We have to turn this into two wires:\n        //  (1) From the input node in the child board to the destination node\n        //  (2) From the source node to this node. If the source node is in a\n        //      parent board, then instead ask parent to wire it up.\n        if (input && board.#acrossBoardsEdges.length > 0) {\n            for (const { edge, from, to } of board.#acrossBoardsEdges) {\n                if (to !== board || !edge.constant)\n                    throw new Error(\"Across board wires: Must be constant and from parent to child\");\n                // Hopefully unique enough name that doesn't class with other inputs\n                const label = `$l-${edge.to}-${edge.in}`;\n                board.addEdge({ ...edge, from: input.id, out: label });\n                const outerEdge = { ...edge, to: node.id, in: label };\n                if (from === this) {\n                    this.addEdge(outerEdge);\n                }\n                else {\n                    this.addEdgeAcrossBoards(outerEdge, from, this);\n                }\n            }\n            // Clear the edges, as they are now added to the board itself.\n            // TODO: Add code in .run() to verify that all edges are consumed.\n            board.#acrossBoardsEdges = [];\n        }\n        return node;\n    }\n    addEdge(edge) {\n        this.edges.push(edge);\n    }\n    addNode(node) {\n        this.nodes.push(node);\n    }\n    /**\n     * Adds a new kit to the board.\n     *\n     * Kits are collections of nodes that are bundled together for a specific\n     * purpose. For example, the [Core Kit](https://github.com/breadboard-ai/breadboard/tree/main/packages/core) provides a nodes that\n     * are useful for making boards.\n     *\n     * Typically, kits are distributed as NPM packages. To add a kit to the board,\n     * simply install it using `npm` or `yarn`, and then add it to the board:\n     *\n     * ```js\n     * import { Board } from \"@google-labs/breadboard\";\n     * import { Core } from \"@google-labs/core-kit\";\n     *\n     * const board = new Board();\n     * const kit = board.addKit(Core);\n     * ```\n     *\n     * @param ctr - the kit constructor.\n     * @returns - the kit object, which is associated with\n     * the board and can be used to place nodes on that board.\n     */\n    addKit(ctr) {\n        const kit = asComposeTimeKit(ctr, this);\n        this.kits.push(kit);\n        return kit;\n    }\n    /**\n     * Used in the context of board.lambda(): Returns the board that is currently\n     * being constructed, according to the nesting level of board.lambda() calls\n     * with JS functions.\n     *\n     * Only called by Node constructor, when adding nodes.\n     */\n    currentBoardToAddTo() {\n        const closureStack = this.#topClosure\n            ? this.#topClosure.#closureStack\n            : this.#closureStack;\n        if (closureStack.length === 0)\n            return this;\n        else\n            return closureStack[closureStack.length - 1];\n    }\n    /**\n     *\n     */\n    addEdgeAcrossBoards(edge, from, to) {\n        if (edge.out === \"*\")\n            throw new Error(\"Across board wires: * wires not supported\");\n        if (!edge.constant)\n            throw new Error(\"Across board wires: Must be constant for now\");\n        if (to !== this)\n            throw new Error(\"Across board wires: Must be invoked on to board\");\n        const closureStack = this.#topClosure\n            ? this.#topClosure.#closureStack\n            : this.#closureStack;\n        if (from !== this.#topClosure && !closureStack.includes(from))\n            throw new Error(\"Across board wires: From must be parent of to\");\n        this.#acrossBoardsEdges.push({ edge, from, to });\n    }\n}\n//# sourceMappingURL=board.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class InitServer {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async serve() {\n        const stream = this.#transport.createServerStream();\n        const reader = stream.readableRequests.getReader();\n        const request = await reader.read();\n        if (request.done) {\n            throw new Error(\"Client closed stream without sending a request.\");\n        }\n        return request.value.url;\n    }\n}\nexport class InitClient {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async load(url) {\n        const stream = this.#transport.createClientStream();\n        const writer = stream.writableRequests.getWriter();\n        await writer.write({ url });\n        await writer.close();\n    }\n}\n//# sourceMappingURL=init.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class Diagnostics extends EventTarget {\n    #callback;\n    constructor(callback) {\n        super();\n        this.#callback = callback;\n    }\n    async report(message) {\n        return this.#callback(message);\n    }\n}\n//# sourceMappingURL=diagnostics.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst STREAM_KIND = \"stream\";\nexport class StreamCapability {\n    kind = STREAM_KIND;\n    stream;\n    constructor(stream) {\n        this.stream = stream;\n    }\n}\nexport const clone = (streamCapability) => {\n    const [leave, take] = streamCapability.stream.tee();\n    streamCapability.stream = leave;\n    return take;\n};\nexport const isStreamCapability = (object) => {\n    const maybeStream = object;\n    return (maybeStream &&\n        maybeStream.kind &&\n        maybeStream.kind === STREAM_KIND &&\n        maybeStream.stream instanceof ReadableStream);\n};\n// TODO: Remove this once MessageController is gone.\nconst findStreams = (value, foundStreams) => {\n    if (Array.isArray(value)) {\n        value.forEach((item) => {\n            findStreams(item, foundStreams);\n        });\n    }\n    else if (typeof value === \"object\") {\n        if (value === null || value === undefined)\n            return;\n        const maybeCapability = value;\n        if (maybeCapability.kind && maybeCapability.kind === STREAM_KIND) {\n            foundStreams.push(maybeCapability.stream);\n        }\n        else {\n            Object.values(value).forEach((item) => {\n                findStreams(item, foundStreams);\n            });\n        }\n    }\n};\nexport const stringifyWithStreams = (value) => {\n    const foundStreams = [];\n    return {\n        value: JSON.stringify(value, (key, value) => {\n            if (isStreamCapability(value)) {\n                foundStreams.push(value.stream);\n                return { $type: \"Stream\", id: foundStreams.length - 1 };\n            }\n            return value;\n        }),\n        streams: foundStreams,\n    };\n};\nexport const parseWithStreams = (value, getStream) => {\n    const parsed = JSON.parse(value, (key, value) => {\n        if (typeof value === \"object\" && value !== null) {\n            if (value.$type === \"Stream\" && typeof value.id === \"number\") {\n                return new StreamCapability(getStream(value.id));\n            }\n        }\n        return value;\n    });\n    return parsed;\n};\nexport const getStreams = (value) => {\n    const foundStreams = [];\n    findStreams(value, foundStreams);\n    return foundStreams;\n};\n/**\n * Stubs out all streams in the input values with empty streams.\n * This is useful when we don't want the streams to be transferred.\n * @param data\n * @returns\n */\nexport const stubOutStreams = (data) => {\n    const stringified = stringifyWithStreams(data).value;\n    return parseWithStreams(stringified, () => new ReadableStream());\n};\nexport const portToStreams = (port) => {\n    const readable = new ReadableStream({\n        start(controller) {\n            port.onmessage = (ev) => {\n                if (ev.data === null) {\n                    controller.close();\n                    return;\n                }\n                controller.enqueue(ev.data);\n            };\n        },\n        cancel() {\n            port.onmessage = null;\n        },\n    });\n    const writable = new WritableStream({\n        write(chunk) {\n            const stringified = stringifyWithStreams(chunk);\n            port.postMessage(chunk, stringified.streams);\n        },\n        close() {\n            port.postMessage(null, []);\n        },\n    });\n    return {\n        readable,\n        writable,\n    };\n};\nexport const portFactoryToStreams = (portFactory) => {\n    let streams;\n    const streamsAvailable = new Promise((resolve) => {\n        portFactory().then((port) => {\n            streams = portToStreams(port);\n            resolve();\n        });\n    });\n    const readable = new ReadableStream({\n        async start() {\n            await streamsAvailable;\n        },\n        pull(controller) {\n            return streams.readable.pipeTo(new WritableStream({\n                write(chunk) {\n                    controller.enqueue(chunk);\n                },\n            }));\n        },\n        cancel() {\n            streams.readable.cancel();\n        },\n    });\n    const writable = new WritableStream({\n        async start() {\n            await streamsAvailable;\n        },\n        async write(chunk) {\n            const writer = streams.writable.getWriter();\n            await writer.write(chunk);\n            writer.releaseLock();\n        },\n        async close() {\n            await streams.writable.close();\n        },\n        async abort(reason) {\n            await streams.writable.abort(reason);\n        },\n    });\n    return {\n        readable,\n        writable,\n    };\n};\nexport class WritableResult {\n    #writer;\n    data;\n    constructor(value, writer) {\n        this.#writer = writer;\n        this.data = value;\n    }\n    async reply(chunk) {\n        await this.#writer.write(chunk);\n    }\n}\nclass StreamsAsyncIterator {\n    #reader;\n    #writer;\n    constructor(writable, readable) {\n        this.#reader = readable.getReader();\n        this.#writer = writable.getWriter();\n    }\n    async next() {\n        const { done, value } = await this.#reader.read();\n        if (done) {\n            this.#writer.close();\n            return { done, value: undefined };\n        }\n        return {\n            done: false,\n            value: new WritableResult(value, this.#writer),\n        };\n    }\n    async return() {\n        this.#writer.close();\n        return { done: true, value: undefined };\n    }\n    async throw(err) {\n        this.#writer.abort(err);\n        return { done: true, value: undefined };\n    }\n}\n/**\n * A helper to convert a pair of streams to an async iterable that follows\n * the following protocol:\n * - The async iterable yields a `WritableResult` object.\n * - The `WritableResult` object contains the data from the readable stream.\n * - The `WritableResult` object has a `reply` method that can be used to\n *   write a value as a reply to to data in the readable stream.\n *\n * This is particularly useful with bi-directional streams, when the two\n * streams are semantically connected to each other.\n *\n * @param writable The writable stream.\n * @param readable The readable stream.\n * @returns An async iterable.\n */\nexport const streamsToAsyncIterable = (writable, readable) => {\n    return {\n        async start(chunk) {\n            const writer = writable.getWriter();\n            await writer.write(chunk);\n            writer.releaseLock();\n        },\n        [Symbol.asyncIterator]() {\n            return new StreamsAsyncIterator(writable, readable);\n        },\n    };\n};\n// Polyfill to make ReadableStream async iterable\n// See https://bugs.chromium.org/p/chromium/issues/detail?id=929585\nexport const patchReadableStream = () => {\n    // eslint-disable-next-line\n    // @ts-ignore\n    ReadableStream.prototype[Symbol.asyncIterator] ||\n        // eslint-disable-next-line\n        // @ts-ignore\n        (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {\n            const reader = this.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done)\n                        return;\n                    yield value;\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        });\n};\n// A polyfill for ReadableStream.from:\n// See https://streams.spec.whatwg.org/#rs-from\n// TODO: Do a proper TypeScript types polyfill.\nexport const streamFromAsyncGen = (iterator) => {\n    return new ReadableStream({\n        async pull(controller) {\n            const { value, done } = await iterator.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(value);\n        },\n    });\n};\nexport const streamFromReader = (reader) => {\n    return new ReadableStream({\n        async pull(controller) {\n            const { value, done } = await reader.read();\n            if (done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(value);\n        },\n    }, { highWaterMark: 0 });\n};\nexport const streamFromWriter = (writer) => {\n    return new WritableStream({\n        async write(chunk) {\n            return writer.write(chunk);\n        },\n    }, { highWaterMark: 0 });\n};\n//# sourceMappingURL=stream.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Diagnostics } from \"../harness/diagnostics.js\";\nimport { RunResult } from \"../run.js\";\nimport { streamsToAsyncIterable, stubOutStreams, } from \"../stream.js\";\nimport { timestamp } from \"../timestamp.js\";\nconst resumeRun = (request) => {\n    const [type, , state] = request;\n    console.log(\"resumeRun\", type, state);\n    // There may not be any state to resume from.\n    if (!state)\n        return undefined;\n    if (state.length > 1) {\n        throw new Error(\"I don't yet know how to resume from nested subgraphs.\");\n    }\n    const result = RunResult.load(state[0].state);\n    if (type === \"input\") {\n        const [, inputs] = request;\n        result.inputs = inputs.inputs;\n    }\n    return result;\n};\nexport class RunServer {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async serve(runner, diagnostics = false, context = {}) {\n        const stream = this.#transport.createServerStream();\n        const requestReader = stream.readableRequests.getReader();\n        let request = await requestReader.read();\n        if (request.done)\n            return;\n        const result = resumeRun(request.value);\n        const responses = stream.writableResponses.getWriter();\n        const servingContext = {\n            ...context,\n            probe: diagnostics\n                ? new Diagnostics(async (message) => {\n                    const { type, data } = message;\n                    const response = [type, stubOutStreams(data)];\n                    if (type == \"nodestart\") {\n                        response.push(message.state);\n                    }\n                    await responses.write(response);\n                })\n                : undefined,\n        };\n        try {\n            for await (const stop of runner.run(servingContext, result)) {\n                if (stop.type === \"input\") {\n                    const state = stop.runState;\n                    const { node, inputArguments, timestamp } = stop;\n                    await responses.write([\n                        \"input\",\n                        { node, inputArguments, timestamp },\n                        state,\n                    ]);\n                    request = await requestReader.read();\n                    if (request.done) {\n                        await responses.close();\n                        return;\n                    }\n                    else {\n                        const [type, inputs] = request.value;\n                        if (type === \"input\") {\n                            stop.inputs = inputs.inputs;\n                        }\n                    }\n                }\n                else if (stop.type === \"output\") {\n                    const { node, outputs, timestamp } = stop;\n                    await responses.write([\"output\", { node, outputs, timestamp }]);\n                }\n            }\n            await responses.write([\"end\", { timestamp: timestamp() }]);\n            await responses.close();\n        }\n        catch (e) {\n            const error = e;\n            let message;\n            if (error?.cause) {\n                const { cause } = error;\n                message = cause;\n            }\n            else {\n                message = error.message;\n            }\n            console.error(\"Run Server error:\", message);\n            await responses.write([\n                \"error\",\n                { error: message, timestamp: timestamp() },\n            ]);\n            await responses.close();\n        }\n    }\n}\nconst createRunResult = (response) => {\n    const [type, data, state] = response.data;\n    const reply = async (chunk) => {\n        if (type !== \"input\") {\n            throw new Error(\"For now, we cannot reply to messages other than 'input'.\");\n        }\n        await response.reply([type, chunk, state]);\n    };\n    return {\n        type,\n        data,\n        state,\n        reply,\n    };\n};\nexport class RunClient {\n    #transport;\n    constructor(clientTransport) {\n        this.#transport = clientTransport;\n    }\n    async *run(state) {\n        const stream = this.#transport.createClientStream();\n        const server = streamsToAsyncIterable(stream.writableRequests, stream.readableResponses);\n        const request = [\"run\", {}];\n        state && request.push(state);\n        await server.start(request);\n        for await (const response of server) {\n            yield createRunResult(response);\n        }\n    }\n    async runOnce(inputs) {\n        let outputs;\n        for await (const stop of this.run()) {\n            const { type, data } = stop;\n            if (type === \"input\") {\n                stop.reply({ inputs });\n            }\n            else if (type === \"output\") {\n                outputs = data.outputs;\n                break;\n            }\n        }\n        return outputs || {};\n    }\n}\n//# sourceMappingURL=run.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { portFactoryToStreams, portToStreams, streamFromReader, streamFromWriter, } from \"../stream.js\";\nconst DISPATCHER_SEND = \"port-dispatcher-sendport\";\nexport class PortDispatcher {\n    #worker;\n    #waitForSender = new Map();\n    #pool = new Map();\n    constructor(worker) {\n        this.#worker = worker;\n        this.#worker.addEventListener(\"message\", (event) => {\n            const { type, id, port } = event.data;\n            if (type !== DISPATCHER_SEND)\n                return;\n            const waiting = this.#waitForSender.get(id);\n            if (waiting) {\n                waiting(port);\n                this.#waitForSender.delete(id);\n            }\n            else {\n                this.#pool.set(id, port);\n            }\n        });\n    }\n    receive(id) {\n        const pooledPort = this.#pool.get(id);\n        if (pooledPort) {\n            this.#pool.delete(id);\n            return portToStreams(pooledPort);\n        }\n        return portFactoryToStreams(() => {\n            return new Promise((resolve) => {\n                this.#waitForSender.set(id, resolve);\n            });\n        });\n    }\n    send(id) {\n        const { port1, port2 } = new MessageChannel();\n        this.#worker.postMessage({ type: DISPATCHER_SEND, id, port: port2 }, [\n            port2,\n        ]);\n        return portToStreams(port1);\n    }\n}\nexport class WorkerClientTransport {\n    #reader;\n    #writer;\n    constructor(streams) {\n        this.#reader = streams.readable.getReader();\n        this.#writer = streams.writable.getWriter();\n    }\n    createClientStream() {\n        return {\n            writableRequests: streamFromWriter(this.#writer),\n            readableResponses: streamFromReader(this.#reader),\n        };\n    }\n}\nexport class WorkerServerTransport {\n    #clientStreams;\n    constructor(streams) {\n        this.#clientStreams = streams;\n    }\n    createServerStream() {\n        return {\n            readableRequests: this.#clientStreams\n                .readable,\n            writableResponses: this.#clientStreams.writable,\n        };\n    }\n}\n//# sourceMappingURL=worker.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class KitBuilder {\n    url;\n    title;\n    description;\n    version;\n    namespacePrefix;\n    constructor({ title, description, version, url, namespacePrefix = \"\", }) {\n        this.url = url;\n        this.title = title;\n        this.description = description;\n        this.version = version;\n        this.namespacePrefix = namespacePrefix;\n    }\n    #addPrefix(handlers) {\n        return Object.keys(handlers).reduce((acc, key) => {\n            acc[`${this.namespacePrefix}${key}`] = handlers[key];\n            return acc;\n        }, {});\n    }\n    build(handlers) {\n        if (!this.url)\n            throw new Error(`Builder was not yet initialized.`);\n        const url = this.url;\n        const prefix = this.namespacePrefix;\n        const { title, description, version } = this;\n        const prefixedHandlers = this.#addPrefix(handlers);\n        const nodes = Object.keys(handlers);\n        return class {\n            title = title;\n            description = description;\n            version = version;\n            url = url;\n            get handlers() {\n                return prefixedHandlers;\n            }\n            constructor(nodeFactory) {\n                const proxy = new Proxy(this, {\n                    get(target, prop) {\n                        if (prop === \"handlers\" || prop === \"url\") {\n                            return target[prop];\n                        }\n                        else if (nodes.includes(prop)) {\n                            return (configOrLambda = {}) => {\n                                const config = nodeFactory.getConfigWithLambda(configOrLambda);\n                                const { $id, ...rest } = config;\n                                return nodeFactory.create(proxy, `${prefix}${prop}`, { ...rest }, $id);\n                            };\n                        }\n                    },\n                });\n                return proxy;\n            }\n        };\n    }\n    static wrap(params, functions) {\n        const createHandler = (previous, current) => {\n            const [name, fn] = current;\n            previous[name] = {\n                invoke: async (inputs) => {\n                    // JS can have rest args, eg. \"...args\" as a parameter at the end of a function, but breadboard cannot accept \".\" so we use \"___\".\n                    let argNames = [];\n                    if (fn && fn.length > 0) {\n                        argNames = fn.toString().match(/\\((.+?)\\)/)?.[1].split(\",\") ?? [];\n                        /*\n                        If fn.length is greater than 1 and argNames.length = 0, then we likely have a system function that accepts a splat of arguments..\n            \n                        e.g Math.max([1,2,3,4])\n            \n                        We need to special case this and pass the arguments as an array and expect `inputs` to have a key of `args` that is an array.\n                        */\n                        if (fn.length > 1 && argNames.length === 0 && \"___args\" in inputs && Array.isArray(inputs[\"___args\"])) {\n                            argNames = [\"___args\"];\n                        }\n                    }\n                    // Validate the input names.\n                    for (const argName of argNames) {\n                        if (argName.trim() in inputs === false) {\n                            throw new Error(`Missing input: ${argName.trim()}. Valid inputs are: ${Object.keys(inputs).join(\", \")}`);\n                        }\n                    }\n                    const args = argNames\n                        .filter(argName => argName.startsWith(\"___\") == false)\n                        .map((argName) => inputs[argName.trim()]);\n                    const lastArgName = argNames[argNames.length - 1];\n                    if (lastArgName != undefined && lastArgName.startsWith(\"___\")) {\n                        // Splat the rest of the arguments.\n                        args.push(...inputs[lastArgName]);\n                    }\n                    const results = await fn(...args);\n                    if (typeof results !== \"object\" || Array.isArray(results)) {\n                        // Number, Boolean, Array, String, will output to `result`.\n                        return { result: results };\n                    }\n                    // Objects will destructured into the output.\n                    return { ...results };\n                }\n            };\n            return previous;\n        };\n        const handlers = Object.entries(functions).reduce(createHandler, {});\n        const builder = new KitBuilder(params);\n        return builder.build(handlers);\n    }\n}\n//# sourceMappingURL=builder.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { callHandler } from \"../handler.js\";\n/**\n * Polyfill for atob and btoa.\n */\nexport const atob = globalThis.process\n    ? (str) => Buffer.from(str, \"base64\").toString(\"binary\")\n    : globalThis.atob;\nexport const btoa = globalThis.process\n    ? (str) => Buffer.from(str, \"binary\").toString(\"base64\")\n    : globalThis.btoa;\nconst TUNNEL_VALUE_SEPARATOR = \"~\";\nexport class NodeTunnel {\n    outputName;\n    from;\n    to;\n    when;\n    constructor(outputName, from, to, when = {}) {\n        this.outputName = outputName;\n        this.from = from;\n        this.to = to;\n        this.when = when;\n    }\n    getInputNames() {\n        const inputNames = Object.keys(this.when);\n        return inputNames.length === 0 ? [this.outputName] : inputNames;\n    }\n    matches(inputs) {\n        return Object.entries(this.when).every(([inputName, value]) => {\n            const inputValue = inputs[inputName];\n            if (typeof value === \"string\") {\n                return inputValue === value;\n            }\n            else {\n                if (typeof inputValue !== \"string\")\n                    return false;\n                return value.test(inputValue);\n            }\n        });\n    }\n}\nexport const readConfig = (config) => {\n    if (!config.proxy)\n        return {};\n    return Object.fromEntries(config.proxy\n        .map((spec) => {\n        if (typeof spec === \"string\") {\n            return undefined;\n        }\n        if (!spec.tunnel)\n            return undefined;\n        return [spec.node, readNodeSpec(spec.node, spec.tunnel)];\n    })\n        .filter(Boolean));\n};\nexport const readNodeSpec = (node, spec) => {\n    return Object.fromEntries(Object.entries(spec).map(([outputName, value]) => {\n        if (typeof value === \"string\") {\n            return [outputName, [new NodeTunnel(outputName, node, value)]];\n        }\n        else if (Array.isArray(value)) {\n            return [\n                outputName,\n                value.map((v) => {\n                    if (typeof v === \"string\") {\n                        return new NodeTunnel(outputName, node, v);\n                    }\n                    return new NodeTunnel(outputName, node, v.to, v.when);\n                }),\n            ];\n        }\n        else {\n            return [\n                outputName,\n                [new NodeTunnel(outputName, node, value.to, value.when)],\n            ];\n        }\n    }));\n};\nexport const replaceOutputs = (outputs, tunnels, replacer) => {\n    if (!outputs)\n        return;\n    return Object.fromEntries(Object.entries(outputs).map(([outputName, value]) => {\n        return outputName in tunnels\n            ? [outputName, replacer(outputName, value)]\n            : [outputName, value];\n    }));\n};\nexport const replaceInputs = async (inputs, tunnels, replacer) => {\n    // Decide if we should allow or block values for this node.\n    const allow = tunnels.some((tunnel) => tunnel.matches(inputs));\n    return Object.fromEntries(await Promise.all(Object.entries(inputs).map(async ([inputName, value]) => {\n        return [inputName, await replacer(value, allow)];\n    })));\n};\n// Compute a simple hash that expires every 7 days.\n// The point of this hash is not protect anything, but rather to have\n// a simple way to identify a tunnelled value.\n// It is also rotating so that the users of the node proxy don't accidentally\n// adopt bad practices of hard-coding the values.\n// Note: the rotation will occasionaly cause errors at the break of the week.\n// TODO: Fix the rotation to be window-based or come up with an even better\n// solution.\nconst MILLISECONDS_IN_A_WEEK = 1000 * 60 * 60 * 24 * 7;\nconst TUNNEL_HASH = Math.round(Date.now() / MILLISECONDS_IN_A_WEEK).toString(36);\nconst TUNNEL_PREFIX = `T-${TUNNEL_HASH}-`;\nconst TUNNEL_SUFFIX = `-${TUNNEL_HASH}-T`;\nconst SPLIT_REGEX = new RegExp(`(${TUNNEL_PREFIX}.*?${TUNNEL_SUFFIX})`, \"gm\");\nconst TUNNEL_REGEX = new RegExp(`^${TUNNEL_PREFIX}(.+?)${TUNNEL_SUFFIX}$`);\nconst BLOCKED_TUNNEL_VALUE = \"VALUE_BLOCKED\";\nexport const getTunnelValue = (nodeType, outputName, inputs) => {\n    const memoize = btoa(JSON.stringify(inputs)).replace(\"=\", \"\");\n    return `${TUNNEL_PREFIX}${nodeType}${TUNNEL_VALUE_SEPARATOR}${outputName}${TUNNEL_VALUE_SEPARATOR}${memoize}${TUNNEL_SUFFIX}`;\n};\nexport const scanTunnelValue = (value) => {\n    const parts = value.split(SPLIT_REGEX).filter(Boolean);\n    return parts.map((part) => {\n        const match = part.match(TUNNEL_REGEX);\n        if (match) {\n            // This is a tunnel value, parse it into components and return\n            // a helper object that enables the caller to replace the value.\n            const value = match[1].split(TUNNEL_VALUE_SEPARATOR);\n            const [nodeType, outputName, encodedInputs] = value;\n            const inputs = atob(encodedInputs);\n            return {\n                nodeType,\n                outputName,\n                inputs,\n            };\n        }\n        else {\n            // This is a regular substring, return a helper object that handles\n            // joining it back together as a string.\n            return {\n                value: part,\n            };\n        }\n    });\n};\nexport const replaceTunnelledInputs = async (input, \n/**\n * If true, the tunneled inputs will be replaced with the original value.\n * If false, the tunneled inputs should be blocked. The tunnel value\n * is replaced with a BLOCKED_TUNNEL_VALUE.\n */\nallow, replacer) => {\n    const json = JSON.stringify(input);\n    const parts = scanTunnelValue(json);\n    const result = await Promise.all(parts.map(async (part) => {\n        if (\"inputs\" in part) {\n            const inputs = JSON.parse(part.inputs);\n            const { nodeType, outputName } = part;\n            const outputs = allow\n                ? await replacer(nodeType, inputs)\n                : { [outputName]: BLOCKED_TUNNEL_VALUE };\n            if (!outputs)\n                return \"\";\n            let jsonString = JSON.stringify(outputs[outputName]);\n            if (jsonString.startsWith('\"')) {\n                jsonString = jsonString.slice(1, -1);\n            }\n            jsonString = JSON.stringify(jsonString);\n            return jsonString.slice(1, -1);\n        }\n        return part.value;\n    }));\n    return JSON.parse(result.join(\"\"));\n};\nexport const createDestinationMap = (map) => {\n    // pivot the map of tunnel entries to create a map of tunnel destinations\n    const entries = Object.entries(map).flatMap(([_, nodeTunnels]) => {\n        return Object.entries(nodeTunnels).flatMap(([_, tunnels]) => {\n            return tunnels.map((tunnel) => {\n                return [tunnel.to, tunnel];\n            });\n        });\n    });\n    // collate entries by destination node\n    return entries.reduce((acc, [to, tunnel]) => {\n        if (!acc[to])\n            acc[to] = [];\n        acc[to].push(tunnel);\n        return acc;\n    }, {});\n};\n/**\n * A special kit that provides tunneling of outputs and inputs as specified\n * by the Tunnels spec.\n *\n * This kit is constructed from existing NodeHandlers and the Tunnels spec.\n * It reads the spec and wraps the node handlers to add the tunneling logic.\n *\n * The tunnel entries, or the outputs of nodes that are tunneled, are replaced\n * with a special value that is computed from the node type and the output name.\n *\n * The tunnel destinations, or the inputs of the nodes to which a tunnel leads, are\n * replaced with the original value of the tunnel entry.\n */\nexport const createTunnelKit = (map, handlers) => {\n    // wrap handlers to tunnel outputs (tunnel entries)\n    const outputWrappedHandlers = Object.fromEntries(Object.entries(handlers).map(([nodeType, handler]) => {\n        const nodeTunnels = map[nodeType];\n        if (!nodeTunnels)\n            return [nodeType, handler];\n        return [\n            nodeType,\n            async (inputs, context) => {\n                const outputs = await callHandler(handler, inputs, context);\n                return replaceOutputs(outputs, nodeTunnels, (name) => getTunnelValue(nodeType, name, inputs));\n            },\n        ];\n    }));\n    // wrap handlers to connect the tunnel to the inputs (tunnel destinations)\n    const destinations = createDestinationMap(map);\n    const inputWrappedHandlers = Object.fromEntries(Object.entries(outputWrappedHandlers).map(([nodeType, handler]) => {\n        const destinationTunnels = destinations[nodeType];\n        if (!destinationTunnels)\n            return [nodeType, handler];\n        return [\n            nodeType,\n            async (inputs, context) => {\n                return callHandler(handler, await replaceInputs(inputs, destinationTunnels, async (value, allow) => {\n                    // scan for tunneled values in `value`.\n                    // for each found `tunnel value`,\n                    // - extract the node type and output name of the tunnel entry.\n                    // - call the handler of the node type for the tunnel entry\n                    //   with the inputs that are decoded from the tunnel value\n                    // - from the outputs, extract the inputs that are tunneled\n                    //   and replace the `tunnel value` with them.\n                    return replaceTunnelledInputs(value, allow, async (nodeType, inputs) => {\n                        return callHandler(handlers[nodeType], inputs, context);\n                    });\n                }), context);\n            },\n        ];\n    }));\n    return {\n        url: \"tunnel-kit\",\n        handlers: inputWrappedHandlers,\n    };\n};\n//# sourceMappingURL=tunnel.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { callHandler, handlersFromKits } from \"../handler.js\";\nimport { streamsToAsyncIterable } from \"../stream.js\";\nimport { asRuntimeKit } from \"../kits/ctors.js\";\nimport { KitBuilder } from \"../kits/builder.js\";\nimport { createTunnelKit, readConfig } from \"./tunnel.js\";\nimport { timestamp } from \"../timestamp.js\";\nconst getHandlerConfig = (type, config = []) => {\n    const handlerConfig = config.find((arg) => {\n        if (typeof arg === \"string\")\n            return arg === type;\n        else\n            return arg.node === type;\n    });\n    if (typeof handlerConfig === \"string\") {\n        return {\n            node: handlerConfig,\n        };\n    }\n    return handlerConfig;\n};\nexport class ProxyServer {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async serve(config) {\n        const { kits } = config;\n        const stream = this.#transport.createServerStream();\n        const tunnelKit = createTunnelKit(readConfig(config), handlersFromKits(kits));\n        const handlers = tunnelKit.handlers;\n        for await (const request of streamsToAsyncIterable(stream.writableResponses, stream.readableRequests)) {\n            const [type] = request.data;\n            if (type === \"end\") {\n                break;\n            }\n            if (type !== \"proxy\") {\n                request.reply([\n                    \"error\",\n                    { error: \"Expected proxy request.\", timestamp: timestamp() },\n                ]);\n                continue;\n            }\n            const [, { node, inputs }] = request.data;\n            const handlerConfig = getHandlerConfig(node.type, config.proxy);\n            const handler = handlerConfig ? handlers[node.type] : undefined;\n            if (!handler) {\n                request.reply([\n                    \"error\",\n                    {\n                        error: \"Can't proxy a node of this node type.\",\n                        timestamp: timestamp(),\n                    },\n                ]);\n                continue;\n            }\n            try {\n                const result = await callHandler(handler, inputs, {\n                    descriptor: node,\n                });\n                if (!result) {\n                    request.reply([\n                        \"error\",\n                        { error: \"Handler returned nothing.\", timestamp: timestamp() },\n                    ]);\n                    continue;\n                }\n                request.reply([\"proxy\", { outputs: result }]);\n            }\n            catch (e) {\n                request.reply([\n                    \"error\",\n                    { error: e.message, timestamp: timestamp() },\n                ]);\n            }\n        }\n    }\n}\nexport class ProxyClient {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    shutdownServer() {\n        const stream = this.#transport.createClientStream();\n        const writer = stream.writableRequests.getWriter();\n        writer.write([\"end\", { timestamp: timestamp() }]);\n        writer.close();\n    }\n    async proxy(node, inputs) {\n        const stream = this.#transport.createClientStream();\n        const writer = stream.writableRequests.getWriter();\n        const reader = stream.readableResponses.getReader();\n        writer.write([\"proxy\", { node, inputs }]);\n        writer.close();\n        const result = await reader.read();\n        if (result.done)\n            throw new Error(\"Unexpected proxy failure: empty response.\");\n        const [type] = result.value;\n        if (type === \"proxy\") {\n            const [, { outputs }] = result.value;\n            return outputs;\n        }\n        else if (type === \"error\") {\n            const [, { error }] = result.value;\n            throw new Error(JSON.stringify(error));\n        }\n        else {\n            throw new Error(`Unexpected proxy failure: unknown response type \"${type}\".`);\n        }\n    }\n    createProxyKit(args = []) {\n        const nodesToProxy = args.map((arg) => {\n            if (typeof arg === \"string\")\n                return arg;\n            else\n                return arg.node;\n        });\n        const proxiedNodes = Object.fromEntries(nodesToProxy.map((type) => {\n            return [\n                type,\n                {\n                    invoke: async (inputs, context) => {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        const descriptor = context.descriptor;\n                        const result = await this.proxy(descriptor, inputs);\n                        return result;\n                    },\n                },\n            ];\n        }));\n        return asRuntimeKit(new KitBuilder({ url: \"proxy\" }).build(proxiedNodes));\n    }\n}\n//# sourceMappingURL=proxy.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { ProxyClient } from \"../remote/proxy.js\";\nconst isProxyKitConfig = (kitOrConfig) => {\n    return \"proxy\" in kitOrConfig;\n};\nexport const configureKits = (kits, factory) => {\n    return kits.map((kit) => {\n        if (isProxyKitConfig(kit)) {\n            const proxyClient = new ProxyClient(factory.client(\"proxy\"));\n            return proxyClient.createProxyKit(kit.proxy);\n        }\n        return kit;\n    });\n};\n//# sourceMappingURL=kits.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const baseURL = (config) => {\n    if (config.base)\n        return config.base;\n    if (\"window\" in self)\n        return new URL(self.location.href);\n    return new URL(import.meta.url);\n};\n//# sourceMappingURL=url.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Board } from \"../board.js\";\nimport { InitServer } from \"../remote/init.js\";\nimport { RunServer } from \"../remote/run.js\";\nimport { PortDispatcher, WorkerClientTransport, WorkerServerTransport, } from \"../remote/worker.js\";\nimport { configureKits } from \"./kits.js\";\nimport { baseURL } from \"./url.js\";\nconst isInWorker = () => {\n    return (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    typeof WorkerGlobalScope !== \"undefined\" &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        self instanceof WorkerGlobalScope);\n};\nconst maybeCreateWorker = () => {\n    throw new Error(\"Not implemented\");\n};\nclass WorkerTransportFactory {\n    #dispatcher;\n    constructor(dispatcher) {\n        this.#dispatcher = dispatcher;\n    }\n    client(label) {\n        return new WorkerClientTransport(this.#dispatcher.send(label));\n    }\n    server(label) {\n        return new WorkerServerTransport(this.#dispatcher.receive(label));\n    }\n}\nconst getBoardURL = async (config, factory) => {\n    const url = config.url;\n    if (url)\n        return url;\n    const initServer = new InitServer(factory.server(\"load\"));\n    return await initServer.serve();\n};\n/**\n * Start the Breadboard run server. Currently, this function is somewhat\n * specialized to the worker transport, but (one hopes) will eventually\n * grow up to be more general and flexible.\n * @param config - The configuration for the server.\n * @returns - a promise that resolves when the server is done serving.\n */\nexport const serve = async (config) => {\n    if (config.transport !== \"worker\") {\n        throw new Error(\"Only worker transport is supported at this time.\");\n    }\n    const inWorker = isInWorker();\n    const worker = inWorker ? self : maybeCreateWorker();\n    const factory = new WorkerTransportFactory(new PortDispatcher(worker));\n    const kits = configureKits(config.kits, factory);\n    // TODO: Figure out how to initalize.\n    const isRunServer = true;\n    if (!isRunServer)\n        return;\n    const server = new RunServer(factory.server(\"run\"));\n    const url = await getBoardURL(config, factory);\n    const base = baseURL(config);\n    const runner = await Board.load(url, { base });\n    return server.serve(runner, !!config.diagnostics, { kits });\n};\n/**\n * A helper function to define a serve configuration. Especially useful in\n * TypeScript, where the type of the configuration is inferred from the\n * argument.\n * @param config - The configuration for the server.\n * @returns - The configuration for the server.\n */\nexport const defineServeConfig = (config) => {\n    return config;\n};\n//# sourceMappingURL=serve.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class AbstractNode {\n}\n//# sourceMappingURL=types.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AbstractNode, } from \"./types.js\";\nimport { IdVendor } from \"../../id.js\";\nconst nodeIdVendor = new IdVendor();\n// TODO:BASE Extract base class that isn't opinionated about the syntax. Marking\n// methods that should be base as \"TODO:BASE\" below, including complications.\nexport class BaseNode extends AbstractNode {\n    id;\n    type;\n    outgoing = [];\n    incoming = [];\n    configuration = {};\n    #handler;\n    #scope;\n    constructor(handler, scope, config = {}) {\n        super();\n        this.#scope = scope;\n        if (typeof handler === \"string\") {\n            this.type = handler;\n        }\n        else {\n            this.type = \"fn\";\n            this.#handler = handler;\n        }\n        const { $id, ...rest } = config;\n        this.id = $id ?? nodeIdVendor.vendId(scope, this.type);\n        this.configuration = rest;\n    }\n    addIncomingEdge(from, out, in_, constant, schema) {\n        if (from.#scope !== this.#scope)\n            throw new Error(\"Can't connect nodes from different scopes\");\n        const edge = {\n            to: this,\n            from: from,\n            out,\n            in: in_,\n            schema,\n        };\n        if (constant)\n            edge.constant = true;\n        this.incoming.push(edge);\n        from.outgoing.push(edge);\n    }\n    #getHandlerDescribe(scope) {\n        const handler = this.#handler ?? scope.getHandler(this.type);\n        return handler && typeof handler !== \"function\"\n            ? handler.describe\n            : undefined;\n    }\n    // In the end, we need to capture the outputs and resolve the promise. But\n    // before that there is a bit of refactoring to do to allow returning of\n    // graphs, parallel execution, etc.\n    //\n    // The logic from BuilderNode.invoke should be somehow called from here, for\n    // deserialized nodes that require the Builder environment.\n    async invoke(inputs, dynamicScope) {\n        const scope = dynamicScope ?? this.#scope;\n        const handler = this.#handler ?? scope.getHandler(this.type);\n        let result;\n        const handlerFn = typeof handler === \"function\" ? handler : handler?.invoke;\n        if (handlerFn) {\n            result = (await handlerFn(inputs, this));\n        }\n        else if (handler && typeof handler !== \"function\" && handler.graph) {\n            // TODO: This isn't quite right, but good enough for now. Instead what\n            // this should be in invoking a graph from a lexical scope in a dynamic\n            // scope. This requires moving state management into the dyanmic scope.\n            const graphs = handler.graph.getPinnedNodes();\n            if (graphs.length !== 1)\n                throw new Error(\"Expected exactly one graph\");\n            result = (await scope.invokeOneRound(inputs, graphs[0]));\n        }\n        else {\n            throw new Error(`Can't find handler for ${this.id}`);\n        }\n        return result;\n    }\n    async describe(scope = this.#scope, inputs, inputSchema, outputSchema) {\n        const describe = this.#getHandlerDescribe(scope);\n        return describe\n            ? await describe(inputs, inputSchema, outputSchema)\n            : undefined;\n    }\n    async serialize(metadata) {\n        return this.#scope.serialize(metadata, this);\n    }\n    async serializeNode() {\n        const node = {\n            id: this.id,\n            type: this.type,\n            configuration: this.configuration,\n        };\n        return [node];\n    }\n}\n//# sourceMappingURL=node.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO: To support parallelism, we need to track which nodes are still pending\nexport class State {\n    queue = [];\n    inputs = new Map();\n    constants = new Map();\n    controlWires = new Map();\n    haveRun = new Set();\n    queueUp(node) {\n        if (!this.queue.includes(node))\n            this.queue.push(node);\n    }\n    next() {\n        if (!this.queue.length)\n            throw new Error(\"No nodes in queue\");\n        return this.queue.shift();\n    }\n    done() {\n        return this.queue.length === 0;\n    }\n    /**\n     * Compute required inputs from edges and compare with present inputs\n     *\n     * Required inputs are\n     *  - for all named incoming edges, the presence of any data, irrespective of\n     *    which node they come from\n     *  - at least one of the incoming empty or * wires, if present (TODO: Is that\n     *    correct?)\n     *  - data from at least one node if it already ran\n     *\n     * @returns false if none are missing, otherwise string[] of missing inputs.\n     * NOTE: A node with no incoming wires returns an empty array after  first\n     * run.\n     */\n    missingInputs(node) {\n        if (node.incoming.length === 0 && this.haveRun.has(node))\n            return [];\n        const requiredKeys = new Set(node.incoming.map((edge) => edge.in));\n        const presentKeys = new Set([\n            ...Object.keys(node.configuration),\n            ...Object.keys(this.constants.get(node) ?? {}),\n        ]);\n        for (const [port, values] of (this.inputs.get(node) ?? new Map()).entries())\n            if (values.length)\n                presentKeys.add(port);\n        if (this.controlWires.get(node)?.length)\n            presentKeys.add(\"\");\n        const missingInputs = [...requiredKeys].filter((key) => !presentKeys.has(key));\n        return missingInputs.length ? missingInputs : false;\n    }\n    shiftInputs(node) {\n        const inputs = { ...node.configuration, ...this.constants.get(node) };\n        // Shift inputs from queues\n        const queues = this.inputs.get(node) ?? new Map();\n        for (const [port, values] of queues.entries())\n            if (values.length > 0)\n                inputs[port] = values.shift();\n        // Mark as run, reset control wires\n        this.haveRun.add(node);\n        this.controlWires.delete(node);\n        return inputs;\n    }\n    processResult(node, result) {\n        const distribution = { nodes: [], unused: [] };\n        const unusedPorts = new Set(Object.keys(result));\n        for (const edge of node.outgoing) {\n            const ports = this.distributeResults(edge, result);\n            ports.forEach((key) => unusedPorts.delete(key));\n            // If it's ready to run, add it to the queue\n            const missing = this.missingInputs(edge.to);\n            if (!missing)\n                this.queueUp(edge.to);\n            distribution.nodes.push({ node: edge.to, received: ports, missing });\n        }\n        distribution.unused = [...unusedPorts];\n        return distribution;\n    }\n    distributeResults(edge, inputs) {\n        const data = edge.out === \"*\"\n            ? inputs\n            : edge.out === \"\"\n                ? {}\n                : inputs[edge.out] !== undefined\n                    ? { [edge.in]: inputs[edge.out] }\n                    : {};\n        // Update constants; pverwrite current values if present\n        if (edge.constant)\n            this.constants.set(edge.to, { ...this.constants.get(edge.to), ...data });\n        // Regular inputs: Add to the input queues\n        if (!this.inputs.has(edge.to))\n            this.inputs.set(edge.to, new Map());\n        const queues = this.inputs.get(edge.to);\n        for (const port of Object.keys(data)) {\n            if (!queues?.has(port))\n                queues?.set(port, []);\n            queues?.get(port)?.push(data[port]);\n        }\n        if (edge.in === \"\")\n            this.controlWires.set(edge.to, [\n                ...(this.controlWires.get(edge.to) ?? []),\n                edge.from,\n            ]);\n        // return which wires were used\n        return Object.keys(data);\n    }\n}\n//# sourceMappingURL=state.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { State } from \"./state.js\";\nconst buildRequiredPropertyList = (properties) => {\n    return Object.entries(properties)\n        .map(([key, value]) => {\n        const mayHaveOptional = value;\n        if (mayHaveOptional.$optional) {\n            delete mayHaveOptional.$optional;\n            return undefined;\n        }\n        return key;\n    })\n        .filter(Boolean);\n};\nexport class Scope {\n    parentLexicalScope;\n    parentDynamicScope;\n    #handlers = {};\n    #pinnedNodes = [];\n    #callbacks = [];\n    constructor(config = {}) {\n        this.parentLexicalScope = config.lexicalScope;\n        this.parentDynamicScope = config.dynamicScope;\n    }\n    addHandlers(handlers) {\n        Object.entries(handlers).forEach(([name, handler]) => (this.#handlers[name] = handler));\n    }\n    getHandler(name) {\n        return (this.#handlers[name] ||\n            this.parentDynamicScope?.getHandler(name) ||\n            this.parentLexicalScope?.getHandler(name));\n    }\n    pin(node) {\n        this.#pinnedNodes.push(node);\n    }\n    compactPins() {\n        const visited = new Set();\n        const disjointPins = [];\n        for (const node of this.#pinnedNodes) {\n            if (visited.has(node))\n                continue;\n            disjointPins.push(node);\n            const connected = this.#findAllConnectedNodes(node);\n            connected.forEach((node) => visited.add(node));\n        }\n        this.#pinnedNodes = disjointPins;\n    }\n    getPinnedNodes() {\n        return this.#pinnedNodes;\n    }\n    addCallbacks(callbacks) {\n        this.#callbacks.push(callbacks);\n    }\n    #getAllCallbacks() {\n        // Callbacks are called in reverse order that they are added. Important for\n        // the `before` callback, which can override execution with output values.\n        // So while all are called, the last one added that returns something other\n        // than undefined gets precedence.\n        return [\n            ...this.#callbacks,\n            ...(this.parentDynamicScope\n                ? this.parentDynamicScope.#getAllCallbacks()\n                : []),\n        ];\n    }\n    async invoke(node, state = new State()) {\n        try {\n            if (node !== false)\n                (node ? (node instanceof Array ? node : [node]) : this.#pinnedNodes)\n                    .flatMap((node) => this.#findAllConnectedNodes(node).filter((node) => state?.missingInputs(node) === false))\n                    .forEach((node) => state?.queueUp(node));\n            const callbacks = this.#getAllCallbacks();\n            while (!state.done()) {\n                for (const callback of callbacks)\n                    if (await callback.stop?.(this, state))\n                        return;\n                const node = state.next();\n                const inputs = state.shiftInputs(node);\n                let callbackResult = undefined;\n                for (const callback of callbacks)\n                    callbackResult ??= await callback.before?.(this, node, inputs);\n                // Invoke node, unless before callback already provided a result.\n                const result = callbackResult ??\n                    (await node.invoke(inputs, this).catch((e) => {\n                        return {\n                            $error: {\n                                type: \"error\",\n                                error: e,\n                            },\n                        };\n                    }));\n                // Distribute data to outgoing edges, queue up nodes that are ready to\n                const distribution = state.processResult(node, result);\n                // Call after callback\n                for (const callback of callbacks) {\n                    await callback.after?.(this, node, inputs, result, distribution);\n                }\n                // Abort graph on uncaught errors.\n                if (distribution.unused.includes(\"$error\")) {\n                    throw result[\"$error\"].error;\n                }\n            }\n        }\n        finally {\n            // Call done callback\n            // Note: Only callbacks added to this scope specifically are called\n            for (const callback of this.#callbacks) {\n                await callback.done?.();\n            }\n        }\n    }\n    invokeOneRound(inputs = {}, node = undefined, state) {\n        if (\"$state\" in inputs) {\n            state = inputs[\"$state\"];\n            delete inputs[\"$state\"];\n        }\n        let resolver = undefined;\n        const promise = new Promise((resolve) => {\n            resolver = resolve;\n        });\n        const scope = new Scope({ dynamicScope: this });\n        scope.addHandlers({\n            input: async () => {\n                return inputs;\n            },\n            output: async (inputs) => {\n                resolver?.(await inputs);\n                resolver = undefined;\n                return inputs;\n            },\n        });\n        let lastNode = undefined;\n        const lastMissingInputs = new Map();\n        let stopState = undefined;\n        scope.addCallbacks({\n            stop: (_scope, state) => {\n                // Once output node was executed, stop execution.\n                if (!resolver)\n                    stopState = state;\n                return !resolver;\n            },\n            after: (_scope, node, _inputs, _outputs, distribution) => {\n                // Remember debug information to make the error below more useful.\n                lastNode = node;\n                for (const { node, missing } of distribution.nodes) {\n                    if (missing) {\n                        lastMissingInputs.set(node.id, missing.join(\", \"));\n                    }\n                    else {\n                        lastMissingInputs.delete(node.id);\n                    }\n                }\n            },\n            done: () => {\n                // Make sure we don't wait forever if execution terminates without\n                // reaching an output node.\n                resolver?.({\n                    $error: {\n                        type: \"error\",\n                        error: new Error(`Output node never reach. Last node was ${lastNode?.id}.\\n\\nThese nodes had inputs missing:\\n${Array.from(lastMissingInputs, ([id, missing]) => `  ${id}: ${missing}`).join(\"\\n\")}`),\n                    },\n                });\n            },\n        });\n        const runner = scope.invoke(node !== undefined ? node : this.#pinnedNodes, state);\n        // Wait for both, return output values, and last state if stopped.\n        return Promise.all([promise, runner]).then(([outputs]) => ({\n            ...outputs,\n            ...(stopState ? { $state: stopState } : {}),\n        }));\n    }\n    async serialize(metadata, node) {\n        const queue = (node ? [node] : this.#pinnedNodes).flatMap((node) => this.#findAllConnectedNodes(node));\n        const graphs = {};\n        const nodes = await Promise.all(queue.map(async (node) => {\n            const [nodeDescriptor, subGraph] = await node.serializeNode();\n            // Save subgraphs returned, typically for `invoke` nodes that call\n            // serialized graphs or functions.\n            if (subGraph)\n                graphs[nodeDescriptor.id] = subGraph;\n            // If `input` or `output` nodes don't have a schema, derive it from\n            // their wires, calling the respective nodes' describe method.\n            if ((nodeDescriptor.type === \"input\" ||\n                nodeDescriptor.type === \"output\") &&\n                !nodeDescriptor.configuration?.schema) {\n                const schema = await this.#addMissingSchemas(node);\n                if (Object.entries(schema.properties ?? {}).length > 0)\n                    nodeDescriptor.configuration = {\n                        ...nodeDescriptor.configuration,\n                        schema,\n                    };\n            }\n            return nodeDescriptor;\n        }));\n        const edges = queue.flatMap((node) => node.outgoing.map((edge) => ({\n            from: edge.from.id,\n            to: edge.to.id,\n            out: edge.out,\n            in: edge.in,\n            ...(edge.constant ? { constant: true } : {}),\n        })));\n        return { ...metadata, edges, nodes, graphs };\n    }\n    #findAllConnectedNodes(node) {\n        const nodes = new Set();\n        const queue = [node];\n        while (queue.length) {\n            const node = queue.shift();\n            if (nodes.has(node))\n                continue;\n            nodes.add(node);\n            node.incoming.forEach((edge) => queue.push(edge.from));\n            node.outgoing.forEach((edge) => queue.push(edge.to));\n        }\n        return [...nodes];\n    }\n    async #getSchemasForNode(node) {\n        const incomingPorts = Object.fromEntries(node.incoming\n            .filter((edge) => edge.out !== \"\" && edge.out !== \"*\")\n            .map((edge) => [edge.out, edge.schema ?? {}]));\n        const outgoingPorts = Object.fromEntries(node.outgoing\n            .filter((edge) => edge.out !== \"\" && edge.out !== \"*\")\n            .map((edge) => [edge.out, edge.schema ?? {}]));\n        return await node.describe(this, node.configuration, { properties: incomingPorts }, { properties: outgoingPorts });\n    }\n    async #addMissingSchemas(node) {\n        const properties = {};\n        const ports = new Set();\n        if (node.type === \"input\") {\n            const nodes = new Set();\n            // Find all nodes downstream of this input node, note all ports\n            for (const edge of node.outgoing)\n                if (edge.out !== \"*\" && edge.out !== \"\") {\n                    nodes.add(edge.to);\n                    ports.add(edge.out);\n                    if (edge.schema)\n                        properties[edge.out] = edge.schema;\n                }\n            // For each node, get the schema and copy over the ports we care about\n            for (const toNode of nodes) {\n                const schema = await this.#getSchemasForNode(toNode);\n                const schemaPorts = schema?.inputSchema?.properties;\n                if (schemaPorts)\n                    for (const edge of toNode.incoming)\n                        if (edge.from === node && schemaPorts[edge.in])\n                            properties[edge.out] = {\n                                ...schemaPorts[edge.in],\n                                ...properties[edge.out],\n                            };\n            }\n        }\n        else if (node.type === \"output\") {\n            const nodes = new Set();\n            // Find all nodes upstream of this output node, note all ports\n            for (const edge of node.incoming)\n                if (edge.out !== \"*\" && edge.out !== \"\") {\n                    nodes.add(edge.from);\n                    ports.add(edge.in);\n                    if (edge.schema)\n                        properties[edge.in] = edge.schema;\n                }\n            // For each node, get the schema and copy over the ports we care about\n            for (const fromNode of nodes) {\n                const schema = await this.#getSchemasForNode(fromNode);\n                const schemaPorts = schema?.outputSchema?.properties;\n                if (schemaPorts)\n                    for (const edge of fromNode.outgoing)\n                        if (edge.to === node && schemaPorts[edge.out])\n                            properties[edge.in] = {\n                                ...schemaPorts[edge.out],\n                                ...properties[edge.in],\n                            };\n            }\n        }\n        else {\n            throw new Error(\"Can't yet derive schema for non-input/output nodes\");\n        }\n        for (const port of ports) {\n            if (!properties[port]) {\n                properties[port] = { type: \"string\", title: port };\n            }\n            else {\n                properties[port].type ||= \"string\";\n                properties[port].title ||= port;\n            }\n        }\n        const required = buildRequiredPropertyList(properties);\n        return { type: \"object\", properties, required };\n    }\n}\n//# sourceMappingURL=scope.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BuilderScope } from \"./scope.js\";\n/**\n * The following is inspired by zone.js, but much simpler, and crucially doesn't\n * require monkey patching.\n *\n * Instead, we use a global variable to store the current scope, and swap it\n * out when we need to run a function in a different context.\n *\n * Scope.asScopeFor() wraps a function that runs with that Scope as context.\n *\n * action and any nodeFactory will run with the current Scope as context. That\n * is, they remember the Scope that was active when they were created.\n *\n * Crucially (and that's all we need from zone.js), {NodeImpl,Value}.then() call\n * onsuccessful and onrejected with the Scope as context. So even if the\n * context changed in the meantime, due to async calls, the rest of a flow\n * defining function will run with the current Scope as context.\n *\n * This works because NodeImpl and Value are PromiseLike, and so their then() is\n * called when they are awaited. Importantly, there is no context switch between\n * then() and the onsuccessful or onrejected call, if called from a Promise\n * then(), including a Promise.resolve().then (This makes it robust in case the\n * containing function isn't immediately awaited and so possibly Promises are\n * being scheduled). However, there is a context switch between the await and\n * the then() call, and so the context might have changed. That's why we\n * remember the scope on the node object.\n *\n * One requirement from this that there can't be any await in the body of a flow\n * or action function, if they are followed by either node creation or flow\n * calls. This is also a requirement for restoring state after interrupting a\n * flow.\n */\nlet currentContextScope = undefined;\nexport function getCurrentContextScope() {\n    // Initialize on first use.\n    if (!currentContextScope)\n        currentContextScope = new BuilderScope();\n    return currentContextScope;\n}\nexport function swapCurrentContextScope(scope) {\n    const oldScope = getCurrentContextScope();\n    currentContextScope = scope;\n    return oldScope;\n}\n//# sourceMappingURL=default-scope.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Scope } from \"../runner/scope.js\";\nimport { swapCurrentContextScope } from \"./default-scope.js\";\n/**\n * Adds syntactic sugar to support unproxying and serialization of nodes/graphs.\n */\nexport class BuilderScope extends Scope {\n    #isSerializing;\n    #closureEdges = [];\n    parentLambdaNode;\n    // TODO:BASE, config of subclasses can have more fields\n    constructor(config = {}) {\n        super(config);\n        this.#isSerializing = config.serialize ?? false;\n        this.parentLambdaNode = config.parentLambda;\n    }\n    async serialize(metadata, node) {\n        return super.serialize(metadata, node && typeof node.unProxy === \"function\"\n            ? node.unProxy()\n            : node);\n    }\n    serializing() {\n        return this.#isSerializing;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    asScopeFor(fn) {\n        return ((...args) => {\n            const oldScope = swapCurrentContextScope(this);\n            try {\n                return fn(...args);\n            }\n            finally {\n                swapCurrentContextScope(oldScope);\n            }\n        });\n    }\n    addClosureEdge(edge) {\n        this.#closureEdges.push(edge);\n    }\n    getClosureEdges() {\n        return this.#closureEdges;\n    }\n}\n//# sourceMappingURL=scope.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class AbstractValue {\n}\n//# sourceMappingURL=types.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AbstractValue, } from \"./types.js\";\nimport { BuilderNode, isBuilderNodeProxy } from \"./node.js\";\n// Because Value is sometimes behind a function Proxy (see NodeImpl's methods),\n// we need to use this approach to identify Value instead instanceof.\nexport const IsValueSymbol = Symbol(\"IsValue\");\nexport function isValue(obj) {\n    return ((typeof obj === \"object\" || typeof obj === \"function\") &&\n        obj[IsValueSymbol] !== undefined);\n}\nexport class Value extends AbstractValue {\n    #node;\n    #scope;\n    #keymap;\n    #constant;\n    #schema;\n    constructor(node, scope, keymap, constant = false, schema = {}) {\n        super();\n        this.#node = node;\n        this.#scope = scope;\n        this.#keymap = typeof keymap === \"string\" ? { [keymap]: keymap } : keymap;\n        this[IsValueSymbol] = this;\n        this.#constant = constant;\n        this.#schema = schema;\n    }\n    then(onfulfilled, onrejected) {\n        if (Object.keys(this.#keymap).length !== 1)\n            throw Error(\"Can't `await` for multiple values\");\n        return this.#node.then((o) => o &&\n            onfulfilled &&\n            this.#scope.asScopeFor(onfulfilled)(o[Object.keys(this.#keymap)[0]]), onrejected && this.#scope.asScopeFor(onrejected));\n    }\n    asNodeInput() {\n        return [this.#node.unProxy(), this.#keymap, this.#constant, this.#schema];\n    }\n    to(to, config) {\n        const toNode = isBuilderNodeProxy(to)\n            ? to.unProxy()\n            : new BuilderNode(to, this.#scope, config);\n        toNode.addInputsFromNode(this.#node, this.#keymap, this.#constant, this.#schema);\n        return toNode.asProxy();\n    }\n    // This doesn't do any type checking on the inputs.\n    //\n    // TODO: See whether that's somehow possible. The main problem is that\n    // node.<field> is typed for the outputs. We could add a new InputValue type\n    // and generate those from node.in().field so that the final syntax could be\n    // `toNode.toField.in(fromNode.in().fromField)`.\n    //\n    // That is, today .in() on a value returns void and in the future it would\n    // return that new InputValue type, typed with the right input value from the\n    // original node. To accomplish this, we'll have to keep passing the\n    // node input values type through the chain of values and .as() statements.\n    in(inputs) {\n        let invertedMap = Object.fromEntries(Object.entries(this.#keymap).map(([fromKey, toKey]) => [toKey, fromKey]));\n        if (isValue(inputs)) {\n            invertedMap = inputs.#remapKeys(invertedMap);\n            this.#node.addInputsFromNode(inputs.#node, invertedMap, inputs.#constant, inputs.#schema);\n        }\n        else if (isBuilderNodeProxy(inputs)) {\n            this.#node.addInputsFromNode(inputs.unProxy(), invertedMap);\n        }\n        else {\n            this.#node.addInputsAsValues(inputs);\n        }\n    }\n    as(newKey) {\n        let newMap;\n        if (typeof newKey === \"string\") {\n            if (Object.keys(this.#keymap).length !== 1)\n                throw new Error(\"Can't rename multiple values with a single string\");\n            newMap = { [Object.keys(this.#keymap)[0]]: newKey };\n        }\n        else {\n            newMap = this.#remapKeys(newKey);\n        }\n        return new Value(this.#node, this.#scope, newMap, this.#constant, this.#schema);\n    }\n    memoize() {\n        return new Value(this.#node, this.#scope, this.#keymap, true, this.#schema);\n    }\n    // Create a node for the lambda that is being sent as this value. At this\n    // point we can't verify that this actually is a BoardCapability, so we just\n    // do it and let the runtime throw an error if this wasn't one.\n    invoke(config) {\n        return new BuilderNode(\"invoke\", this.#scope, {\n            ...config,\n            $board: this,\n        }).asProxy();\n    }\n    /**\n     * The following are type-casting methods that are useful when a node type\n     * returns generic types but we want to narrow the types to what we know they\n     * are, e.g. a parser node returning the result as raw wires.\n     *\n     * This is also a way to define the schema of a board, e.g. by casting input\n     * wires and what is returned.\n     *\n     * Use as `foo.asString()` or `foo.asNumber()`. `isArray` and `isObject` cast\n     * to generic arrays and objects.\n     */\n    isUnknown() {\n        delete this.#schema.type;\n        return this;\n    }\n    isString() {\n        this.#schema.type = \"string\";\n        return this;\n    }\n    isNumber() {\n        this.#schema.type = \"number\";\n        return this;\n    }\n    isBoolean() {\n        this.#schema.type = \"boolean\";\n        return this;\n    }\n    isArray() {\n        this.#schema.type = \"array\";\n        return this;\n    }\n    isImage(mimeType = \"image/png\") {\n        this.#schema.type = mimeType;\n        return this;\n    }\n    isObject() {\n        this.#schema.type = \"object\";\n        return this;\n    }\n    title(title) {\n        this.#schema.title = title;\n        return this;\n    }\n    description(description) {\n        this.#schema.description = description;\n        return this;\n    }\n    format(format) {\n        this.#schema.format = format;\n        return this;\n    }\n    examples(...examples) {\n        this.#schema.examples = examples;\n        return this;\n    }\n    default(value) {\n        this.#schema.default = value;\n        return this;\n    }\n    optional() {\n        this.#schema.$optional = true;\n        return this;\n    }\n    transient() {\n        this.#schema.$optional = true;\n        return this;\n    }\n    #remapKeys(newKeys) {\n        const newMap = { ...this.#keymap };\n        Object.entries(newKeys).forEach(([fromKey, toKey]) => {\n            if (this.#keymap[toKey]) {\n                newMap[fromKey] = this.#keymap[toKey];\n                delete this.#keymap[toKey];\n            }\n            else {\n                newMap[fromKey] = toKey;\n            }\n        });\n        return newMap;\n    }\n}\n//# sourceMappingURL=value.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AbstractNode, } from \"../runner/types.js\";\nimport { BaseNode } from \"../runner/node.js\";\nimport { BuilderScope } from \"./scope.js\";\nimport { Value, isValue } from \"./value.js\";\nimport { isLambda } from \"./board.js\";\nexport class BuilderNode extends BaseNode {\n    #promise;\n    #resolve;\n    #reject;\n    #scope;\n    #handler;\n    constructor(handler, scope, config = {}) {\n        const $id = !isBuilderNodeProxy(config) &&\n            !(config instanceof AbstractNode) &&\n            !isLambda(config) &&\n            !isValue(config) &&\n            config.$id;\n        super(handler, scope, $id ? { $id } : {});\n        this.#scope = scope;\n        if (typeof handler !== \"string\")\n            this.#handler = handler;\n        if (isBuilderNodeProxy(config)) {\n            this.addInputsFromNode(config.unProxy());\n        }\n        else if (config instanceof AbstractNode) {\n            this.addInputsFromNode(config);\n        }\n        else if (isLambda(config)) {\n            this.addInputsAsValues({\n                $board: config.getBoardCapabilityAsValue(),\n            });\n        }\n        else if (isValue(config)) {\n            this.addInputsFromNode(...config.asNodeInput());\n        }\n        else {\n            if (config.$id !== undefined)\n                delete config[\"$id\"];\n            this.addInputsAsValues(config);\n        }\n        // Set up spread value, so that { ...node } as input works.\n        this[this.#spreadKey()] =\n            this;\n        this.#promise = new Promise((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n    }\n    addInputsAsValues(values) {\n        // Split into constants and nodes\n        const constants = {};\n        const nodes = [];\n        Object.entries(values).forEach(([key, value]) => {\n            // This turns something returned by board() into a BoardCapability, which\n            // is going to be either a Promise for a BoardCapability (assigned to\n            // constants below) or an AbstractValue to one.\n            if (isLambda(value))\n                value = value.getBoardCapabilityAsValue();\n            if (isValue(value)) {\n                nodes.push(value.as(key).asNodeInput());\n            }\n            else if (value instanceof AbstractNode || isBuilderNodeProxy(value)) {\n                nodes.push([\n                    isBuilderNodeProxy(value) ? value.unProxy() : value,\n                    { [key]: key },\n                    false,\n                    undefined, // Defers inference of schema from node to serialization\n                ]);\n            }\n            else {\n                constants[key] = value;\n            }\n        });\n        this.configuration = { ...this.configuration, ...constants };\n        nodes.forEach((node) => this.unProxy().addInputsFromNode(...node));\n    }\n    // Add inputs from another node as edges\n    addInputsFromNode(from, keymap = { \"*\": \"\" }, constant, schema) {\n        const keyPairs = Object.entries(keymap);\n        if (keyPairs.length === 0) {\n            // Add an empty edge: Just control flow, no data moving.\n            this.addIncomingEdge(from, \"\", \"\", constant);\n        }\n        else {\n            keyPairs.forEach(([fromKey, toKey]) => {\n                // \"*-<id>\" means \"all outputs from <id>\" and comes from using a node in\n                // a spread, e.g. newNode({ ...node, $id: \"id\" }\n                if (fromKey.startsWith(\"*-\")) {\n                    fromKey = \"*\";\n                    toKey = \"\";\n                }\n                this.unProxy().addIncomingEdge(isBuilderNodeProxy(from) ? from.unProxy() : from, fromKey, toKey, constant, schema);\n            });\n        }\n    }\n    addIncomingEdge(from, out, in_, constant, schema) {\n        const fromScope = from.#scope;\n        // If this is a reguar wire, call super method to add it\n        if (fromScope === this.#scope) {\n            super.addIncomingEdge(from, out, in_, constant, schema);\n            return;\n        }\n        // Validate that this is a wire from a parent scope\n        for (let scope = this.#scope; scope !== fromScope; scope = scope.parentLexicalScope)\n            if (!scope)\n                throw new Error(\"Only wires from parent scopes allowed\");\n        // Don't allow * or empty wires from parent scopes\n        if (out === \"*\" || out === \"\")\n            throw new Error(\"Can't use * or empty wires from parent scopes\");\n        // Save for board() to add to the graph later\n        this.#scope.addClosureEdge({\n            scope: fromScope,\n            from: from,\n            to: this,\n            out,\n            in: in_,\n        });\n    }\n    async invoke(inputs, dynamicScope) {\n        const scope = new BuilderScope({\n            dynamicScope,\n            lexicalScope: this.#scope,\n        });\n        return scope.asScopeFor(async () => {\n            try {\n                const handler = this.#handler ?? scope.getHandler(this.type);\n                let result;\n                // Note: The handler might actually return a graph (as a NodeProxy), and\n                // so the await might triggers its execution. This is what we want.\n                //\n                // Awaiting here means that parallel execution isn't possible.\n                // TODO: Return a promise that knows how to do the rest. Make sure to\n                // never invoke the handler twice while it is running, though.\n                //\n                // TODO: What this should do instead is much closer to what the\n                // serialization code below does. It should:\n                //  - add an input node, assign the inputs to it\n                //  - call the handler with that input node's proxy (this gives it all\n                //    the values, but as promises) if it supports promises, otherwise\n                //    call it with the values directly.\n                //  - if the handler returns a node (i.e. a graph), and\n                //    - it isn't an output node, add an output node and wire it up\n                //    - execute the graph, and return the output node's outputs\n                //  - otherwise return the handler's return value as result.\n                const handlerFn = typeof handler === \"function\" ? handler : handler?.invoke;\n                if (handlerFn) {\n                    result = (await handlerFn(inputs, this));\n                }\n                else if (handler && typeof handler !== \"function\" && handler.graph) {\n                    // TODO: This isn't quite right, but good enough for now. Instead what\n                    // this should be in invoking a graph from a lexical scope in a dynamic\n                    // scope. This requires moving state management into the dyanmic scope.\n                    const graphs = handler.graph.getPinnedNodes();\n                    if (graphs.length !== 1)\n                        throw new Error(\"Expected exactly one graph\");\n                    result = (await scope.invokeOneRound(inputs, graphs[0]));\n                }\n                else {\n                    throw new Error(`Can't find handler for ${this.id}`);\n                }\n                // Execute graphs returned by the handler as individual results (A full\n                // graph returned would have already been executed above)\n                //\n                // TODO: As a future feature, it would be nice to do this as deep\n                // traversal, so that developers can return complex structures composed\n                // of different responses. But only if we support this for regular nodes\n                // as well.\n                for (const [key, value] of Object.entries(result)) {\n                    if (value instanceof BuilderNode)\n                        result[key] = (await value)[key];\n                    else if (isValue(value))\n                        result[key] = (await value);\n                    else if (isLambda(value))\n                        result[key] =\n                            (await value.getBoardCapabilityAsValue());\n                }\n                // Resolve promise, but only on first run\n                if (this.#resolve) {\n                    this.#resolve(result);\n                    this.#resolve = this.#reject = undefined;\n                }\n                return result;\n            }\n            catch (e) {\n                // Reject promise, but only on first run\n                if (this.#reject) {\n                    this.#reject(e);\n                    this.#resolve = this.#reject = undefined;\n                }\n                throw e;\n            }\n        })();\n    }\n    // TODO:BASE Special casing the function case (which is most of the code\n    // here), everything else is the same, but really just the first few lines\n    // here.\n    async serializeNode() {\n        // HACK: See board.getClosureNode() and\n        // board.getBoardCapabilityAsValue() for why this is needed. There we\n        // create a node that has a board capability as input, but serializing the\n        // graph is async, while node creation isn't. So we wait until here to\n        // await the serialized BoardCapability. To fix: Make node factories a\n        // first class object, which should inherently move serializing the\n        // subgraph to here (and never serialize subgraphs if their parent graphs\n        // aren't serialized either).\n        for (const [key, value] of Object.entries(this.configuration))\n            if (value instanceof Promise)\n                this.configuration[key] =\n                    await value;\n        if (this.type !== \"fn\") {\n            return super.serializeNode();\n        }\n        const scope = new BuilderScope({\n            lexicalScope: this.#scope,\n            serialize: true,\n        });\n        const handler = this.#handler ?? scope.getHandler(this.type);\n        // If this is a graph node, save it as a subgraph (returned as second value)\n        // and turns this into an invoke node.\n        if (handler && typeof handler !== \"function\" && handler.graph) {\n            const node = {\n                id: this.id,\n                type: \"invoke\",\n                configuration: {\n                    ...this.configuration,\n                    path: \"#\" + this.id,\n                },\n            };\n            const graphs = handler.graph.getPinnedNodes();\n            if (graphs.length !== 1)\n                throw new Error(\"Expected exactly one graph\");\n            return [node, await scope.serialize({}, graphs[0])];\n        }\n        // Else, serialize the handler itself and return a runJavascript node.\n        const handlerFn = typeof handler === \"function\" ? handler : handler?.invoke;\n        if (!handlerFn)\n            throw new Error(`Handler for ${this.type} in ${this.id} not found`);\n        let code = handlerFn.toString();\n        let name = this.id.replace(/-/g, \"_\");\n        const arrowFunctionRegex = /(?:async\\s*)?(\\w+|\\([^)]*\\))\\s*=>\\s*/;\n        const traditionalFunctionRegex = /(?:async\\s+)?function\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*\\{/;\n        if (arrowFunctionRegex.test(code)) {\n            // It's an arrow function, convert to traditional\n            code = code.replace(arrowFunctionRegex, (_, params) => {\n                const async = code.trim().startsWith(\"async\") ? \"async \" : \"\";\n                const paramsWithParens = params.startsWith(\"(\")\n                    ? params\n                    : `(${params})`;\n                return `${async}function ${name}${paramsWithParens} `;\n            });\n        }\n        else {\n            const match = traditionalFunctionRegex.exec(code);\n            if (match === null)\n                throw new Error(\"Unexpected seralization: \" + code);\n            else\n                name = match[1] || name;\n        }\n        const schemas = await this.describe(scope);\n        const invokeGraph = {\n            edges: [\n                { from: `${this.id}-input`, to: `${this.id}-run`, out: \"*\" },\n                { from: `${this.id}-run`, to: `${this.id}-output`, out: \"*\" },\n            ],\n            nodes: [\n                {\n                    id: `${this.id}-input`,\n                    type: \"input\",\n                    configuration: schemas?.inputSchema\n                        ? { schema: schemas.inputSchema }\n                        : {},\n                },\n                {\n                    id: `${this.id}-run`,\n                    type: \"runJavascript\",\n                    configuration: {\n                        ...this.configuration,\n                        code,\n                        name,\n                        raw: true,\n                    },\n                },\n                {\n                    id: `${this.id}-output`,\n                    type: \"output\",\n                    configuration: schemas?.outputSchema\n                        ? { schema: schemas.outputSchema }\n                        : {},\n                },\n            ],\n        };\n        const node = {\n            id: this.id,\n            type: \"invoke\",\n            configuration: { path: \"#\" + this.id },\n        };\n        return [node, invokeGraph];\n    }\n    /**\n     * Creates a proxy for a Node that is used when constructing a graph.\n     *\n     *   const node = originalNode.asProxy();\n     *\n     * It acts as a Promise for the Node's output by implementing a `then` method:\n     *   const output = await node;\n     *\n     * It acts a proxy for Promises for the Node's output's members.\n     *   const field = await node.field;\n     *\n     * You can still call methods on the Node:\n     *   node.to(nextNode);\n     *\n     * You can do that on output members too:\n     *   node.field.to(nextNode);\n     *\n     * This even works for its methods and `then` and other reserved words:\n     *   const to = await node.to;\n     *   const thenValue = await node.then; // note: not then()\n     *   node.then.to(nextNode); // send the value of `then` to nextNode\n     *   node.to.to(nextNode);   // same for the value of `to`.\n     *\n     *\n     * To achieve this, we use a Proxy that creates instances of Value for each\n     * requested key, as if it was an output of the node. If there is a method on\n     * node with the same name, we return a proxy for that method instead, that\n     * forwards all gets to the Value instance. As this includes the `then` method\n     * defined on the value, `await node.foo` works, even though `node.foo` is a a\n     * function. That it is a function is important for `node.then`, so that the\n     * node acts like a Promise as well.\n     *\n     */\n    // TODO: Hack keys() to make spread work\n    asProxy() {\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                if (typeof prop === \"string\") {\n                    const value = new Value(target, target.#scope, prop);\n                    let method = target[prop];\n                    // .to(), .in(), etc. call the original method:\n                    if (method && typeof method === \"function\")\n                        method = method.bind(target);\n                    // Otherwise, default \"method\" is to invoke the lambda represented by the value\n                    else\n                        method = ((config) => value.invoke(config)).bind(value);\n                    return new Proxy(method, {\n                        get(_, key, __) {\n                            const maybeMethod = Reflect.get(value, key, value);\n                            return typeof maybeMethod === \"function\"\n                                ? maybeMethod.bind(value)\n                                : maybeMethod;\n                        },\n                        ownKeys(_) {\n                            return Reflect.ownKeys(value).filter((key) => typeof key === \"string\");\n                        },\n                    });\n                }\n                else {\n                    return Reflect.get(target, prop, receiver);\n                }\n            },\n            ownKeys(target) {\n                return [target.#spreadKey()];\n            },\n        });\n    }\n    /**\n     * Retrieve underlying node from a NodeProxy. Use like this:\n     *\n     * if (thing instanceof BuilderNode) { const node = thing.unProxy(); }\n     *\n     * @returns A BuilderNoder that is not a proxy, but the original BuilderNode.\n     */\n    unProxy() {\n        return this;\n    }\n    /****\n     * Implementations of NodeProxyInterface, used for constructing Graphs,\n     * typically invoked on this.asProxy().\n     */\n    /**\n     * Makes the node (and its proxy) act as a Promise, which returns the output\n     * of the node. This trigger the execution of the graph built up so far.\n     *\n     * this.#promise is a Promise that gets resolved with the (first and only the\n     * first) invoke() call of the node. It is resolved with the outputs.\n     */\n    then(onfulfilled, onrejected) {\n        if (this.#scope.serializing())\n            throw new Error(`Can't \\`await\\` on ${this.id} in board declaration. ` +\n                `Did you mean to use \\`code\\` instead of \\`board\\`?`);\n        try {\n            // It's ok to call this multiple times: If it already run it'll only do\n            // something if new nodes or inputs were added (e.g. between await calls)\n            this.#scope.invoke(this).catch((e) => {\n                if (onrejected)\n                    return Promise.reject(e).catch(this.#scope.asScopeFor(onrejected));\n                else\n                    throw e;\n            });\n            return this.#promise.then(onfulfilled && this.#scope.asScopeFor(onfulfilled), onrejected && this.#scope.asScopeFor(onrejected));\n        }\n        catch (e) {\n            if (onrejected)\n                return Promise.reject(e).catch(this.#scope.asScopeFor(onrejected));\n            else\n                throw e;\n        }\n    }\n    to(to, config) {\n        const toNode = isBuilderNodeProxy(to)\n            ? to.unProxy()\n            : new BuilderNode(to, this.#scope, config);\n        // TODO: Ideally we would look at the schema here and use * only if\n        // the output is open ended and/or not all fields are present all the time.\n        toNode.addInputsFromNode(this, { \"*\": \"\" });\n        return toNode.asProxy();\n    }\n    // This doesn't do any type checking on the inputs.\n    //\n    // TODO: See whether that's somehow possible. The main problem is that\n    // node.<field> is typed for the outputs. We could add a new InputValue type\n    // and generate those from node.in().field so that the final syntax could be\n    // - `toNode.in({ toField: fromNode.in().fromField) }` or\n    // - `toNode.in({ field: fromNode.in() })`\n    //\n    // That is, today .in() returns itself, and in with this change, it would\n    // return a proxy object typed with the input types.\n    in(inputs) {\n        if (inputs instanceof BaseNode) {\n            this.addInputsFromNode(inputs);\n        }\n        else if (isValue(inputs)) {\n            this.addInputsFromNode(...inputs.asNodeInput());\n        }\n        else {\n            this.addInputsAsValues(inputs);\n        }\n        return this.asProxy();\n    }\n    as(keymap) {\n        return new Value(this, this.#scope, keymap);\n    }\n    keys() {\n        return [this.#spreadKey()];\n    }\n    #spreadKey() {\n        return \"*-\" + this.id;\n    }\n}\n// This will also match Lambdas, since they behave like a subset of\n// BuilderNodeProxy.\n//\n// TODO: Identify where they don't and possibly use a different is* there.\nexport function isBuilderNodeProxy(node) {\n    return typeof node.unProxy === \"function\";\n}\n//# sourceMappingURL=node.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BuilderNode } from \"./node.js\";\nimport { getCurrentContextScope } from \"./default-scope.js\";\nimport { handlersFromKit } from \"../runner/kits.js\";\nexport function addNodeType(name, handler) {\n    if (name)\n        registerNodeType(name, handler);\n    return ((config) => {\n        return new BuilderNode(name ?? handler, getCurrentContextScope(), config).asProxy();\n    });\n}\nexport function registerNodeType(name, handler) {\n    getCurrentContextScope().addHandlers({ [name]: handler });\n}\n// Extracts handlers from kits and creates node factories for them.\nexport function addKit(ctr, namespacePrefix = \"\") {\n    const kit = new ctr({});\n    const handlers = handlersFromKit(kit);\n    const removeNamespacePrefix = namespacePrefix\n        ? (name) => {\n            return name.startsWith(namespacePrefix)\n                ? name.slice(namespacePrefix.length)\n                : name;\n        }\n        : (name) => name;\n    return Object.fromEntries(Object.entries(handlers).map(([name, handler]) => [\n        removeNamespacePrefix(name),\n        addNodeType(name, handler),\n    ]));\n}\n//# sourceMappingURL=kits.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { zodToSchema } from \"./zod-utils.js\";\nimport { registerNodeType } from \"./kits.js\";\nimport { getCurrentContextScope } from \"./default-scope.js\";\nimport { BuilderNode } from \"./node.js\";\nimport { BuilderScope } from \"./scope.js\";\n/**\n * Implementation of the overloaded board function.\n */\nexport const board = (optionsOrFn, maybeFn) => {\n    const options = typeof optionsOrFn === \"object\" ? optionsOrFn : {};\n    options.graph ??= typeof optionsOrFn === \"function\" ? optionsOrFn : maybeFn;\n    return lambdaFactory(options);\n};\n/**\n * Explicit implementations of the overloaded variants, also splitting\n * graph generation and code boards.\n */\nexport const code = (fn) => {\n    return lambdaFactory({\n        invoke: fn,\n    });\n};\n/**\n * Actual implementation of all the above\n */\nfunction lambdaFactory(options) {\n    if (!options.invoke && !options.graph)\n        throw new Error(\"Missing invoke or graph definition function\");\n    const lexicalScope = getCurrentContextScope();\n    const closureEdgesToWire = [];\n    // Extract board metadata from config. Used in serialize().\n    const { url, title, description, version } = options ?? {};\n    const configMetadata = {\n        ...(url ? { url } : {}),\n        ...(title ? { title } : {}),\n        ...(description ? { description } : {}),\n        ...(version ? { version } : {}),\n    };\n    const inputSchema = options.input && zodToSchema(options.input);\n    const outputSchema = options.output && zodToSchema(options.output);\n    const handler = {};\n    if (options.describe)\n        handler.describe = options.describe;\n    else if (inputSchema && outputSchema)\n        handler.describe = async () => ({ inputSchema, outputSchema });\n    if (options.invoke)\n        handler.invoke = options.invoke;\n    if (options.graph) {\n        const scope = new BuilderScope({ lexicalScope, serialize: true });\n        scope.asScopeFor(() => {\n            const inputNode = new BuilderNode(\"input\", scope, inputSchema ? { schema: inputSchema } : {});\n            const outputNode = new BuilderNode(\"output\", scope, outputSchema ? { schema: outputSchema } : {});\n            const createAndPinNode = (type, config) => {\n                const node = new BuilderNode(type, scope, config);\n                scope.pin(node);\n                return node.asProxy();\n            };\n            // Create base kit that auto-pins to the scope.\n            const base = {\n                input: createAndPinNode.bind(null, \"input\"),\n                output: createAndPinNode.bind(null, \"output\"),\n            };\n            const result = options.graph?.(inputNode.asProxy(), base);\n            // Nothing returned means that the function must have pinned nodes itself\n            // using the `base` kit supplied above.\n            if (result === undefined)\n                return;\n            if (result instanceof Promise)\n                throw new Error(\"Graph generation function can't be async\");\n            let actualOutput = outputNode;\n            if (result instanceof BuilderNode) {\n                // If the handler returned an output node, serialize it directly,\n                // otherwise connect the returned node's outputs to the output node.\n                const node = result.unProxy();\n                if (node.type === \"output\")\n                    actualOutput = node;\n                else\n                    outputNode.addInputsFromNode(node);\n            }\n            else if (typeof result === \"object\") {\n                // Otherwise wire up all keys of the returned object to the output.\n                outputNode.addInputsAsValues(result);\n            }\n            else {\n                throw new Error(`Unexpected return ${typeof result} value from graph declaration`);\n            }\n            // Pin the resulting graph. Note: This might not contain either of the\n            // input or output nodes created above, if e.g. a new input node was\n            // created and an output node was returned.\n            scope.pin(actualOutput);\n        })();\n        // Add closure wires from parent scopes, if any\n        if (scope.getClosureEdges().length > 0) {\n            // This input node will receive all closure wires into the new graph.\n            const closureInput = new BuilderNode(\"input\", scope, {\n                $id: \"closure-input\",\n            });\n            scope.pin(closureInput);\n            for (const edge of scope.getClosureEdges()) {\n                // Connect closure input to destination node\n                const { to, out, in: in_ } = edge;\n                const wire = `$l-${out}-${to.id}`;\n                to.addIncomingEdge(closureInput, wire, in_, true);\n                // Wire upwards. This has to wait until the end of this function because\n                // we first need the lambda node, and that in turn needs to serialize\n                // this graph first.\n                closureEdgesToWire.push({ ...edge, to: closureInput, in: wire });\n            }\n        }\n        scope.compactPins();\n        const numGraphs = scope.getPinnedNodes().length;\n        if (numGraphs !== 1)\n            if (numGraphs === 0)\n                throw new Error(\"If not returning a graph, use `base.input` and `base.output`.\");\n            else\n                throw new Error(`Expected exactly one graph, but got ${numGraphs}. Are ${scope\n                    .getPinnedNodes()\n                    .map((node) => node.id)\n                    .join(\", \")} maybe disjoint?`);\n        handler.graph = scope;\n    }\n    let lambdaNode = undefined;\n    // TODO: Fix for closures, probably create a graph with an invoke node and\n    // re-register name with that as handler. But first we need to get cross-scope\n    // wiring right.\n    if (options.name)\n        registerNodeType(options.name, handler);\n    // When this factory is called, create node with handler and return as proxy.\n    // But if this is a closure, i.e. there are incoming wires to the lambda node\n    // (= like a closure, it reads from other nodes in its parent lexical scope),\n    // then invoke said lambda by reading the board capability it creates.\n    const factory = ((config) => {\n        if (!lambdaNode ||\n            (lambdaNode.incoming.length === 0 && closureEdgesToWire.length == 0))\n            return new BuilderNode(handler, getCurrentContextScope(), config).asProxy();\n        else\n            return new BuilderNode(\"invoke\", getCurrentContextScope(), {\n                ...config,\n                $board: lambdaNode.asProxy().board,\n            });\n    });\n    // Serializable:\n    // (Will be called and then overwritten by `createLambda` below\n    // once this turns into a closure)\n    factory.serialize = async (metadata) => {\n        const node = new BuilderNode(handler, lexicalScope);\n        const [singleNode, graph] = await node.serializeNode();\n        // If there is a subgraph that is invoked, just return that.\n        if (graph) {\n            if (singleNode.type !== \"invoke\")\n                throw new Error(\"Unexpected node with graph\");\n            return { ...configMetadata, ...metadata, ...graph };\n        }\n        // Otherwise build a graph around the node:\n        else\n            return {\n                ...configMetadata,\n                ...metadata,\n                edges: [\n                    { from: `${singleNode.id}-input`, to: singleNode.id, out: \"*\" },\n                    { from: singleNode.id, to: `${singleNode.id}-output`, out: \"*\" },\n                ],\n                nodes: [\n                    {\n                        id: `${singleNode.id}-input`,\n                        type: \"input\",\n                        configuration: inputSchema ? { schema: inputSchema } : {},\n                    },\n                    singleNode,\n                    {\n                        id: `${singleNode.id}-output`,\n                        type: \"output\",\n                        configuration: outputSchema ? { schema: outputSchema } : {},\n                    },\n                ],\n            };\n    };\n    // ClosureNodeInterface:\n    // Creates a lambda node if this lambda is used as a closure, i.e. it accesses\n    // wires from nodes in it's lexical scope, or it's passed as a value, i.e. a\n    // BoardCapability needs to be created. Those wires will be wired to this\n    // node, which then passes the values to the lambda when invoked. For now it\n    // does that by adding those values to the `args` field in the serialized\n    // graph. And it outputs a `BoardCapability` that can be invoked. In the\n    // future we'll replace the latter with first class support of factories.\n    function getLambdaNode() {\n        if (lambdaNode)\n            return lambdaNode;\n        const serialized = factory.serialize();\n        // HACK: Since node creation is synchronous, we put a promise for the board\n        // capability here. BuilderNode.serializeNode() awaits that then.\n        lambdaNode = new BuilderNode(\"lambda\", lexicalScope, {\n            board: (async () => ({\n                kind: \"board\",\n                board: { kits: [], ...(await serialized) },\n                // kits: because Runner.fromBoardCapability checks for that.\n            }))(),\n        });\n        // Replace the serialize function with one that returns a graph with that\n        // lambda node and an invoke node, not the original graph.\n        factory.serialize = async (metadata) => {\n            // If there are no incoming wires to the lambda node, it's not a closure\n            // and we can just return the original board.\n            if (lambdaNode?.incoming.length === 0 && closureEdgesToWire.length === 0)\n                return await serialized;\n            const invoke = new BuilderNode(\"invoke\", getCurrentContextScope(), {\n                $board: lambdaNode?.asProxy().board,\n            });\n            return invoke.serialize({ ...configMetadata, ...metadata });\n        };\n        return lambdaNode;\n    }\n    // Return wire from lambdaNode that will generate a BoardCapability\n    factory.getBoardCapabilityAsValue = () => lambdaNode !== undefined &&\n        (lambdaNode.incoming.length > 0 || closureEdgesToWire.length > 0)\n        ? lambdaNode.asProxy().board\n        : (async () => ({\n            kind: \"board\",\n            board: { kits: [], ...(await factory.serialize()) },\n        }))();\n    // Access to factory as if it was a node means accessing the closure node.\n    // This makes otherNode.to(factory) work.\n    factory.unProxy = () => getLambdaNode().unProxy();\n    // Allow factory.in(...incoming wires...).\n    //\n    // Note: factory.to() is not supported as there are no outgoing wires. To\n    // access to `board` output, wire the factory directly. In the future we'll\n    // get rid of BoardCapability and treat node factories as first class entities.\n    //\n    factory.in = (inputs) => {\n        getLambdaNode().in(inputs);\n        return factory;\n    };\n    for (const { scope: fromScope, from, out, in: in_ } of closureEdgesToWire) {\n        // If we reached the source scope, connect source node to lambda\n        if (fromScope === lexicalScope)\n            getLambdaNode().addIncomingEdge(from, out, in_, true);\n        // Otherwise add closure edge to the lambda node's scope\n        else\n            lexicalScope.addClosureEdge({\n                scope: fromScope,\n                from,\n                to: getLambdaNode(),\n                out,\n                in: in_,\n            });\n    }\n    return factory;\n}\nexport function isLambda(factory) {\n    return (typeof factory === \"function\" &&\n        typeof factory.getBoardCapabilityAsValue === \"function\");\n}\n//# sourceMappingURL=board.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { addNodeType } from \"./kits.js\";\nimport { convertZodToSchemaInConfig } from \"./zod-utils.js\";\nconst reservedWord = async () => {\n    throw new Error(\"Reserved word handler should never be invoked\");\n};\n// These get added to the default scope\nconst inputFactory = addNodeType(\"input\", reservedWord);\nconst outputFactory = addNodeType(\"output\", reservedWord);\nexport const base = {\n    input: (config) => convertZodToSchemaInConfig(config, inputFactory),\n    output: (config) => convertZodToSchemaInConfig(config, outputFactory),\n};\n//# sourceMappingURL=base.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { parseWithStreams, patchReadableStream, stringifyWithStreams, } from \"../stream.js\";\nconst isIterable = (o) => {\n    return typeof o === \"object\" && o !== null && Symbol.iterator in o;\n};\nconst serverStreamEventDecoder = () => {\n    return new TransformStream({\n        transform(chunk, controller) {\n            if (chunk.startsWith(\"data: \")) {\n                controller.enqueue(chunk.slice(6));\n            }\n        },\n    });\n};\nexport const parseWithStreamsTransform = () => {\n    const siphon = new TransformStream();\n    const writer = siphon.writable.getWriter();\n    return new TransformStream({\n        transform(chunk, controller) {\n            const parsed = parseWithStreams(chunk, (id) => {\n                if (id !== 0) {\n                    throw new Error(\"HTTPClientTransport does not support multiple streams at the moment.\");\n                }\n                return siphon.readable;\n            });\n            // Siphon away chunks into the stream.\n            const [type] = Array.isArray(parsed) ? parsed : [];\n            if (type === \"http-stream-chunk\") {\n                writer.write(parsed[1].chunk);\n            }\n            else if (type === \"http-stream-end\") {\n                writer.close();\n            }\n            else {\n                controller.enqueue(parsed);\n            }\n        },\n    });\n};\nexport class HTTPServerTransport {\n    #request;\n    #response;\n    constructor(request, response) {\n        this.#request = request;\n        this.#response = response;\n    }\n    createServerStream() {\n        const request = this.#request;\n        const response = this.#response;\n        patchReadableStream();\n        response.header(\"Content-Type\", \"text/event-stream\");\n        return {\n            readableRequests: new ReadableStream({\n                start(controller) {\n                    if (!isIterable(request.body)) {\n                        controller.error(new Error(\"Unexpected uniterable body. This is likely a result of processing a GET request. Only POST requests are supported.\"));\n                        return;\n                    }\n                    controller.enqueue(request.body);\n                    controller.close();\n                },\n            }),\n            writableResponses: new WritableStream({\n                async write(chunk) {\n                    const stringified = stringifyWithStreams(chunk);\n                    response.write(`data: ${stringified.value}\\n\\n`);\n                    if (stringified.streams.length) {\n                        if (stringified.streams.length > 1) {\n                            throw new Error(\"HTTPServerTransport does not support multiple streams at the moment.\");\n                        }\n                        // this chunk has streams, let's send the stream data\n                        // along with the chunk.\n                        const stream = stringified.streams[0];\n                        await stream.pipeTo(new WritableStream({\n                            write(chunk) {\n                                const data = [\"http-stream-chunk\", { chunk }];\n                                response.write(`data: ${JSON.stringify(data)}\\n\\n`);\n                            },\n                            close() {\n                                const data = [\"http-stream-end\", {}];\n                                response.write(`data: ${JSON.stringify(data)}\\n\\n`);\n                            },\n                        }));\n                    }\n                },\n                close() {\n                    response.end();\n                },\n            }),\n        };\n    }\n}\n/**\n * When processing HTTP responses, the server may send chunks that are\n * broken in two ways:\n * - Multiple chunks might be merged together\n * - A single chunk might be broken into multiple chunks.\n *\n * This transform stream repairs such chunks, merging broken chunks and\n * splitting merged chunks.\n *\n * @returns The transform stream that repaired chunks.\n */\nconst chunkRepairTransform = () => {\n    let queue = [];\n    return new TransformStream({\n        transform(chunk, controller) {\n            const brokenChunk = !chunk.endsWith(\"\\n\");\n            const chunks = chunk.split(\"\\n\").filter(Boolean);\n            // If there are items in the queue, prepend them to the first chunk\n            // and enqueue the result.\n            if (queue.length && !brokenChunk) {\n                controller.enqueue(`${queue.join(\"\")}${chunks.shift()}`);\n                queue = [];\n            }\n            // Queue all chunks except the last one.\n            while (chunks.length > 1) {\n                controller.enqueue(chunks.shift());\n            }\n            const lastChunk = chunks.shift();\n            if (!lastChunk)\n                return;\n            if (brokenChunk) {\n                queue.push(lastChunk);\n            }\n            else {\n                controller.enqueue(lastChunk);\n            }\n        },\n        flush() {\n            // The queue should be empty at the end of the stream.\n            // The presence of items in the queue is an indication that the\n            // stream was not formatted correctly.\n            if (queue.length) {\n                throw new Error(\"Unexpected end of stream.\");\n            }\n        },\n    });\n};\nexport class HTTPClientTransport {\n    #url;\n    #options;\n    #fetch;\n    constructor(url, options) {\n        this.#url = url;\n        this.#options = {\n            ...options,\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n        };\n        this.#fetch = this.#options.fetch ?? globalThis.fetch.bind(globalThis);\n    }\n    createClientStream() {\n        let responseResolve;\n        const responsePromise = new Promise((resolve) => {\n            responseResolve = resolve;\n        });\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const that = this;\n        return {\n            readableResponses: new ReadableStream({\n                async pull(controller) {\n                    const response = await responsePromise;\n                    const reader = response.getReader();\n                    for (;;) {\n                        const result = await reader.read();\n                        if (result.done) {\n                            break;\n                        }\n                        else {\n                            console.log(\"%cServer-Sent Event Chunk\", \"background: #009; color: #FFF\", result.value);\n                            controller.enqueue(result.value);\n                        }\n                    }\n                    controller.close();\n                },\n            }),\n            writableRequests: new WritableStream({\n                async write(chunk, controller) {\n                    if (!responseResolve) {\n                        throw new Error(\"HTTPClientTransport supports only one write per stream instance.\");\n                    }\n                    const response = await that.#fetch(that.#url, {\n                        ...that.#options,\n                        body: JSON.stringify(chunk),\n                    });\n                    if (!response.ok) {\n                        controller.error(new Error(`HTTP error: ${response.status}`));\n                    }\n                    responseResolve(response.body\n                        ?.pipeThrough(new TextDecoderStream())\n                        .pipeThrough(chunkRepairTransform())\n                        .pipeThrough(serverStreamEventDecoder())\n                        .pipeThrough(parseWithStreamsTransform()));\n                    responseResolve = undefined;\n                },\n            }),\n        };\n    }\n}\n//# sourceMappingURL=http.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Board, asyncGen } from \"../index.js\";\nimport { timestamp } from \"../timestamp.js\";\nimport { Diagnostics } from \"./diagnostics.js\";\nimport { baseURL } from \"./url.js\";\nconst fromProbe = (probe) => {\n    const loadStateIfAny = () => {\n        if (probe.type === \"nodestart\") {\n            return probe.state;\n        }\n        return undefined;\n    };\n    const state = loadStateIfAny();\n    const data = structuredClone(probe.data);\n    return {\n        type: probe.type,\n        data,\n        state,\n        reply: async () => {\n            // Do nothing\n        },\n    };\n};\nconst fromRunnerResult = (result) => {\n    const { type, node, timestamp } = result;\n    if (type === \"input\") {\n        const { inputArguments } = result;\n        return {\n            type,\n            data: {\n                node,\n                inputArguments,\n            },\n            reply: async (value) => {\n                result.inputs = value.inputs;\n            },\n        };\n    }\n    else if (type === \"output\") {\n        const { outputs } = result;\n        return {\n            type,\n            data: {\n                node,\n                outputs,\n                timestamp,\n            },\n            reply: async () => {\n                // Do nothing\n            },\n        };\n    }\n    throw new Error(`Unknown result type \"${type}\".`);\n};\nconst endResult = () => {\n    return {\n        type: \"end\",\n        data: { timestamp: timestamp() },\n        reply: async () => {\n            // Do nothing\n        },\n    };\n};\nconst errorResult = (error) => {\n    return {\n        type: \"error\",\n        data: { error, timestamp: timestamp() },\n        reply: async () => {\n            // Do nothing\n        },\n    };\n};\nexport async function* runLocally(config, kits) {\n    yield* asyncGen(async (next) => {\n        const base = baseURL(config);\n        const runner = await Board.load(config.url, { base });\n        try {\n            const probe = config.diagnostics\n                ? new Diagnostics(async (message) => {\n                    await next(fromProbe(message));\n                })\n                : undefined;\n            for await (const data of runner.run({ probe, kits })) {\n                await next(fromRunnerResult(data));\n            }\n            await next(endResult());\n        }\n        catch (e) {\n            let error = e;\n            let message = \"\";\n            while (error?.cause) {\n                // In the event we get a cause that has no inner error, we will\n                // propagate the cause instead.\n                error = error.cause.error ?? {\n                    name: \"Unexpected Error\",\n                    message: JSON.stringify(error.cause, null, 2),\n                };\n                if (error && \"message\" in error) {\n                    message += `\\n${error.message}`;\n                }\n            }\n            console.error(message, error);\n            await next(errorResult(message));\n        }\n    });\n}\n//# sourceMappingURL=local.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { asRuntimeKit } from \"@google-labs/breadboard\";\nimport { KitBuilder } from \"../kits/builder.js\";\nimport { timestamp } from \"../timestamp.js\";\nexport const createSecretAskingKit = (next) => {\n    const secretAskingKit = new KitBuilder({\n        url: \"secret-asking-kit\",\n    }).build({\n        secrets: async (inputs) => {\n            const { keys } = inputs;\n            if (!keys)\n                return {};\n            let outputs = {};\n            await next({\n                type: \"secret\",\n                data: { keys, timestamp: timestamp() },\n                reply: async (value) => {\n                    outputs = value.inputs;\n                },\n            });\n            return outputs;\n        },\n    });\n    return asRuntimeKit(secretAskingKit);\n};\n//# sourceMappingURL=secrets.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { asyncGen } from \"../index.js\";\nimport { createSecretAskingKit } from \"./secrets.js\";\nimport { ProxyServer } from \"../remote/proxy.js\";\nimport { PortDispatcher, WorkerClientTransport, WorkerServerTransport, } from \"../remote/worker.js\";\nimport { RunClient } from \"../remote/run.js\";\nimport { InitClient } from \"../remote/init.js\";\nexport const createWorker = (url) => {\n    const workerURL = new URL(url, location.href);\n    const code = `import \"${workerURL}\";`;\n    const blob = new Blob([code], { type: \"text/javascript\" });\n    const blobUrl = URL.createObjectURL(blob);\n    return new Worker(blobUrl, { type: \"module\" });\n};\nexport async function* runInWorker(workerURL, config, state) {\n    const worker = createWorker(workerURL);\n    const dispatcher = new PortDispatcher(worker);\n    const initClient = new InitClient(new WorkerClientTransport(dispatcher.send(\"load\")));\n    const proxyServer = new ProxyServer(new WorkerServerTransport(dispatcher.receive(\"proxy\")));\n    const runClient = new RunClient(new WorkerClientTransport(dispatcher.send(\"run\")));\n    await initClient.load(config.url);\n    yield* asyncGen(async (next) => {\n        const kits = [createSecretAskingKit(next), ...config.kits];\n        const proxy = config.proxy?.[0]?.nodes;\n        proxyServer.serve({ kits, proxy });\n        for await (const data of runClient.run(state)) {\n            await next(data);\n        }\n    });\n}\n//# sourceMappingURL=worker.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { asyncGen } from \"../index.js\";\nimport { HTTPClientTransport } from \"../remote/http.js\";\nimport { ProxyClient } from \"../remote/proxy.js\";\nimport { runLocally } from \"./local.js\";\nimport { createSecretAskingKit } from \"./secrets.js\";\nimport { runInWorker } from \"./worker.js\";\nconst configureKits = (config) => {\n    // If a proxy is configured, add the proxy kit to the list of kits.\n    const proxyConfig = config.proxy?.[0];\n    if (!proxyConfig)\n        return config.kits;\n    if (proxyConfig.location !== \"http\") {\n        throw new Error(\"Only HTTP node proxy server is supported at this time.\");\n    }\n    if (!proxyConfig.url) {\n        throw new Error(\"No node proxy server URL provided.\");\n    }\n    const proxyClient = new ProxyClient(new HTTPClientTransport(proxyConfig.url));\n    return [proxyClient.createProxyKit(proxyConfig.nodes), ...config.kits];\n};\nexport async function* run(config) {\n    if (!config.remote) {\n        yield* asyncGen(async (next) => {\n            const kits = [createSecretAskingKit(next), ...configureKits(config)];\n            for await (const data of runLocally(config, kits)) {\n                await next(data);\n            }\n        });\n    }\n    else if (config.remote.type === \"worker\") {\n        const workerURL = config.remote && config.remote.url;\n        if (!workerURL) {\n            throw new Error(\"Worker harness requires a worker URL\");\n        }\n        yield* runInWorker(workerURL, config);\n    }\n    else {\n        throw new Error(`Unsupported harness configuration: ${JSON.stringify(config, null, 2)}`);\n    }\n}\n//# sourceMappingURL=run.js.map"],"names":["Traversal","computeMissingInputs","heads","inputs","current","requiredInputs","Set","filter","edge","in","optional","map","inputsWithConfiguration","Object","keys","forEach","key","add","configuration","input","has","MachineEdgeState","state","Map","constants","queueOutput","node","value","queuesMap","get","set","queue","push","wireOutputs","opportunites","outputs","opportunity","from","length","Error","to","out","constant","this","output","undefined","getAvailableInputs","nodeId","result","entries","useInputs","shift","MachineResult","descriptor","missingInputs","opportunities","newOpportunities","outputsPromise","pendingOutputs","constructor","skip","fromObject","o","edgeState","TraversalMachineIterator","graph","noParallelExecution","processCompletedNode","completedNodeOutput","promiseId","delete","$error","e","cause","globalThis","console","warn","processAllPendingNodes","Promise","all","values","next","id","Symbol","promise","resolve","then","catch","error","kind","size","race","done","nodes","tails","toNode","currentDescriptor","incomingEdges","GraphRepresentation","edges","reduce","acc","Array","TraversalMachine","previousResult","asyncIterator","start","entry","entryResult","type","prepareToSave","replacer","$type","reviver","saveRunnerState","async","JSON","stringify","timestamp","performance","now","RunResult","runState","invocationId","inputArguments","save","isAtExitNode","load","stringifiedResult","s","parse","loadRunnerState","InputStageResult","super","OutputStageResult","resolveURL","base","urlString","results","url","URL","hash","href","path","protocol","decodeURIComponent","pathname","baseWithoutHash","replace","hrefWithoutHash","location","substring","loadFromFile","process","readFileFn","require","readFile","import","loadWithFetch","response","fetch","json","BoardLoadingStep","loaders","graphs","file","unknown","BoardLoader","subgraphs","isSubgraph","step","ReadableStream","prototype","reader","getReader","read","releaseLock","BoardStreamer","writable","readable","controller","WritableStream","write","chunk","TextDecoder","decode","split","line","trim","close","data","enqueue","post","method","headers","body","pipeThrough","runRemote","stream","callHandler","handler","context","handlerFunction","Function","invoke","getHandlerFunction","handlersFromKits","kits","handlers","kit","properNodeId","shape","idPrefix","nodeType","text","MermaidGenerator","nodeMap","handleSlotted","fromNode","prefix","slotted","name","subgraph","describeSubgraph","join","handleLambda","board","capability","describeSubgraphs","lamdba","edgeName","describeGraph","subgraphEdge","ignoreSubgraphs","mermEdge","describeEdge","getSchemaType","isArray","SchemaBuilder","additionalProperties","required","properties","build","setAdditionalProperties","addInputs","addProperty","schema","addProperties","addRequired","empty","createErrorMessage","inputName","metadata","boardTitle","title","bubbleUpInputsIfNeeded","requestInput","InputSchemaReader","createBubbleHandler","default","currentOutputs","newOutputs","property","includes","RequestedInputsManager","cache","createHandler","cachedValue","requestInputResult","transient","noop","AsyncGenQueue","wroteIntoQueue","whenQueuedUp","lastReceipt","abort","setQueuePromise","reject","addToQueue","receipt","AsyncGenIterator","callback","firstTime","bind","err","asyncGen","StackManager","stack","structuredClone","onGraphStart","onNodeStart","onNodeEnd","onGraphEnd","BoardRunner","description","$schema","version","args","slots","validators","outerGraph","breadboardSchema","assign","run","probe","handlersFromBoard","validator","addGraph","machine","requestedInputs","invocationPath","report","newContext","validatorMetadata","getValidatorMetadata","runOnce","addValidator","getSubgraphValidator","mermaid","direction","unstyled","unstyledTemplate","template","toMermaid","fromGraphDescriptor","breadboard","options","loader","fromBreadboardCapability","boardish","runnableBoard","upstreamKits","Core","static","lambda","describe","inputSchema","outputSchema","IdVendor","vendId","count","specRegex","nodeIdVendor","Node","currentBoardToAddTo","hasValues","incomingWiresToAdd","_","wire","indexOf","find","k","addNode","spec","ltr","match","a","b","dir","q","groups","parseSpec","addEdgeAcrossBoards","addEdge","asRuntimeKit","ctor","create","getConfigWithLambda","config","gotGraph","Board","closureStack","topClosure","acrossBoardsEdges","$id","rest","boardOrFunction","pop","label","outerEdge","addKit","ctr","InitServer","transport","serve","createServerStream","readableRequests","request","InitClient","writer","createClientStream","writableRequests","getWriter","Diagnostics","EventTarget","message","STREAM_KIND","StreamCapability","stringifyWithStreams","foundStreams","object","maybeStream","isStreamCapability","streams","parseWithStreams","getStream","parsed","stubOutStreams","stringified","portToStreams","port","onmessage","ev","cancel","postMessage","WritableResult","reply","StreamsAsyncIterator","streamsToAsyncIterable","RunServer","runner","diagnostics","requestReader","log","resumeRun","responses","writableResponses","servingContext","stop","createRunResult","RunClient","clientTransport","server","readableResponses","DISPATCHER_SEND","PortDispatcher","worker","waitForSender","pool","addEventListener","event","waiting","receive","pooledPort","portFactory","streamsAvailable","pull","pipeTo","reason","portFactoryToStreams","send","port1","port2","MessageChannel","WorkerClientTransport","highWaterMark","WorkerServerTransport","clientStreams","KitBuilder","namespacePrefix","addPrefix","prefixedHandlers","nodeFactory","proxy","Proxy","target","prop","configOrLambda","wrap","params","functions","previous","fn","argNames","toString","argName","startsWith","lastArgName","atob","str","Buffer","btoa","NodeTunnel","outputName","when","getInputNames","inputNames","matches","every","inputValue","test","readNodeSpec","fromEntries","v","TUNNEL_HASH","Math","round","Date","TUNNEL_PREFIX","TUNNEL_SUFFIX","SPLIT_REGEX","RegExp","TUNNEL_REGEX","replaceTunnelledInputs","allow","parts","Boolean","part","encodedInputs","jsonString","slice","createTunnelKit","outputWrappedHandlers","nodeTunnels","tunnels","replaceOutputs","memoize","getTunnelValue","destinations","flatMap","tunnel","createDestinationMap","inputWrappedHandlers","destinationTunnels","some","replaceInputs","getHandlerConfig","handlerConfig","arg","ProxyServer","tunnelKit","readConfig","ProxyClient","shutdownServer","createProxyKit","nodesToProxy","proxiedNodes","baseURL","self","WorkerTransportFactory","dispatcher","client","WorkerGlobalScope","maybeCreateWorker","factory","configureKits","initServer","getBoardURL","defineServeConfig","AbstractNode","BaseNode","outgoing","incoming","scope","addIncomingEdge","in_","getHandlerDescribe","getHandler","dynamicScope","handlerFn","getPinnedNodes","invokeOneRound","serialize","serializeNode","State","controlWires","haveRun","queueUp","requiredKeys","presentKeys","shiftInputs","queues","processResult","distribution","unused","unusedPorts","ports","distributeResults","missing","received","Scope","parentLexicalScope","parentDynamicScope","pinnedNodes","callbacks","lexicalScope","addHandlers","pin","compactPins","visited","disjointPins","findAllConnectedNodes","addCallbacks","getAllCallbacks","callbackResult","before","after","resolver","lastNode","lastMissingInputs","stopState","_scope","_inputs","_outputs","$state","nodeDescriptor","subGraph","addMissingSchemas","getSchemasForNode","incomingPorts","outgoingPorts","schemaPorts","mayHaveOptional","$optional","buildRequiredPropertyList","currentContextScope","getCurrentContextScope","BuilderScope","swapCurrentContextScope","oldScope","isSerializing","closureEdges","parentLambdaNode","parentLambda","unProxy","serializing","asScopeFor","addClosureEdge","getClosureEdges","AbstractValue","IsValueSymbol","isValue","obj","Value","keymap","onfulfilled","onrejected","asNodeInput","isBuilderNodeProxy","BuilderNode","addInputsFromNode","asProxy","invertedMap","fromKey","toKey","remapKeys","addInputsAsValues","as","newKey","newMap","$board","isUnknown","isString","isNumber","isBoolean","isImage","mimeType","isObject","format","examples","newKeys","isLambda","getBoardCapabilityAsValue","spreadKey","keyPairs","fromScope","code","arrowFunctionRegex","traditionalFunctionRegex","paramsWithParens","exec","schemas","invokeGraph","raw","receiver","__","maybeMethod","Reflect","ownKeys","addNodeType","registerNodeType","reservedWord","HTTPClientTransport","responseResolve","responsePromise","that","ok","status","TextDecoderStream","TransformStream","transform","brokenChunk","endsWith","chunks","lastChunk","flush","chunkRepairTransform","siphon","parseWithStreamsTransform","fromProbe","loadStateIfAny","fromRunnerResult","endResult","errorResult","createSecretAskingKit","secretAskingKit","secrets","createWorker","workerURL","blob","Blob","blobUrl","createObjectURL","Worker","proxyConfig","remote","initClient","proxyServer","runClient","runInWorker","runLocally"],"mappings":"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"}