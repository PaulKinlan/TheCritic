/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
export class KitBuilder {
    url;
    title;
    description;
    version;
    namespacePrefix;
    constructor({ title, description, version, url, namespacePrefix = "", }) {
        this.url = url;
        this.title = title;
        this.description = description;
        this.version = version;
        this.namespacePrefix = namespacePrefix;
    }
    #addPrefix(handlers) {
        return Object.keys(handlers).reduce((acc, key) => {
            acc[`${this.namespacePrefix}${key}`] = handlers[key];
            return acc;
        }, {});
    }
    build(handlers) {
        if (!this.url)
            throw new Error(`Builder was not yet initialized.`);
        const url = this.url;
        const prefix = this.namespacePrefix;
        const { title, description, version } = this;
        const prefixedHandlers = this.#addPrefix(handlers);
        const nodes = Object.keys(handlers);
        return class {
            title = title;
            description = description;
            version = version;
            url = url;
            get handlers() {
                return prefixedHandlers;
            }
            constructor(nodeFactory) {
                const proxy = new Proxy(this, {
                    get(target, prop) {
                        if (prop === "handlers" || prop === "url") {
                            return target[prop];
                        }
                        else if (nodes.includes(prop)) {
                            return (configOrLambda = {}) => {
                                const config = nodeFactory.getConfigWithLambda(configOrLambda);
                                const { $id, ...rest } = config;
                                return nodeFactory.create(proxy, `${prefix}${prop}`, { ...rest }, $id);
                            };
                        }
                    },
                });
                return proxy;
            }
        };
    }
    static wrap(params, functions) {
        const createHandler = (previous, current) => {
            const [name, fn] = current;
            previous[name] = {
                invoke: async (inputs) => {
                    // JS can have rest args, eg. "...args" as a parameter at the end of a function, but breadboard cannot accept "." so we use "___".
                    let argNames = [];
                    if (fn && fn.length > 0) {
                        argNames = fn.toString().match(/\((.+?)\)/)?.[1].split(",") ?? [];
                        /*
                        If fn.length is greater than 1 and argNames.length = 0, then we likely have a system function that accepts a splat of arguments..
            
                        e.g Math.max([1,2,3,4])
            
                        We need to special case this and pass the arguments as an array and expect `inputs` to have a key of `args` that is an array.
                        */
                        if (fn.length > 1 && argNames.length === 0 && "___args" in inputs && Array.isArray(inputs["___args"])) {
                            argNames = ["___args"];
                        }
                    }
                    // Validate the input names.
                    for (const argName of argNames) {
                        if (argName.trim() in inputs === false) {
                            throw new Error(`Missing input: ${argName.trim()}. Valid inputs are: ${Object.keys(inputs).join(", ")}`);
                        }
                    }
                    const args = argNames
                        .filter(argName => argName.startsWith("___") == false)
                        .map((argName) => inputs[argName.trim()]);
                    const lastArgName = argNames[argNames.length - 1];
                    if (lastArgName != undefined && lastArgName.startsWith("___")) {
                        // Splat the rest of the arguments.
                        args.push(...inputs[lastArgName]);
                    }
                    const results = await fn(...args);
                    if (typeof results !== "object" || Array.isArray(results)) {
                        // Number, Boolean, Array, String, will output to `result`.
                        return { result: results };
                    }
                    // Objects will destructured into the output.
                    return { ...results };
                }
            };
            return previous;
        };
        const handlers = Object.entries(functions).reduce(createHandler, {});
        const builder = new KitBuilder(params);
        return builder.build(handlers);
    }
}
//# sourceMappingURL=builder.js.map