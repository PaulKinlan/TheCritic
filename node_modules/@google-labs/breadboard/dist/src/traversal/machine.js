/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { TraversalMachineIterator } from "./iterator.js";
import { GraphRepresentation } from "./representation.js";
import { MachineResult } from "./result.js";
import { MachineEdgeState } from "./state.js";
export class TraversalMachine {
    graph;
    previousResult;
    constructor(descriptor, result) {
        this.graph = new GraphRepresentation(descriptor);
        this.previousResult = result;
    }
    [Symbol.asyncIterator]() {
        return this.start();
    }
    start() {
        if (this.previousResult)
            return new TraversalMachineIterator(this.graph, this.previousResult);
        const { entries } = this.graph;
        if (entries.length === 0)
            throw new Error("No entry node found in graph.");
        // Create fake edges to represent entry points.
        const opportunities = entries.map((entry) => ({
            from: "$entry",
            to: entry,
        }));
        const entryResult = new MachineResult({ id: "$empty", type: "$empty" }, {}, [], opportunities, [], new MachineEdgeState(), new Map());
        return new TraversalMachineIterator(this.graph, entryResult);
    }
    static async prepareToSave(result) {
        return await TraversalMachineIterator.processAllPendingNodes(result);
    }
}
//# sourceMappingURL=machine.js.map