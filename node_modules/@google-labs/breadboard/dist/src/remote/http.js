/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { parseWithStreams, patchReadableStream, stringifyWithStreams, } from "../stream.js";
const isIterable = (o) => {
    return typeof o === "object" && o !== null && Symbol.iterator in o;
};
const serverStreamEventDecoder = () => {
    return new TransformStream({
        transform(chunk, controller) {
            if (chunk.startsWith("data: ")) {
                controller.enqueue(chunk.slice(6));
            }
        },
    });
};
export const parseWithStreamsTransform = () => {
    const siphon = new TransformStream();
    const writer = siphon.writable.getWriter();
    return new TransformStream({
        transform(chunk, controller) {
            const parsed = parseWithStreams(chunk, (id) => {
                if (id !== 0) {
                    throw new Error("HTTPClientTransport does not support multiple streams at the moment.");
                }
                return siphon.readable;
            });
            // Siphon away chunks into the stream.
            const [type] = Array.isArray(parsed) ? parsed : [];
            if (type === "http-stream-chunk") {
                writer.write(parsed[1].chunk);
            }
            else if (type === "http-stream-end") {
                writer.close();
            }
            else {
                controller.enqueue(parsed);
            }
        },
    });
};
export class HTTPServerTransport {
    #request;
    #response;
    constructor(request, response) {
        this.#request = request;
        this.#response = response;
    }
    createServerStream() {
        const request = this.#request;
        const response = this.#response;
        patchReadableStream();
        response.header("Content-Type", "text/event-stream");
        return {
            readableRequests: new ReadableStream({
                start(controller) {
                    if (!isIterable(request.body)) {
                        controller.error(new Error("Unexpected uniterable body. This is likely a result of processing a GET request. Only POST requests are supported."));
                        return;
                    }
                    controller.enqueue(request.body);
                    controller.close();
                },
            }),
            writableResponses: new WritableStream({
                async write(chunk) {
                    const stringified = stringifyWithStreams(chunk);
                    response.write(`data: ${stringified.value}\n\n`);
                    if (stringified.streams.length) {
                        if (stringified.streams.length > 1) {
                            throw new Error("HTTPServerTransport does not support multiple streams at the moment.");
                        }
                        // this chunk has streams, let's send the stream data
                        // along with the chunk.
                        const stream = stringified.streams[0];
                        await stream.pipeTo(new WritableStream({
                            write(chunk) {
                                const data = ["http-stream-chunk", { chunk }];
                                response.write(`data: ${JSON.stringify(data)}\n\n`);
                            },
                            close() {
                                const data = ["http-stream-end", {}];
                                response.write(`data: ${JSON.stringify(data)}\n\n`);
                            },
                        }));
                    }
                },
                close() {
                    response.end();
                },
            }),
        };
    }
}
/**
 * When processing HTTP responses, the server may send chunks that are
 * broken in two ways:
 * - Multiple chunks might be merged together
 * - A single chunk might be broken into multiple chunks.
 *
 * This transform stream repairs such chunks, merging broken chunks and
 * splitting merged chunks.
 *
 * @returns The transform stream that repaired chunks.
 */
const chunkRepairTransform = () => {
    let queue = [];
    return new TransformStream({
        transform(chunk, controller) {
            const brokenChunk = !chunk.endsWith("\n");
            const chunks = chunk.split("\n").filter(Boolean);
            // If there are items in the queue, prepend them to the first chunk
            // and enqueue the result.
            if (queue.length && !brokenChunk) {
                controller.enqueue(`${queue.join("")}${chunks.shift()}`);
                queue = [];
            }
            // Queue all chunks except the last one.
            while (chunks.length > 1) {
                controller.enqueue(chunks.shift());
            }
            const lastChunk = chunks.shift();
            if (!lastChunk)
                return;
            if (brokenChunk) {
                queue.push(lastChunk);
            }
            else {
                controller.enqueue(lastChunk);
            }
        },
        flush() {
            // The queue should be empty at the end of the stream.
            // The presence of items in the queue is an indication that the
            // stream was not formatted correctly.
            if (queue.length) {
                throw new Error("Unexpected end of stream.");
            }
        },
    });
};
export class HTTPClientTransport {
    #url;
    #options;
    #fetch;
    constructor(url, options) {
        this.#url = url;
        this.#options = {
            ...options,
            method: "POST",
            headers: { "Content-Type": "application/json" },
        };
        this.#fetch = this.#options.fetch ?? globalThis.fetch.bind(globalThis);
    }
    createClientStream() {
        let responseResolve;
        const responsePromise = new Promise((resolve) => {
            responseResolve = resolve;
        });
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        return {
            readableResponses: new ReadableStream({
                async pull(controller) {
                    const response = await responsePromise;
                    const reader = response.getReader();
                    for (;;) {
                        const result = await reader.read();
                        if (result.done) {
                            break;
                        }
                        else {
                            console.log("%cServer-Sent Event Chunk", "background: #009; color: #FFF", result.value);
                            controller.enqueue(result.value);
                        }
                    }
                    controller.close();
                },
            }),
            writableRequests: new WritableStream({
                async write(chunk, controller) {
                    if (!responseResolve) {
                        throw new Error("HTTPClientTransport supports only one write per stream instance.");
                    }
                    const response = await that.#fetch(that.#url, {
                        ...that.#options,
                        body: JSON.stringify(chunk),
                    });
                    if (!response.ok) {
                        controller.error(new Error(`HTTP error: ${response.status}`));
                    }
                    responseResolve(response.body
                        ?.pipeThrough(new TextDecoderStream())
                        .pipeThrough(chunkRepairTransform())
                        .pipeThrough(serverStreamEventDecoder())
                        .pipeThrough(parseWithStreamsTransform()));
                    responseResolve = undefined;
                },
            }),
        };
    }
}
//# sourceMappingURL=http.js.map