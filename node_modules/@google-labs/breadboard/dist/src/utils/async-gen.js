/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
// only here for historical purposes. Use asyncGen instead.
// Remove this when we're sure we don't need it anymore.
export const asyncGenOld = (callback) => {
    let proceedToNext;
    let nextCalled;
    let nextThrew;
    const next = async (result) => {
        nextCalled(result);
        return new Promise((resolve) => {
            proceedToNext = resolve;
        });
    };
    return {
        [Symbol.asyncIterator]() {
            let waitForCallbackToCallNext;
            let done = false;
            const resolver = (resolve, reject) => {
                nextCalled = resolve;
                nextThrew = reject;
            };
            waitForCallbackToCallNext = new Promise(resolver);
            proceedToNext = () => {
                callback(next)
                    .then(() => {
                    done = true;
                    nextCalled(undefined);
                })
                    .catch((err) => {
                    nextThrew(err);
                });
            };
            return {
                async next() {
                    proceedToNext && proceedToNext();
                    const value = await waitForCallbackToCallNext;
                    waitForCallbackToCallNext = new Promise(resolver);
                    return { done, value };
                },
            };
        },
    };
};
const noop = () => {
    /* noop */
};
class AsyncGenQueue {
    #queue = [];
    #wroteIntoQueue = noop;
    #whenQueuedUp;
    #lastReceipt;
    abort = noop;
    constructor() {
        this.#setQueuePromise();
    }
    #setQueuePromise() {
        this.#whenQueuedUp = new Promise((resolve, reject) => {
            this.#wroteIntoQueue = resolve;
            this.abort = reject;
        });
    }
    #addToQueue(entry) {
        this.#queue.push(entry);
        if (this.#queue.length == 1) {
            this.#wroteIntoQueue();
            this.#setQueuePromise();
        }
    }
    async write(value) {
        return new Promise((receipt) => {
            this.#addToQueue({ value, receipt });
        });
    }
    async read() {
        this.#lastReceipt && this.#lastReceipt();
        if (this.#queue.length === 0) {
            await this.#whenQueuedUp;
        }
        const entry = this.#queue.shift();
        if (!entry) {
            throw new Error("asyncGen queue should never be empty.");
        }
        this.#lastReceipt = entry.receipt;
        if (!entry.value) {
            return { done: true, value: undefined };
        }
        return { done: false, value: entry.value };
    }
    close() {
        this.#addToQueue({ value: undefined, receipt: noop });
    }
}
class AsyncGenIterator {
    #callback;
    #firstTime = true;
    #queue = new AsyncGenQueue();
    constructor(callback) {
        this.#callback = callback;
    }
    /**
     * Called by the callback to advance to the next value.
     * Roughly equivalent to "yield":
     * ```ts
     * yield value;
     * ```
     * same as
     * ```ts
     * await next(value);
     * ```
     * @param value
     */
    async #next(value) {
        return this.#queue.write(value);
    }
    async next() {
        if (this.#firstTime) {
            this.#firstTime = false;
            this.#callback(this.#next.bind(this))
                .then(() => {
                this.#queue.close();
            })
                .catch((err) => {
                this.#queue.abort(err);
            });
        }
        return this.#queue.read();
    }
}
/**
 * Converts async/await style code into an async generator.
 * Useful when you need to combine arrow-style functions and yield.
 *
 * Example:
 *
 * ```ts
 * async function* foo() {
 *   yield 1;
 *   yield* asyncGen(async (next) => {
 *     await next(2);
 *     await next(3);
 *   });
 *   yield 4;
 * }
 *
 * for await (const val of foo()) {
 *   console.log(val);
 * }
 * ```
 *
 * This code will print:
 *
 * ```
 * 1
 * 2
 * 3
 * 4
 * ```
 *
 * @param callback A callback that will be called with a `next` function.
 * The callback should call `next` with the next value to yield.
 * @returns An async generator.
 */
export const asyncGen = (callback) => {
    return {
        [Symbol.asyncIterator]() {
            return new AsyncGenIterator(callback);
        },
    };
};
//# sourceMappingURL=async-gen.js.map