/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { z } from "zod";
import { Schema } from "../../types.js";
import { InputsMaybeAsValues, NodeProxy } from "./types.js";
import { InputValues, OutputValues } from "../runner/types.js";
export declare const base: {
    input: (<T extends z.ZodType<any, z.ZodTypeDef, any>>(config: {
        schema: T;
        $id?: string | undefined;
    } & Partial<z.TypeOf<T> extends infer T_1 extends import("./types.js").InputValues ? { [K in keyof T_1]: z.TypeOf<T>[K] | import("./types.js").AbstractValue<z.TypeOf<T>[K]> | NodeProxy<import("./types.js").InputValues, Partial<{
        [key: string]: z.TypeOf<T>[K];
    }>>; } : never> & {
        [x: string]: unknown;
    }) => NodeProxy<Record<string, never>, z.TypeOf<T>>) & ((config?: {
        schema?: Schema;
        $id?: string;
    } & InputsMaybeAsValues<InputValues>) => NodeProxy<InputValues, OutputValues>);
    output: (<T_2 extends z.ZodType<any, z.ZodTypeDef, any>>(config: {
        schema: T_2;
        $id?: string | undefined;
    } & Partial<z.TypeOf<T_2> extends infer T_3 extends import("./types.js").InputValues ? { [K_1 in keyof T_3]: z.TypeOf<T_2>[K_1] | import("./types.js").AbstractValue<z.TypeOf<T_2>[K_1]> | NodeProxy<import("./types.js").InputValues, Partial<{
        [key: string]: z.TypeOf<T_2>[K_1];
    }>>; } : never> & {
        [x: string]: unknown;
    }) => NodeProxy<z.TypeOf<T_2>, Record<string, never>>) & ((config?: {
        schema?: Schema;
        $id?: string;
    } & InputsMaybeAsValues<InputValues>) => NodeProxy<InputValues, Record<string, never>>);
};
//# sourceMappingURL=base.d.ts.map