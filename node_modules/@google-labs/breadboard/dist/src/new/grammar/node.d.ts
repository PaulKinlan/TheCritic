/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { GraphDescriptor, NodeDescriptor } from "@google-labs/breadboard";
import { InputsMaybeAsValues, NodeProxy, NodeProxyMethods, AbstractValue, BuilderNodeInterface, BuilderNodeConfig } from "./types.js";
import { InputValues, OutputValues, NodeHandler, NodeTypeIdentifier, NodeValue, Serializeable, KeyMap, AbstractNode, ScopeInterface } from "../runner/types.js";
import { Schema } from "../../types.js";
import { BaseNode } from "../runner/node.js";
import { BuilderScope } from "./scope.js";
import { Value } from "./value.js";
export declare class BuilderNode<I extends InputValues = InputValues, O extends OutputValues = OutputValues> extends BaseNode<I, O> implements BuilderNodeInterface<I, O>, NodeProxyMethods<I, O>, PromiseLike<O>, Serializeable {
    #private;
    constructor(handler: NodeTypeIdentifier | NodeHandler<I, O>, scope: BuilderScope, config?: BuilderNodeConfig<I>);
    addInputsAsValues(values: InputsMaybeAsValues<I>): void;
    addInputsFromNode(from: AbstractNode, keymap?: KeyMap, constant?: boolean, schema?: Schema): void;
    addIncomingEdge(from: AbstractNode, out: string, in_: string, constant?: boolean, schema?: Schema): void;
    invoke(inputs: I, dynamicScope?: ScopeInterface): Promise<O>;
    serializeNode(): Promise<[NodeDescriptor, GraphDescriptor?]>;
    /**
     * Creates a proxy for a Node that is used when constructing a graph.
     *
     *   const node = originalNode.asProxy();
     *
     * It acts as a Promise for the Node's output by implementing a `then` method:
     *   const output = await node;
     *
     * It acts a proxy for Promises for the Node's output's members.
     *   const field = await node.field;
     *
     * You can still call methods on the Node:
     *   node.to(nextNode);
     *
     * You can do that on output members too:
     *   node.field.to(nextNode);
     *
     * This even works for its methods and `then` and other reserved words:
     *   const to = await node.to;
     *   const thenValue = await node.then; // note: not then()
     *   node.then.to(nextNode); // send the value of `then` to nextNode
     *   node.to.to(nextNode);   // same for the value of `to`.
     *
     *
     * To achieve this, we use a Proxy that creates instances of Value for each
     * requested key, as if it was an output of the node. If there is a method on
     * node with the same name, we return a proxy for that method instead, that
     * forwards all gets to the Value instance. As this includes the `then` method
     * defined on the value, `await node.foo` works, even though `node.foo` is a a
     * function. That it is a function is important for `node.then`, so that the
     * node acts like a Promise as well.
     *
     */
    asProxy(): NodeProxy<I, O>;
    /**
     * Retrieve underlying node from a NodeProxy. Use like this:
     *
     * if (thing instanceof BuilderNode) { const node = thing.unProxy(); }
     *
     * @returns A BuilderNoder that is not a proxy, but the original BuilderNode.
     */
    unProxy(): this;
    /****
     * Implementations of NodeProxyInterface, used for constructing Graphs,
     * typically invoked on this.asProxy().
     */
    /**
     * Makes the node (and its proxy) act as a Promise, which returns the output
     * of the node. This trigger the execution of the graph built up so far.
     *
     * this.#promise is a Promise that gets resolved with the (first and only the
     * first) invoke() call of the node. It is resolved with the outputs.
     */
    then<TResult1 = O, TResult2 = never>(onfulfilled?: ((value: O) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null): PromiseLike<TResult1 | TResult2>;
    to<ToO extends OutputValues = OutputValues, ToC extends InputValues = InputValues>(to: NodeProxy<O & ToC, ToO> | NodeTypeIdentifier | NodeHandler<O & ToC, ToO>, config?: ToC): NodeProxy<O & ToC, ToO>;
    in(inputs: NodeProxy<InputValues, Partial<I>> | InputsMaybeAsValues<I> | AbstractValue<NodeValue>): NodeProxy<I, O>;
    as(keymap: KeyMap): Value;
    keys(): string[];
}
export declare function isBuilderNodeProxy<I extends InputValues = InputValues, O extends OutputValues = OutputValues>(node: unknown): node is BuilderNodeInterface<I, O>;
//# sourceMappingURL=node.d.ts.map