/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { NodeValue, InputValues, InputsMaybeAsValues, OutputValues, NodeProxy, BuilderNodeInterface, BuilderNodeConfig, AbstractValue } from "./types.js";
import { OutputValue, NodeHandler, NodeTypeIdentifier, KeyMap } from "../runner/types.js";
import { Schema } from "../../types.js";
import { BuilderNode } from "./node.js";
import { BuilderScope } from "./scope.js";
export declare const IsValueSymbol: unique symbol;
export declare function isValue<T extends NodeValue = NodeValue>(obj: unknown): obj is Value<T>;
export declare class Value<T extends NodeValue = NodeValue> extends AbstractValue<T> implements PromiseLike<T | undefined> {
    #private;
    constructor(node: BuilderNode<InputValues, OutputValue<T>>, scope: BuilderScope, keymap: string | KeyMap, constant?: boolean, schema?: {});
    then<TResult1 = T | undefined, TResult2 = never>(onfulfilled?: ((value: T | undefined) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null): PromiseLike<TResult1 | TResult2>;
    asNodeInput(): [
        BuilderNodeInterface<InputValues, OutputValue<T>>,
        {
            [key: string]: string;
        },
        boolean,
        Schema
    ];
    to<ToO extends OutputValues = OutputValues, ToC extends InputValues = InputValues>(to: NodeProxy<OutputValue<T> & ToC, ToO> | NodeTypeIdentifier | NodeHandler<OutputValue<T> & ToC, ToO>, config?: ToC): NodeProxy<OutputValue<T> & ToC, ToO>;
    in(inputs: BuilderNodeInterface<InputValues, OutputValues> | AbstractValue<NodeValue> | InputsMaybeAsValues<InputValues>): void;
    as(newKey: string | KeyMap): Value<T>;
    memoize(): Value<T>;
    invoke(config?: BuilderNodeConfig): NodeProxy;
    /**
     * The following are type-casting methods that are useful when a node type
     * returns generic types but we want to narrow the types to what we know they
     * are, e.g. a parser node returning the result as raw wires.
     *
     * This is also a way to define the schema of a board, e.g. by casting input
     * wires and what is returned.
     *
     * Use as `foo.asString()` or `foo.asNumber()`. `isArray` and `isObject` cast
     * to generic arrays and objects.
     */
    isUnknown(): AbstractValue<unknown>;
    isString(): AbstractValue<string>;
    isNumber(): AbstractValue<number>;
    isBoolean(): AbstractValue<boolean>;
    isArray(): AbstractValue<NodeValue[]>;
    isImage(mimeType?: string): AbstractValue<unknown>;
    isObject(): AbstractValue<{
        [key: string]: NodeValue;
    }>;
    title(title: string): AbstractValue<T>;
    description(description: string): AbstractValue<T>;
    format(format: string): AbstractValue<T>;
    examples(...examples: string[]): AbstractValue<T>;
    default(value: string): AbstractValue<T>;
    optional(): AbstractValue<T>;
    transient(): AbstractValue<T>;
}
//# sourceMappingURL=value.d.ts.map