/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { AbstractNode, } from "./types.js";
import { IdVendor } from "../../id.js";
const nodeIdVendor = new IdVendor();
// TODO:BASE Extract base class that isn't opinionated about the syntax. Marking
// methods that should be base as "TODO:BASE" below, including complications.
export class BaseNode extends AbstractNode {
    id;
    type;
    outgoing = [];
    incoming = [];
    configuration = {};
    #handler;
    #scope;
    constructor(handler, scope, config = {}) {
        super();
        this.#scope = scope;
        if (typeof handler === "string") {
            this.type = handler;
        }
        else {
            this.type = "fn";
            this.#handler = handler;
        }
        const { $id, ...rest } = config;
        this.id = $id ?? nodeIdVendor.vendId(scope, this.type);
        this.configuration = rest;
    }
    addIncomingEdge(from, out, in_, constant, schema) {
        if (from.#scope !== this.#scope)
            throw new Error("Can't connect nodes from different scopes");
        const edge = {
            to: this,
            from: from,
            out,
            in: in_,
            schema,
        };
        if (constant)
            edge.constant = true;
        this.incoming.push(edge);
        from.outgoing.push(edge);
    }
    #getHandlerDescribe(scope) {
        const handler = this.#handler ?? scope.getHandler(this.type);
        return handler && typeof handler !== "function"
            ? handler.describe
            : undefined;
    }
    // In the end, we need to capture the outputs and resolve the promise. But
    // before that there is a bit of refactoring to do to allow returning of
    // graphs, parallel execution, etc.
    //
    // The logic from BuilderNode.invoke should be somehow called from here, for
    // deserialized nodes that require the Builder environment.
    async invoke(inputs, dynamicScope) {
        const scope = dynamicScope ?? this.#scope;
        const handler = this.#handler ?? scope.getHandler(this.type);
        let result;
        const handlerFn = typeof handler === "function" ? handler : handler?.invoke;
        if (handlerFn) {
            result = (await handlerFn(inputs, this));
        }
        else if (handler && typeof handler !== "function" && handler.graph) {
            // TODO: This isn't quite right, but good enough for now. Instead what
            // this should be in invoking a graph from a lexical scope in a dynamic
            // scope. This requires moving state management into the dyanmic scope.
            const graphs = handler.graph.getPinnedNodes();
            if (graphs.length !== 1)
                throw new Error("Expected exactly one graph");
            result = (await scope.invokeOneRound(inputs, graphs[0]));
        }
        else {
            throw new Error(`Can't find handler for ${this.id}`);
        }
        return result;
    }
    async describe(scope = this.#scope, inputs, inputSchema, outputSchema) {
        const describe = this.#getHandlerDescribe(scope);
        return describe
            ? await describe(inputs, inputSchema, outputSchema)
            : undefined;
    }
    async serialize(metadata) {
        return this.#scope.serialize(metadata, this);
    }
    async serializeNode() {
        const node = {
            id: this.id,
            type: this.type,
            configuration: this.configuration,
        };
        return [node];
    }
}
//# sourceMappingURL=node.js.map