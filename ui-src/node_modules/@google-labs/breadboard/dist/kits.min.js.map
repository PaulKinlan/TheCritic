{"version":3,"file":"kits.min.js","sources":["src/schema.js","src/handler.js","src/traversal/index.js","src/traversal/state.js","src/traversal/result.js","src/traversal/iterator.js","src/traversal/representation.js","src/traversal/machine.js","src/serialization.js","src/timestamp.js","src/run.js","src/loader.js","src/remote.js","src/mermaid.js","src/bubble.js","src/utils/async-gen.js","src/stack.js","src/runner.js","src/kits/graph-to-kit.js","src/kits/builder.js"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const getSchemaType = (value) => {\n    if (value === null || value === undefined) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"array\";\n    }\n    return typeof value;\n};\nexport class SchemaBuilder {\n    additionalProperties = false;\n    required = [];\n    properties = {};\n    build() {\n        const result = {\n            type: \"object\",\n            properties: this.properties,\n            additionalProperties: this.additionalProperties,\n        };\n        if (this.required.length > 0) {\n            result.required = this.required;\n        }\n        return result;\n    }\n    setAdditionalProperties(additionalProperties) {\n        if (additionalProperties !== undefined) {\n            this.additionalProperties = additionalProperties;\n        }\n        return this;\n    }\n    addInputs(inputs) {\n        if (!inputs)\n            return this;\n        Object.entries(inputs).forEach(([name, value]) => {\n            this.addProperty(name, { type: getSchemaType(value) });\n        });\n        return this;\n    }\n    addProperty(name, schema) {\n        this.properties[name] = schema;\n        return this;\n    }\n    addProperties(properties) {\n        Object.entries(properties).forEach(([name, schema]) => {\n            this.addProperty(name, schema);\n        });\n        return this;\n    }\n    addRequired(required) {\n        if (!required)\n            return this;\n        if (typeof required === \"string\") {\n            this.required = [...this.required, required];\n        }\n        else if (Array.isArray(required) && required.length > 0) {\n            this.required = [...this.required, ...required];\n        }\n        return this;\n    }\n    static empty(additionalProperties = false) {\n        return new SchemaBuilder()\n            .setAdditionalProperties(additionalProperties)\n            .build();\n    }\n}\n//# sourceMappingURL=schema.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst getHandlerFunction = (handler) => {\n    if (handler instanceof Function)\n        return handler;\n    if (handler.invoke)\n        return handler.invoke;\n    throw new Error(\"Invalid handler\");\n};\nexport const callHandler = async (handler, inputs, context) => {\n    // if (handler instanceof Function) return handler(inputs, context);\n    // if (handler.invoke) return handler.invoke(inputs, context);\n    const handlerFunction = getHandlerFunction(handler);\n    return new Promise((resolve) => {\n        handlerFunction(inputs, context)\n            .then(resolve)\n            .catch((error) => {\n            resolve({ $error: { error } });\n        });\n    });\n};\nexport const handlersFromKits = (kits) => {\n    return kits.reduce((handlers, kit) => {\n        // If multiple kits have the same handler, the kit earlier in the list\n        // gets precedence, including upstream kits getting precedence over kits\n        // defined in the graph.\n        //\n        // TODO: This means kits are fallback, consider non-fallback as well.\n        return { ...kit.handlers, ...handlers };\n    }, {});\n};\n//# sourceMappingURL=handler.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * This class holds important parts of the graph traversal algorithm.\n */\nexport class Traversal {\n    /**\n     * Computes the missing inputs for a node. A missing input is an input that is\n     * required by the node, but is not (yet) available in the current state.\n     * @param heads All the edges that point to the node.\n     * @param inputs The input values that will be passed to the node\n     * @param current The node that is being visited.\n     * @returns Array of missing input names.\n     */\n    static computeMissingInputs(heads, inputs, current) {\n        const requiredInputs = [\n            ...new Set(heads\n                .filter((edge) => !!edge.in && !edge.optional)\n                .map((edge) => edge.in || \"\")),\n        ];\n        const inputsWithConfiguration = new Set();\n        Object.keys(inputs).forEach((key) => inputsWithConfiguration.add(key));\n        if (current.configuration) {\n            Object.keys(current.configuration).forEach((key) => inputsWithConfiguration.add(key));\n        }\n        return requiredInputs.filter((input) => !inputsWithConfiguration.has(input));\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class MachineEdgeState {\n    state = new Map();\n    constants = new Map();\n    #queueOutput(map, node, key, value) {\n        let queuesMap = map.get(node);\n        if (!queuesMap) {\n            queuesMap = new Map();\n            map.set(node, queuesMap);\n        }\n        let queue = queuesMap.get(key);\n        if (!queue) {\n            queue = [];\n            queuesMap.set(key, queue);\n        }\n        queue.push(value);\n    }\n    /**\n     * Processes outputs by wiring them to the destinations according\n     * to the supplied edges. Assumes that the outputs were generated by\n     * the from node.\n     *\n     * @param opportunites {Edge[]} Edges to process\n     * @param outputs {OutputValues} Outputs to wire\n     */\n    wireOutputs(opportunites, outputs) {\n        // Verify that all edges are from the same node.\n        if (opportunites.filter((opportunity) => opportunity.from != opportunites[0].from).length !== 0)\n            throw new Error(\"All opportunities must be from the same node\");\n        opportunites.forEach((opportunity) => {\n            const to = opportunity.to;\n            const out = opportunity.out;\n            const queuesMap = opportunity.constant ? this.constants : this.state;\n            if (!out)\n                return;\n            if (out === \"*\") {\n                for (const key in outputs) {\n                    const output = outputs[key];\n                    if (output != null && output != undefined)\n                        this.#queueOutput(queuesMap, to, key, output);\n                }\n            }\n            else if (opportunity.in) {\n                const output = outputs[out];\n                // TODO: Check and document why we don't allow that\n                if (output != null && output != undefined)\n                    this.#queueOutput(queuesMap, to, opportunity.in, output);\n            }\n        });\n    }\n    /**\n     * Returns the available inputs for a given node.\n     *\n     * @param nodeId {NodeIdentifier} The node to get the inputs for.\n     * @returns {InputValues} The available inputs.\n     */\n    getAvailableInputs(nodeId) {\n        const result = {};\n        for (const queuesMap of [\n            this.constants.get(nodeId), // Constants are overwritten by state.\n            this.state.get(nodeId),\n        ]) {\n            if (!queuesMap)\n                continue;\n            for (const [key, queue] of queuesMap.entries()) {\n                if (queue.length === 0)\n                    continue;\n                result[key] = queue[0];\n            }\n        }\n        return result;\n    }\n    /**\n     * Shifts inputs from the queues. Leaves constants as is.\n     *\n     * @param nodeId {NodeIdentifier} The node to shift the inputs for.\n     * @param inputs {InputValues} The inputs that are used.\n     */\n    useInputs(nodeId, inputs) {\n        const queuesMap = this.state.get(nodeId);\n        if (!queuesMap)\n            return;\n        for (const key in inputs) {\n            const queue = queuesMap.get(key);\n            if (!queue)\n                continue;\n            queue.shift();\n        }\n    }\n}\n//# sourceMappingURL=state.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { MachineEdgeState } from \"./state.js\";\nexport class MachineResult {\n    descriptor;\n    inputs;\n    missingInputs;\n    opportunities;\n    newOpportunities;\n    state;\n    outputsPromise;\n    pendingOutputs;\n    constructor(descriptor, inputs, missingInputs, opportunities, newOpportunities, state, pendingOutputs) {\n        this.descriptor = descriptor;\n        this.inputs = inputs;\n        this.missingInputs = missingInputs;\n        this.opportunities = opportunities;\n        this.newOpportunities = newOpportunities;\n        this.state = state;\n        this.pendingOutputs = pendingOutputs;\n    }\n    /**\n     * `true` if the machine decided that the node should be skipped, rather than\n     * visited.\n     */\n    get skip() {\n        return this.missingInputs.length > 0;\n    }\n    static fromObject(o) {\n        const edgeState = new MachineEdgeState();\n        edgeState.constants = o.state.constants;\n        edgeState.state = o.state.state;\n        return new MachineResult(o.descriptor, o.inputs, o.missingInputs, o.opportunities, o.newOpportunities, edgeState, o.pendingOutputs);\n    }\n}\n//# sourceMappingURL=result.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Traversal } from \"./index.js\";\nimport { MachineResult } from \"./result.js\";\nexport class TraversalMachineIterator {\n    graph;\n    #current;\n    #noParallelExecution;\n    constructor(graph, result, noParallelExecution = true) {\n        this.graph = graph;\n        this.#current = result;\n        this.#noParallelExecution = noParallelExecution;\n    }\n    static #processCompletedNode(result, completedNodeOutput) {\n        const { promiseId, outputs, newOpportunities } = completedNodeOutput;\n        result.pendingOutputs.delete(promiseId);\n        // If there was an error, ignore all other outputs and hence opportunites.\n        const opportunities = outputs.$error\n            ? newOpportunities.filter((e) => e.out === \"$error\")\n            : newOpportunities;\n        // Process outputs.\n        result.opportunities.push(...opportunities);\n        result.state.wireOutputs(opportunities, outputs);\n        if (outputs.$error) {\n            if (opportunities.length === 0) {\n                // If the node threw an exception and it wasn't routed via $error,\n                // throw it again. This will cause the traversal to stop.\n                throw new Error(\"Uncaught exception in node handler. Catch by wiring up the $error output.\", {\n                    cause: outputs.$error,\n                });\n            }\n            else {\n                globalThis.console.warn(\"Error in node handler, passing to the wired $error output.\", outputs.$error, opportunities);\n            }\n        }\n    }\n    static async processAllPendingNodes(result) {\n        const completed = await Promise.all(result.pendingOutputs.values());\n        completed.forEach((completedNodeOutput) => {\n            TraversalMachineIterator.#processCompletedNode(result, completedNodeOutput);\n        });\n        return result;\n    }\n    async next() {\n        // If there are no missing inputs, let's consume the outputs\n        if (!this.#current.skip) {\n            const { inputs, outputsPromise, newOpportunities, descriptor } = this.#current;\n            // Mark inputs as used, i.e. shift inputs queues.\n            this.#current.state.useInputs(descriptor.id, this.#current.inputs);\n            const promiseId = Symbol();\n            const promise = new Promise((resolve) => {\n                (outputsPromise || Promise.resolve({}))\n                    .then((outputs) => {\n                    // If not already present, add inputs and descriptor along for\n                    // context and to support retries. If $error came from another node,\n                    // the descriptor will remain the original, but new inputs will be\n                    // added, though never overwriting prior ones.\n                    if (outputs.$error) {\n                        const $error = outputs.$error;\n                        outputs.$error = {\n                            descriptor,\n                            ...$error,\n                            inputs: { ...inputs, ...$error.inputs },\n                        };\n                    }\n                    resolve({ promiseId, outputs, newOpportunities });\n                })\n                    .catch((error) => {\n                    // If the handler threw an exception, turn it into a $error output.\n                    // Pass the inputs and descriptor along for context and to support\n                    // retries. This Promise will hence always resolve.\n                    resolve({\n                        promiseId,\n                        outputs: {\n                            $error: {\n                                kind: \"error\",\n                                error,\n                                inputs,\n                                descriptor,\n                            },\n                        },\n                        newOpportunities: newOpportunities.filter((edge) => edge.out === \"$error\"),\n                    });\n                });\n            });\n            this.#current.pendingOutputs.set(promiseId, promise);\n        }\n        // If there are no more opportunites or we've disabled parallel execution,\n        // let's wait for pending nodes to be done\n        while ((this.#current.opportunities.length === 0 || this.#noParallelExecution) &&\n            this.#current.pendingOutputs.size > 0) {\n            // Wait for the first pending node to be done.\n            TraversalMachineIterator.#processCompletedNode(this.#current, await Promise.race(this.#current.pendingOutputs.values()));\n        }\n        // If there are no more opportunities and none are pending, we're done.\n        if (this.#current.opportunities.length === 0)\n            return { done: true, value: null };\n        // Now, we're ready to start the next iteration.\n        // Otherwise, let's pop the next opportunity from the queue.\n        const opportunity = this.#current.opportunities.shift();\n        const { heads, nodes, tails } = this.graph;\n        const toNode = opportunity.to;\n        const currentDescriptor = nodes.get(toNode);\n        if (!currentDescriptor)\n            throw new Error(`No node found for id \"${toNode}\"`);\n        const incomingEdges = heads.get(toNode) || [];\n        const inputs = this.#current.state.getAvailableInputs(toNode);\n        const missingInputs = Traversal.computeMissingInputs(incomingEdges, inputs, currentDescriptor);\n        const newOpportunities = tails.get(toNode) || [];\n        // Pour configuration values into inputs. These are effectively like\n        // constants.\n        const inputsWithConfiguration = {\n            ...currentDescriptor.configuration,\n            ...inputs,\n        };\n        this.#current = new MachineResult(currentDescriptor, inputsWithConfiguration, missingInputs, this.#current.opportunities, newOpportunities, this.#current.state, this.#current.pendingOutputs);\n        return { done: false, value: this.#current };\n    }\n}\n//# sourceMappingURL=iterator.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class GraphRepresentation {\n    /**\n     * Tails: a map of all outgoing edges, keyed by node id.\n     */\n    tails = new Map();\n    /**\n     * Heads: a map of all incoming edges, keyed by node id.\n     */\n    heads = new Map();\n    /**\n     * Nodes: a map of all nodes, keyed by node id.\n     */\n    nodes = new Map();\n    /**\n     * Entries: a list of all nodes that have no incoming edges.\n     */\n    entries = [];\n    constructor(descriptor) {\n        this.tails = descriptor.edges.reduce((acc, edge) => {\n            const from = edge.from;\n            acc.has(from) ? acc.get(from)?.push(edge) : acc.set(from, [edge]);\n            return acc;\n        }, new Map());\n        this.heads = descriptor.edges.reduce((acc, edge) => {\n            const to = edge.to;\n            acc.has(to) ? acc.get(to)?.push(edge) : acc.set(to, [edge]);\n            return acc;\n        }, new Map());\n        this.nodes = descriptor.nodes.reduce((acc, node) => {\n            acc.set(node.id, node);\n            return acc;\n        }, new Map());\n        this.entries = Array.from(this.tails.keys()).filter((node) => !this.heads.has(node) || this.heads.get(node)?.length === 0);\n    }\n}\n//# sourceMappingURL=representation.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachineIterator } from \"./iterator.js\";\nimport { GraphRepresentation } from \"./representation.js\";\nimport { MachineResult } from \"./result.js\";\nimport { MachineEdgeState } from \"./state.js\";\nexport class TraversalMachine {\n    graph;\n    previousResult;\n    constructor(descriptor, result) {\n        this.graph = new GraphRepresentation(descriptor);\n        this.previousResult = result;\n    }\n    [Symbol.asyncIterator]() {\n        return this.start();\n    }\n    start() {\n        if (this.previousResult)\n            return new TraversalMachineIterator(this.graph, this.previousResult);\n        const { entries } = this.graph;\n        if (entries.length === 0)\n            throw new Error(\"No entry node found in graph.\");\n        // Create fake edges to represent entry points.\n        const opportunities = entries.map((entry) => ({\n            from: \"$entry\",\n            to: entry,\n        }));\n        const entryResult = new MachineResult({ id: \"$empty\", type: \"$empty\" }, {}, [], opportunities, [], new MachineEdgeState(), new Map());\n        return new TraversalMachineIterator(this.graph, entryResult);\n    }\n    static async prepareToSave(result) {\n        return await TraversalMachineIterator.processAllPendingNodes(result);\n    }\n}\n//# sourceMappingURL=machine.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachine } from \"./traversal/machine.js\";\nimport { MachineResult } from \"./traversal/result.js\";\nexport const replacer = (key, value) => {\n    if (!(value instanceof Map))\n        return value;\n    return { $type: \"Map\", value: Array.from(value.entries()) };\n};\nexport const reviver = (key, value) => {\n    const { $type } = (value || {});\n    return $type == \"Map\" && value.value\n        ? new Map(value.value)\n        : value;\n};\nexport const saveRunnerState = async (type, result) => {\n    const state = await TraversalMachine.prepareToSave(result);\n    return JSON.stringify({ state, type }, replacer);\n};\nexport const loadRunnerState = (s) => {\n    const { state: o, type } = JSON.parse(s, reviver);\n    const state = MachineResult.fromObject(o);\n    return { state, type };\n};\n//# sourceMappingURL=serialization.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const timestamp = () => globalThis.performance.now();\n//# sourceMappingURL=timestamp.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { loadRunnerState, saveRunnerState } from \"./serialization.js\";\nimport { timestamp } from \"./timestamp.js\";\nexport class RunResult {\n    #type;\n    #state;\n    // TODO: Remove #state and rename this to #state\n    #runState;\n    // TODO: Remove this once RunState machinery works\n    #invocationId;\n    constructor(state, type, runState, invocationId) {\n        this.#state = state;\n        this.#type = type;\n        this.#runState = runState;\n        this.#invocationId = invocationId;\n    }\n    get invocationId() {\n        return this.#invocationId;\n    }\n    get type() {\n        return this.#type;\n    }\n    get node() {\n        return this.#state.descriptor;\n    }\n    get inputArguments() {\n        return this.#state.inputs;\n    }\n    set inputs(inputs) {\n        this.#state.outputsPromise = Promise.resolve(inputs);\n    }\n    get outputs() {\n        return this.#state.inputs;\n    }\n    get state() {\n        return this.#state;\n    }\n    async save() {\n        return saveRunnerState(this.#type, this.#state);\n    }\n    get runState() {\n        return this.#runState;\n    }\n    get timestamp() {\n        return timestamp();\n    }\n    isAtExitNode() {\n        return (this.#state.newOpportunities.length === 0 &&\n            this.#state.opportunities.length === 0 &&\n            this.#state.pendingOutputs.size === 0);\n    }\n    static load(stringifiedResult) {\n        const { state, type } = loadRunnerState(stringifiedResult);\n        return new RunResult(state, type, undefined, 0);\n    }\n}\nexport class InputStageResult extends RunResult {\n    constructor(state, runState, invocationId) {\n        super(state, \"input\", runState, invocationId);\n    }\n    get outputs() {\n        throw new Error('Outputs are not available in the \"input\" stage');\n    }\n}\nexport class OutputStageResult extends RunResult {\n    constructor(state, invocationId) {\n        super(state, \"output\", undefined, invocationId);\n    }\n    get inputArguments() {\n        throw new Error('Input arguments are not available in the \"output\" stage');\n    }\n    set inputs(inputs) {\n        throw new Error('Setting inputs is not available in the \"output\" stage');\n    }\n}\n//# sourceMappingURL=run.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const resolveURL = (base, urlString, results) => {\n    const url = new URL(urlString, base);\n    const hash = url.hash;\n    const href = url.href;\n    const path = url.protocol === \"file:\" ? decodeURIComponent(url.pathname) : undefined;\n    const baseWithoutHash = base.href.replace(base.hash, \"\");\n    const hrefWithoutHash = href.replace(hash, \"\");\n    if (baseWithoutHash == hrefWithoutHash && hash) {\n        results.push({ type: \"hash\", location: hash.substring(1), href });\n        return true;\n    }\n    const result = path\n        ? { type: \"file\", location: path, href }\n        : href\n            ? { type: \"fetch\", location: hrefWithoutHash, href }\n            : { type: \"unknown\", location: \"\", href };\n    results.push(result);\n    return !hash;\n};\nexport const loadFromFile = async (path) => {\n    if (typeof globalThis.process === \"undefined\")\n        throw new Error(\"Unable to use `path` when not running in node\");\n    let readFileFn;\n    // The CJS transpilation process for node/vscode seems to miss this import,\n    // and leaves it as an import statement rather than converting it to a\n    // require. We therefore need a runtime check that prefers `require` if it\n    // is available.\n    if (typeof require === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const { readFile } = require(\"node:fs/promises\");\n        readFileFn = readFile;\n    }\n    else {\n        const { readFile } = await import(/* vite-ignore */ \"node:fs/promises\");\n        readFileFn = readFile;\n    }\n    return JSON.parse(await readFileFn(path, \"utf-8\"));\n};\nexport const loadWithFetch = async (url) => {\n    const response = await fetch(url);\n    return await response.json();\n};\nexport class BoardLoadingStep {\n    loaders;\n    graphs;\n    constructor(graphs) {\n        this.loaders = {\n            file: loadFromFile,\n            fetch: loadWithFetch,\n            hash: async (hash) => {\n                if (!graphs)\n                    throw new Error(\"No sub-graphs to load from\");\n                return graphs[hash];\n            },\n            unknown: async () => {\n                throw new Error(\"Unable to determine Board loader type\");\n            },\n        };\n    }\n    async load(result) {\n        const graph = await this.loaders[result.type](result.location);\n        graph.url = result.href;\n        return graph;\n    }\n}\nexport class BoardLoader {\n    #base;\n    #graphs;\n    constructor({ base, graphs }) {\n        this.#base = base;\n        this.#graphs = graphs;\n    }\n    async load(urlString) {\n        const results = [];\n        let base = this.#base;\n        while (!resolveURL(base, urlString, results)) {\n            base = new URL(results[results.length - 1].href);\n        }\n        let graph;\n        let subgraphs = this.#graphs;\n        let isSubgraph = true;\n        for (const result of results) {\n            if (result.type === \"file\" || result.type === \"fetch\")\n                isSubgraph = false;\n            const step = new BoardLoadingStep(subgraphs);\n            graph = await step.load(result);\n            subgraphs = graph.graphs;\n        }\n        if (!graph)\n            throw new Error(\"BoardLoader failed to load a graph. This error likely indicates a bug in the BoardLoader.\");\n        return { graph, isSubgraph };\n    }\n}\n//# sourceMappingURL=loader.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Polyfill to make ReadableStream async iterable\n// See https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n// eslint-disable-next-line\n// @ts-ignore\nReadableStream.prototype[Symbol.asyncIterator] ||\n    // eslint-disable-next-line\n    // @ts-ignore\n    (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {\n        const reader = this.getReader();\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    return;\n                yield value;\n            }\n        }\n        finally {\n            reader.releaseLock();\n        }\n    });\nclass BoardStreamer {\n    writable;\n    readable;\n    controller = null;\n    constructor() {\n        this.writable = new WritableStream({\n            write: (chunk) => this.write(chunk),\n        });\n        this.readable = new ReadableStream({\n            start: (controller) => {\n                this.controller = controller;\n            },\n        });\n    }\n    write(chunk) {\n        const decoder = new TextDecoder();\n        const s = decoder.decode(chunk);\n        s.split(\"\\n\")\n            .map((line) => line.trim())\n            .filter((line) => line.length > 0)\n            .forEach((line) => {\n            try {\n                if (line === \"stop\") {\n                    this.controller?.close();\n                    return;\n                }\n                const data = JSON.parse(line);\n                this.controller?.enqueue(data);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        });\n    }\n}\n/**\n * Posts the inputs to the breadboard-server and returns a stream of results.\n */\nconst post = async (url, inputs, state) => {\n    const response = await fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ inputs, state }),\n    });\n    return response.body?.pipeThrough(new BoardStreamer());\n};\nexport async function* runRemote(url) {\n    let inputs = undefined;\n    let state = undefined;\n    for (;;) {\n        const stream = await post(url, inputs, state);\n        if (!stream)\n            break;\n        for await (const result of stream) {\n            state = JSON.stringify(result.state);\n            yield result;\n            inputs = result.inputs;\n        }\n        if (!state)\n            break;\n    }\n}\n//# sourceMappingURL=remote.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst template = (edges, direction) => {\n    return `%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%\ngraph ${direction};\n${edges}\nclassDef default stroke:#ffab40,fill:#fff2ccff,color:#000\nclassDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000\nclassDef output stroke:#38761d,fill:#b6d7a8ff,color:#000\nclassDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef slot stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef config stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef secrets stroke:#db4437,fill:#f4cccc,color:#000\nclassDef slotted stroke:#a64d79`;\n};\nconst unstyledTemplate = (edges, direction) => {\n    return `graph ${direction};\n${edges}`;\n};\nconst properNodeId = (node) => {\n    // Mermaid gets confused by hyphens in node ids\n    // For example `get-graph` id will throw a syntax error, because it thinks\n    // that it sees the `graph` token.\n    return node && node.replace(/-/g, \"\");\n};\nconst shape = (descriptor, idPrefix = \"\") => {\n    if (!descriptor)\n        return \"\";\n    const node = descriptor.id;\n    const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n    const nodeId = `${prefix}${properNodeId(node)}`;\n    const nodeType = descriptor.type;\n    const text = `\"${nodeType} <br> id='${node}'\"`;\n    switch (nodeType) {\n        case \"include\":\n            return `${nodeId}[[${text}]]:::include`;\n        case \"slot\":\n            return `${nodeId}((${text})):::slot`;\n        case \"passthrough\":\n            return `${nodeId}((${text})):::passthrough`;\n        case \"input\":\n            return `${nodeId}[/${text}/]:::input`;\n        case \"secrets\":\n            return `${nodeId}(${text}):::secrets`;\n        case \"output\":\n            return `${nodeId}{{${text}}}:::output`;\n        default:\n            return `${nodeId}[${text}]`;\n    }\n};\nconst describeEdge = (edge, nodeMap, idPrefix = \"\") => {\n    const from = edge.from;\n    const fromNode = shape(nodeMap.get(from), idPrefix);\n    const to = edge.to;\n    const toNode = shape(nodeMap.get(to), idPrefix);\n    const input = edge.in;\n    const output = edge.out;\n    const optional = edge.optional;\n    const constant = edge.constant;\n    if (output === \"*\") {\n        return `${fromNode} -- all --> ${toNode}`;\n    }\n    if (output && input) {\n        if (optional)\n            return `${fromNode} -. \"${output}->${input}\" .-> ${toNode}`;\n        if (constant)\n            return `${fromNode} -- \"${output}->${input}\" --o ${toNode}`;\n        return `${fromNode} -- \"${output}->${input}\" --> ${toNode}`;\n    }\n    return `${fromNode} --> ${toNode}`;\n};\nclass MermaidGenerator {\n    nodeMap;\n    edges;\n    nodes;\n    idPrefix;\n    subgraphs;\n    constructor(graph, idPrefix = \"\") {\n        const { edges, nodes } = graph;\n        this.nodeMap = new Map(nodes.map((node) => [node.id, node]));\n        this.edges = edges;\n        this.nodes = nodes;\n        this.idPrefix = idPrefix;\n        this.subgraphs = graph.graphs || {};\n    }\n    handleSlotted(fromNode, idPrefix) {\n        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n        const type = fromNode.type;\n        if (type !== \"include\")\n            return \"\";\n        const slotted = fromNode.configuration?.slotted;\n        if (!slotted)\n            return \"\";\n        const subgraphs = Object.entries(slotted).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, \"slotted\", fromNode, `${prefix}${fromNode.id}`));\n        return subgraphs.join(\"\\n\");\n    }\n    handleLambda(fromNode, idPrefix) {\n        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n        const board = fromNode.configuration?.board;\n        if (!board)\n            return \"\";\n        const capability = board;\n        if (capability.kind !== \"board\")\n            return \"\";\n        const graph = capability.board;\n        return this.describeSubgraph(graph, fromNode.id, \"lamdba\", fromNode, `${prefix}${fromNode.id}`);\n    }\n    describeSubgraphs(edge, idPrefix = \"\") {\n        const fromNode = this.nodeMap.get(edge.from);\n        if (!fromNode)\n            return \"\";\n        const lamdba = this.handleLambda(fromNode, idPrefix);\n        const slotted = this.handleSlotted(fromNode, idPrefix);\n        return `${slotted}${lamdba}`;\n    }\n    describeSubgraph(subgraph, name, edgeName, fromNode, idPrefix) {\n        const subgraphGenerator = new MermaidGenerator(subgraph, idPrefix);\n        const edges = subgraphGenerator.describeGraph();\n        const prefix = this.idPrefix ? `${properNodeId(this.idPrefix)}_` : \"\";\n        const subgraphEdge = edgeName && fromNode\n            ? `sg_${properNodeId(name)}:::slotted -- \"${edgeName}->${edgeName}\" --o ${prefix}${properNodeId(fromNode.id)}\\n`\n            : \"\";\n        return `\\nsubgraph sg_${properNodeId(name)} [${name}]\\n${edges}\\nend\\n${subgraphEdge}`;\n    }\n    describeGraph(ignoreSubgraphs = false) {\n        const result = this.edges.map((edge) => {\n            const mermEdge = describeEdge(edge, this.nodeMap, this.idPrefix);\n            const mermSubgraphs = ignoreSubgraphs\n                ? \"\"\n                : this.describeSubgraphs(edge, this.idPrefix);\n            return `${mermEdge}${mermSubgraphs}`;\n        });\n        const subgraphs = ignoreSubgraphs\n            ? \"\"\n            : Object.entries(this.subgraphs).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, undefined, undefined, `${name}${this.idPrefix}`));\n        return [...result, ...subgraphs].join(\"\\n\");\n    }\n}\nexport const toMermaid = (graph, direction = \"TD\", unstyled = false, ignoreSubgraphs = false) => {\n    const generator = new MermaidGenerator(graph);\n    const edges = generator.describeGraph(ignoreSubgraphs);\n    return unstyled\n        ? unstyledTemplate(edges, direction)\n        : template(edges, direction);\n};\n//# sourceMappingURL=mermaid.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { InputStageResult } from \"./run.js\";\nexport const createErrorMessage = (inputName, metadata = {}, required) => {\n    const boardTitle = metadata.title ?? metadata?.url;\n    const requiredText = required ? \"required \" : \"\";\n    return `Missing ${requiredText}input \"${inputName}\"${boardTitle ? ` for board \"${boardTitle}\".` : \".\"}`;\n};\nexport const bubbleUpInputsIfNeeded = async (metadata, context, descriptor, result) => {\n    // If we have no way to bubble up inputs, we just return and not\n    // enforce required inputs.\n    if (!context.requestInput)\n        return;\n    const outputs = (await result.outputsPromise) ?? {};\n    const reader = new InputSchemaReader(outputs, result.inputs);\n    result.outputsPromise = reader.read(createBubbleHandler(metadata, context, descriptor));\n};\nexport const createBubbleHandler = (metadata, context, descriptor) => {\n    return (async (name, schema, required) => {\n        if (required) {\n            throw new Error(createErrorMessage(name, metadata, required));\n        }\n        if (schema.default !== undefined) {\n            if (\"type\" in schema && schema.type !== \"string\") {\n                return JSON.parse(schema.default);\n            }\n            return schema.default;\n        }\n        const value = await context.requestInput?.(name, schema, descriptor);\n        if (value === undefined) {\n            throw new Error(createErrorMessage(name, metadata, required));\n        }\n        return value;\n    });\n};\nexport class InputSchemaReader {\n    #currentOutputs;\n    #inputs;\n    constructor(currentOutputs, inputs) {\n        this.#currentOutputs = currentOutputs;\n        this.#inputs = inputs;\n    }\n    async read(handler) {\n        if (!(\"schema\" in this.#inputs))\n            return this.#currentOutputs;\n        const schema = this.#inputs.schema;\n        if (!schema.properties)\n            return this.#currentOutputs;\n        const entries = Object.entries(schema.properties);\n        const newOutputs = {};\n        for (const [name, property] of entries) {\n            if (name in this.#currentOutputs) {\n                newOutputs[name] = this.#currentOutputs[name];\n                continue;\n            }\n            const required = schema.required?.includes(name) ?? false;\n            const value = await handler(name, property, required);\n            newOutputs[name] = value;\n        }\n        return {\n            ...this.#currentOutputs,\n            ...newOutputs,\n        };\n    }\n}\nexport class RequestedInputsManager {\n    #context;\n    #cache = new Map();\n    constructor(context) {\n        this.#context = context;\n    }\n    createHandler(next, result) {\n        return async (name, schema, node) => {\n            const cachedValue = this.#cache.get(name);\n            if (cachedValue !== undefined)\n                return cachedValue;\n            const descriptor = { id: node.id, type: node.type };\n            const requestInputResult = {\n                ...result,\n                descriptor,\n                inputs: {\n                    schema: { type: \"object\", properties: { [name]: schema } },\n                },\n            };\n            //console.log(\"requestInputResult\", requestInputResult);\n            await next(new InputStageResult(requestInputResult, undefined, -1));\n            const outputs = await requestInputResult.outputsPromise;\n            let value = outputs && outputs[name];\n            if (value === undefined) {\n                value = await this.#context.requestInput?.(name, schema, descriptor);\n            }\n            if (!schema.transient)\n                this.#cache.set(name, value);\n            return value;\n        };\n    }\n}\n//# sourceMappingURL=bubble.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// only here for historical purposes. Use asyncGen instead.\n// Remove this when we're sure we don't need it anymore.\nexport const asyncGenOld = (callback) => {\n    let proceedToNext;\n    let nextCalled;\n    let nextThrew;\n    const next = async (result) => {\n        nextCalled(result);\n        return new Promise((resolve) => {\n            proceedToNext = resolve;\n        });\n    };\n    return {\n        [Symbol.asyncIterator]() {\n            let waitForCallbackToCallNext;\n            let done = false;\n            const resolver = (resolve, reject) => {\n                nextCalled = resolve;\n                nextThrew = reject;\n            };\n            waitForCallbackToCallNext = new Promise(resolver);\n            proceedToNext = () => {\n                callback(next)\n                    .then(() => {\n                    done = true;\n                    nextCalled(undefined);\n                })\n                    .catch((err) => {\n                    nextThrew(err);\n                });\n            };\n            return {\n                async next() {\n                    proceedToNext && proceedToNext();\n                    const value = await waitForCallbackToCallNext;\n                    waitForCallbackToCallNext = new Promise(resolver);\n                    return { done, value };\n                },\n            };\n        },\n    };\n};\nconst noop = () => {\n    /* noop */\n};\nclass AsyncGenQueue {\n    #queue = [];\n    #wroteIntoQueue = noop;\n    #whenQueuedUp;\n    #lastReceipt;\n    abort = noop;\n    constructor() {\n        this.#setQueuePromise();\n    }\n    #setQueuePromise() {\n        this.#whenQueuedUp = new Promise((resolve, reject) => {\n            this.#wroteIntoQueue = resolve;\n            this.abort = reject;\n        });\n    }\n    #addToQueue(entry) {\n        this.#queue.push(entry);\n        if (this.#queue.length == 1) {\n            this.#wroteIntoQueue();\n            this.#setQueuePromise();\n        }\n    }\n    async write(value) {\n        return new Promise((receipt) => {\n            this.#addToQueue({ value, receipt });\n        });\n    }\n    async read() {\n        this.#lastReceipt && this.#lastReceipt();\n        if (this.#queue.length === 0) {\n            await this.#whenQueuedUp;\n        }\n        const entry = this.#queue.shift();\n        if (!entry) {\n            throw new Error(\"asyncGen queue should never be empty.\");\n        }\n        this.#lastReceipt = entry.receipt;\n        if (!entry.value) {\n            return { done: true, value: undefined };\n        }\n        return { done: false, value: entry.value };\n    }\n    close() {\n        this.#addToQueue({ value: undefined, receipt: noop });\n    }\n}\nclass AsyncGenIterator {\n    #callback;\n    #firstTime = true;\n    #queue = new AsyncGenQueue();\n    constructor(callback) {\n        this.#callback = callback;\n    }\n    /**\n     * Called by the callback to advance to the next value.\n     * Roughly equivalent to \"yield\":\n     * ```ts\n     * yield value;\n     * ```\n     * same as\n     * ```ts\n     * await next(value);\n     * ```\n     * @param value\n     */\n    async #next(value) {\n        return this.#queue.write(value);\n    }\n    async next() {\n        if (this.#firstTime) {\n            this.#firstTime = false;\n            this.#callback(this.#next.bind(this))\n                .then(() => {\n                this.#queue.close();\n            })\n                .catch((err) => {\n                this.#queue.abort(err);\n            });\n        }\n        return this.#queue.read();\n    }\n}\n/**\n * Converts async/await style code into an async generator.\n * Useful when you need to combine arrow-style functions and yield.\n *\n * Example:\n *\n * ```ts\n * async function* foo() {\n *   yield 1;\n *   yield* asyncGen(async (next) => {\n *     await next(2);\n *     await next(3);\n *   });\n *   yield 4;\n * }\n *\n * for await (const val of foo()) {\n *   console.log(val);\n * }\n * ```\n *\n * This code will print:\n *\n * ```\n * 1\n * 2\n * 3\n * 4\n * ```\n *\n * @param callback A callback that will be called with a `next` function.\n * The callback should call `next` with the next value to yield.\n * @returns An async generator.\n */\nexport const asyncGen = (callback) => {\n    return {\n        [Symbol.asyncIterator]() {\n            return new AsyncGenIterator(callback);\n        },\n    };\n};\n//# sourceMappingURL=async-gen.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { loadRunnerState, saveRunnerState } from \"./serialization.js\";\n// TODO: Support stream serialization somehow.\n// see https://github.com/breadboard-ai/breadboard/issues/423\nexport class StackManager {\n    #stack;\n    #result;\n    constructor(stack) {\n        this.#stack = structuredClone(stack) || [];\n    }\n    onGraphStart() {\n        this.#stack.push({ graph: 0, node: 0 });\n    }\n    onNodeStart(result) {\n        this.#stack[this.#stack.length - 1].node++;\n        this.#result = result;\n    }\n    onNodeEnd() {\n        // TODO: implement\n    }\n    onGraphEnd() {\n        // TODO: implement\n    }\n    async state() {\n        // Assemble the stack from existing pieces.\n        const stack = structuredClone(this.#stack);\n        if (this.#result) {\n            stack[stack.length - 1].state = await saveRunnerState(\"nodestart\", this.#result);\n        }\n        return stack;\n    }\n}\nexport const traversalResultFromStack = (stack) => {\n    const { state } = stack[stack.length - 1];\n    return state ? loadRunnerState(state).state : undefined;\n};\n//# sourceMappingURL=stack.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachine } from \"./traversal/machine.js\";\nimport { InputStageResult, OutputStageResult } from \"./run.js\";\nimport { BoardLoader } from \"./loader.js\";\nimport { runRemote } from \"./remote.js\";\nimport { callHandler, handlersFromKits } from \"./handler.js\";\nimport { toMermaid } from \"./mermaid.js\";\nimport { SchemaBuilder } from \"./schema.js\";\nimport { RequestedInputsManager, bubbleUpInputsIfNeeded } from \"./bubble.js\";\nimport { asyncGen } from \"./utils/async-gen.js\";\nimport { StackManager } from \"./stack.js\";\nimport { timestamp } from \"./timestamp.js\";\nimport breadboardSchema from \"@google-labs/breadboard-schema/breadboard.schema.json\" assert { type: \"json\" };\n/**\n * This class is the main entry point for running a board.\n *\n * It contains everything that is needed to run a board, either loaded from a\n * serialized board or created via the {Board} class.\n *\n * See the {Board} class for a way to build a board that can also be serialized.\n */\nexport class BoardRunner {\n    // GraphDescriptor implementation.\n    url;\n    title;\n    description;\n    $schema;\n    version;\n    edges = [];\n    nodes = [];\n    kits = [];\n    graphs;\n    args;\n    #slots = {};\n    #validators = [];\n    /**\n     * The parent board, if this is board is a subgraph of a larger board.\n     */\n    #outerGraph;\n    /**\n     *\n     * @param metadata - optional metadata for the board. Use this parameter\n     * to provide title, description, version, and URL for the board.\n     */\n    constructor({ url, title, description, version, $schema } = {\n        $schema: breadboardSchema.$id,\n    }) {\n        Object.assign(this, {\n            $schema: $schema ?? breadboardSchema.$id,\n            url,\n            title,\n            description,\n            version,\n        });\n    }\n    /**\n     * Runs the board. This method is an async generator that\n     * yields the results of each stage of the run.\n     *\n     * Conceptually, when we ask the board to run, it will occasionally pause\n     * and give us a chance to interact with it.\n     *\n     * It's typically used like this:\n     *\n     * ```js\n     * for await (const stop of board.run()) {\n     * // do something with `stop`\n     * }\n     * ```\n     *\n     * The `stop` iterator result will be a `RunResult` and provide ability\n     * to influence running of the board.\n     *\n     * The two key use cases are providing input and receiving output.\n     *\n     * If `stop.type` is `input`, the board is waiting for input values.\n     * When that is the case, use `stop.inputs` to provide input values.\n     *\n     * If `stop.type` is `output`, the board is providing output values.\n     * When that is the case, use `stop.outputs` to receive output values.\n     *\n     * See [Chapter 8: Continuous runs](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-8-continuous-runs) of Breadboard tutorial for an example of how to use this method.\n     *\n     * @param probe - an optional probe. If provided, the board will dispatch\n     * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.\n     * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.\n     * @param result - an optional result of a previous run. If provided, the\n     * board will resume from the state of the previous run.\n     * @param kits - an optional map of kits to use when running the board.\n     */\n    async *run(context = {}, result) {\n        const base = context.base || new URL(this.url || \"\", import.meta.url);\n        yield* asyncGen(async (next) => {\n            const { probe } = context;\n            const handlers = await BoardRunner.handlersFromBoard(this, context.kits);\n            const slots = { ...this.#slots, ...context.slots };\n            this.#validators.forEach((validator) => validator.addGraph(this));\n            const machine = new TraversalMachine(this, result?.state);\n            const requestedInputs = new RequestedInputsManager(context);\n            const invocationPath = context.invocationPath || [];\n            const stack = new StackManager(context.state);\n            await probe?.report?.({\n                type: \"graphstart\",\n                data: { metadata: this, path: invocationPath, timestamp: timestamp() },\n            });\n            let invocationId = 0;\n            stack.onGraphStart();\n            const path = () => [...invocationPath, invocationId];\n            for await (const result of machine) {\n                invocationId++;\n                const { inputs, descriptor, missingInputs } = result;\n                if (result.skip) {\n                    await probe?.report?.({\n                        type: \"skip\",\n                        data: {\n                            node: descriptor,\n                            inputs,\n                            missingInputs,\n                            path: path(),\n                            timestamp: timestamp(),\n                        },\n                    });\n                    continue;\n                }\n                stack.onNodeStart(result);\n                await probe?.report?.({\n                    type: \"nodestart\",\n                    data: {\n                        node: descriptor,\n                        inputs,\n                        path: path(),\n                        timestamp: timestamp(),\n                    },\n                    state: await stack.state(),\n                });\n                let outputsPromise = undefined;\n                if (descriptor.type === \"input\") {\n                    await next(new InputStageResult(result, await stack.state(), invocationId));\n                    await bubbleUpInputsIfNeeded(this, context, descriptor, result);\n                    outputsPromise = result.outputsPromise;\n                }\n                else if (descriptor.type === \"output\") {\n                    await next(new OutputStageResult(result, invocationId));\n                    outputsPromise = result.outputsPromise;\n                }\n                else {\n                    const handler = handlers[descriptor.type];\n                    if (!handler)\n                        throw new Error(`No handler for node type \"${descriptor.type}\"`);\n                    const newContext = {\n                        ...context,\n                        board: this,\n                        descriptor,\n                        outerGraph: this.#outerGraph || this,\n                        base,\n                        slots,\n                        kits: [...(context.kits || []), ...this.kits],\n                        requestInput: requestedInputs.createHandler(next, result),\n                        invocationPath: path(),\n                        state: await stack.state(),\n                    };\n                    outputsPromise = callHandler(handler, inputs, newContext);\n                }\n                stack.onNodeEnd();\n                await probe?.report?.({\n                    type: \"nodeend\",\n                    data: {\n                        node: descriptor,\n                        inputs,\n                        outputs: (await outputsPromise),\n                        validatorMetadata: this.#validators.map((validator) => validator.getValidatorMetadata(descriptor)),\n                        path: path(),\n                        timestamp: timestamp(),\n                    },\n                });\n                result.outputsPromise = outputsPromise;\n            }\n            stack.onGraphEnd();\n            await probe?.report?.({\n                type: \"graphend\",\n                data: { metadata: this, path: invocationPath, timestamp: timestamp() },\n            });\n        });\n    }\n    get validators() {\n        return this.#validators;\n    }\n    /**\n     * A simplified version of `run` that runs the board until the board provides\n     * an output, and returns that output.\n     *\n     * This is useful for running boards that don't have multiple outputs\n     * or the the outputs are only expected to be visited once.\n     *\n     * @param inputs - the input values to provide to the board.\n     * @param probe - an optional probe. If provided, the board will dispatch\n     * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.\n     * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.\n     * @param kits - an optional map of kits to use when running the board.\n     * @returns - outputs provided by the board.\n     */\n    async runOnce(inputs, context = {}) {\n        const args = { ...inputs, ...this.args };\n        const { probe } = context;\n        if (context.board && context.descriptor) {\n            // If called from another node in a parent board, add the parent board's\n            // validators to the board, with the current arguments.\n            for (const validator of context.board.validators)\n                this.addValidator(validator.getSubgraphValidator(context.descriptor, Object.keys(args)));\n        }\n        try {\n            let outputs = {};\n            const path = context.invocationPath || [];\n            for await (const result of this.run(context)) {\n                if (result.type === \"input\") {\n                    // Pass the inputs to the board. If there are inputs bound to the\n                    // board (e.g. from a lambda node that had incoming wires), they will\n                    // overwrite supplied inputs.\n                    result.inputs = args;\n                }\n                else if (result.type === \"output\") {\n                    outputs = result.outputs;\n                    // Exit once we receive the first output.\n                    await probe?.report?.({\n                        type: \"nodeend\",\n                        data: {\n                            node: result.node,\n                            inputs: result.inputs,\n                            outputs,\n                            path: [...path, result.invocationId],\n                            timestamp: timestamp(),\n                        },\n                    });\n                    await probe?.report?.({\n                        type: \"graphend\",\n                        data: { metadata: this, path, timestamp: timestamp() },\n                    });\n                    break;\n                }\n            }\n            return outputs;\n        }\n        catch (e) {\n            // Unwrap unhandled error (handled errors are just outputs of the board!)\n            if (e.cause)\n                return { $error: e.cause };\n            else\n                throw e;\n        }\n    }\n    /**\n     * Add validator to the board.\n     * Will call .addGraph() on the validator before executing a graph.\n     *\n     * @param validator - a validator to add to the board.\n     */\n    addValidator(validator) {\n        this.#validators.push(validator);\n    }\n    /**\n     * Returns a [Mermaid](https://mermaid-js.github.io/mermaid/#/) representation\n     * of the board.\n     *\n     * This is useful for visualizing the board.\n     *\n     * @returns - a string containing the Mermaid representation of the board.\n     */\n    mermaid(direction = \"TD\", unstyled = false, ignoreSubgraphs = false) {\n        return toMermaid(this, direction, unstyled, ignoreSubgraphs);\n    }\n    /**\n     * Creates a new board from JSON. If you have a serialized board, you can\n     * use this method to turn it into into a new Board instance.\n     *\n     * @param graph - the JSON representation of the board.\n     * @returns - a new `Board` instance.\n     */\n    static async fromGraphDescriptor(graph) {\n        const breadboard = new BoardRunner(graph);\n        breadboard.edges = graph.edges;\n        breadboard.nodes = graph.nodes;\n        breadboard.graphs = graph.graphs;\n        breadboard.args = graph.args;\n        return breadboard;\n    }\n    /**\n     * Loads a board from a URL or a file path.\n     *\n     * @param url - the URL or a file path to the board.\n     * @param slots - optional slots to provide to the board.\n     * @returns - a new `Board` instance.\n     */\n    static async load(url, options) {\n        const { base, slotted, outerGraph } = options || {};\n        const loader = new BoardLoader({\n            base,\n            graphs: outerGraph?.graphs,\n        });\n        const { isSubgraph, graph } = await loader.load(url);\n        const board = await BoardRunner.fromGraphDescriptor(graph);\n        if (isSubgraph)\n            board.#outerGraph = outerGraph;\n        board.#slots = slotted || {};\n        return board;\n    }\n    /**\n     * Creates a runnable board from a BreadboardCapability,\n     * @param board {BreadboardCapability} A BreadboardCapability including a board\n     * @returns {Board} A runnable board.\n     */\n    static async fromBreadboardCapability(board) {\n        if (board.kind !== \"board\" || !board.board) {\n            throw new Error(`Expected a \"board\" Capability, but got ${board}`);\n        }\n        // TODO: Use JSON schema to validate rather than this hack.\n        const boardish = board.board;\n        if (!(boardish.edges && boardish.kits && boardish.nodes)) {\n            throw new Error('Supplied \"board\" Capability argument is not actually a board');\n        }\n        // If all we got is a GraphDescriptor, build a runnable board from it.\n        // TODO: Use JSON schema to validate rather than this hack.\n        let runnableBoard = board.board;\n        if (!runnableBoard.runOnce) {\n            runnableBoard = await BoardRunner.fromGraphDescriptor(boardish);\n        }\n        return runnableBoard;\n    }\n    static async handlersFromBoard(board, upstreamKits = []) {\n        const core = new Core();\n        const kits = [core, ...upstreamKits, ...board.kits];\n        return handlersFromKits(kits);\n    }\n    static runRemote = runRemote;\n}\n// HACK: Move the Core and Lambda logic into the same file as the BoardRunner to remove the cyclic module dependency (Lambda needs BoardRunner, BoardRunner needs Core).\nclass Core {\n    handlers;\n    constructor() {\n        this.handlers = {\n            lambda: {\n                describe: async (inputs) => ({\n                    inputSchema: new SchemaBuilder()\n                        .setAdditionalProperties(true)\n                        .addInputs(inputs)\n                        .addProperty(\"board\", {\n                        title: \"board\",\n                        description: \"The board to run.\",\n                        type: \"object\",\n                    })\n                        .build(),\n                    outputSchema: new SchemaBuilder()\n                        .addProperty(\"board\", {\n                        title: \"board\",\n                        description: \"The now-runnable board.\",\n                        type: \"object\",\n                    })\n                        .build(),\n                }),\n                invoke: async (inputs) => {\n                    const { board, ...args } = inputs;\n                    if (!board || board.kind !== \"board\" || !board.board)\n                        throw new Error(`Lambda node requires a BoardCapability as \"board\" input`);\n                    const runnableBoard = {\n                        ...(await BoardRunner.fromBreadboardCapability(board)),\n                        args,\n                    };\n                    return {\n                        board: { ...board, board: runnableBoard },\n                    };\n                },\n            },\n        };\n    }\n}\n//# sourceMappingURL=runner.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { callHandler, handlersFromKits } from \"../handler.js\";\nimport { BoardRunner } from \"../runner.js\";\nexport class GraphToKitAdapter {\n    graph;\n    handlers;\n    runner;\n    constructor(graph) {\n        this.graph = graph;\n    }\n    populateDescriptor(descriptor) {\n        const { title, description, version } = this.graph;\n        return { title, description, version, ...descriptor };\n    }\n    async #initialize(url, kits = []) {\n        const runner = await BoardRunner.fromGraphDescriptor(this.graph);\n        runner.url = url;\n        // NOTE: This means that this board will _not_ use handlers defined upstream\n        // in the stack of boards to execute to nodes on this graph, but only the\n        // kits defined on this graph.\n        //\n        // Note however that `invoke` nodes will execute subgraphs with handlers\n        // from higher in the stack, so for example a subgraph defined here that\n        // uses `fetch` will use the `fetch` handler from the parent graph before\n        // using the `fetch` handler from kit defined here.\n        //\n        // The comment above applies only to nodes acting as node handler. We\n        // haven't seen this use-case yet for anything that isn't a Core node, so\n        // let's revisit once we have that.\n        this.handlers = kits?.reduce((acc, kit) => {\n            return { ...acc, ...kit.handlers };\n        }, {});\n        this.runner = runner;\n    }\n    handlerForNode(id) {\n        if (!this.graph)\n            throw new Error(`Builder was not yet initialized.`);\n        const { nodes } = this.graph;\n        const node = nodes.find((node) => node.id === id);\n        if (!node)\n            throw new Error(`Node ${id} not found in graph.`);\n        return {\n            invoke: async (inputs, context) => {\n                const configuration = node.configuration;\n                if (configuration) {\n                    inputs = { ...configuration, ...inputs };\n                }\n                const handlers = {\n                    ...this.handlers,\n                    ...handlersFromKits(context?.kits || []),\n                };\n                const handler = handlers?.[node.type];\n                if (!handler)\n                    throw new Error(`No handler found for node \"${node.type}\".`);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const board = this.runner;\n                const base = board.url ? new URL(board.url) : new URL(import.meta.url);\n                console.log(\"KIT HANDLER\", context);\n                return callHandler(handler, inputs, {\n                    ...context,\n                    outerGraph: board,\n                    base,\n                    // Add this board's kits, so they are available to subgraphs\n                    kits: [...(context.kits || []), ...board.kits],\n                });\n            },\n        };\n    }\n    static async create(graph, url, kits) {\n        const adapter = new GraphToKitAdapter(graph);\n        await adapter.#initialize(url, kits);\n        return adapter;\n    }\n}\n//# sourceMappingURL=graph-to-kit.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class KitBuilder {\n    url;\n    title;\n    description;\n    version;\n    namespacePrefix;\n    constructor({ title, description, version, url, namespacePrefix = \"\", }) {\n        this.url = url;\n        this.title = title;\n        this.description = description;\n        this.version = version;\n        this.namespacePrefix = namespacePrefix;\n    }\n    #addPrefix(handlers) {\n        return Object.keys(handlers).reduce((acc, key) => {\n            acc[`${this.namespacePrefix}${key}`] = handlers[key];\n            return acc;\n        }, {});\n    }\n    build(handlers) {\n        if (!this.url)\n            throw new Error(`Builder was not yet initialized.`);\n        const url = this.url;\n        const prefix = this.namespacePrefix;\n        const { title, description, version } = this;\n        const prefixedHandlers = this.#addPrefix(handlers);\n        const nodes = Object.keys(handlers);\n        return class {\n            title = title;\n            description = description;\n            version = version;\n            url = url;\n            get handlers() {\n                return prefixedHandlers;\n            }\n            constructor(nodeFactory) {\n                const proxy = new Proxy(this, {\n                    get(target, prop) {\n                        if (prop === \"handlers\" || prop === \"url\") {\n                            return target[prop];\n                        }\n                        else if (nodes.includes(prop)) {\n                            return (configOrLambda = {}) => {\n                                const config = nodeFactory.getConfigWithLambda(configOrLambda);\n                                const { $id, ...rest } = config;\n                                return nodeFactory.create(proxy, `${prefix}${prop}`, { ...rest }, $id);\n                            };\n                        }\n                    },\n                });\n                return proxy;\n            }\n        };\n    }\n    static wrap(params, functions) {\n        const createHandler = (previous, current) => {\n            const [name, fn] = current;\n            previous[name] = {\n                invoke: async (inputs) => {\n                    // JS can have rest args, eg. \"...args\" as a parameter at the end of a function, but breadboard cannot accept \".\" so we use \"___\".\n                    let argNames = [];\n                    if (fn && fn.length > 0) {\n                        argNames = fn.toString().match(/\\((.+?)\\)/)?.[1].split(\",\") ?? [];\n                        /*\n                        If fn.length is greater than 1 and argNames.length = 0, then we likely have a system function that accepts a splat of arguments..\n            \n                        e.g Math.max([1,2,3,4])\n            \n                        We need to special case this and pass the arguments as an array and expect `inputs` to have a key of `args` that is an array.\n                        */\n                        if (fn.length > 1 && argNames.length === 0 && \"___args\" in inputs && Array.isArray(inputs[\"___args\"])) {\n                            argNames = [\"___args\"];\n                        }\n                    }\n                    // Validate the input names.\n                    for (const argName of argNames) {\n                        if (argName.trim() in inputs === false) {\n                            throw new Error(`Missing input: ${argName.trim()}. Valid inputs are: ${Object.keys(inputs).join(\", \")}`);\n                        }\n                    }\n                    const args = argNames\n                        .filter(argName => argName.startsWith(\"___\") == false)\n                        .map((argName) => inputs[argName.trim()]);\n                    const lastArgName = argNames[argNames.length - 1];\n                    if (lastArgName != undefined && lastArgName.startsWith(\"___\")) {\n                        // Splat the rest of the arguments.\n                        args.push(...inputs[lastArgName]);\n                    }\n                    const results = await fn(...args);\n                    if (typeof results !== \"object\" || Array.isArray(results)) {\n                        // Number, Boolean, Array, String, will output to `result`.\n                        return { result: results };\n                    }\n                    // Objects will destructured into the output.\n                    return { ...results };\n                }\n            };\n            return previous;\n        };\n        const handlers = Object.entries(functions).reduce(createHandler, {});\n        const builder = new KitBuilder(params);\n        return builder.build(handlers);\n    }\n}\n//# sourceMappingURL=builder.js.map"],"names":["getSchemaType","value","Array","isArray","SchemaBuilder","additionalProperties","required","properties","build","result","type","this","length","setAdditionalProperties","undefined","addInputs","inputs","Object","entries","forEach","name","addProperty","schema","addProperties","addRequired","empty","callHandler","async","handler","context","handlerFunction","Function","invoke","Error","getHandlerFunction","Promise","resolve","then","catch","error","$error","handlersFromKits","kits","reduce","handlers","kit","Traversal","computeMissingInputs","heads","current","requiredInputs","Set","filter","edge","in","optional","map","inputsWithConfiguration","keys","key","add","configuration","input","has","MachineEdgeState","state","Map","constants","queueOutput","node","queuesMap","get","set","queue","push","wireOutputs","opportunites","outputs","opportunity","from","to","out","constant","output","getAvailableInputs","nodeId","useInputs","shift","MachineResult","descriptor","missingInputs","opportunities","newOpportunities","outputsPromise","pendingOutputs","constructor","skip","fromObject","o","edgeState","TraversalMachineIterator","graph","noParallelExecution","processCompletedNode","completedNodeOutput","promiseId","delete","e","cause","globalThis","console","warn","processAllPendingNodes","all","values","next","id","Symbol","promise","kind","size","race","done","nodes","tails","toNode","currentDescriptor","incomingEdges","GraphRepresentation","edges","acc","TraversalMachine","previousResult","asyncIterator","start","entry","entryResult","prepareToSave","replacer","$type","reviver","saveRunnerState","JSON","stringify","timestamp","performance","now","RunResult","runState","invocationId","inputArguments","save","isAtExitNode","load","stringifiedResult","s","parse","loadRunnerState","InputStageResult","super","OutputStageResult","resolveURL","base","urlString","results","url","URL","hash","href","path","protocol","decodeURIComponent","pathname","baseWithoutHash","replace","hrefWithoutHash","location","substring","loadFromFile","process","readFileFn","require","readFile","import","loadWithFetch","response","fetch","json","BoardLoadingStep","loaders","graphs","file","unknown","BoardLoader","subgraphs","isSubgraph","step","ReadableStream","prototype","reader","getReader","read","releaseLock","BoardStreamer","writable","readable","controller","WritableStream","write","chunk","TextDecoder","decode","split","line","trim","close","data","enqueue","post","method","headers","body","pipeThrough","runRemote","stream","properNodeId","shape","idPrefix","nodeType","text","MermaidGenerator","nodeMap","handleSlotted","fromNode","prefix","slotted","subgraph","describeSubgraph","join","handleLambda","board","capability","describeSubgraphs","lamdba","edgeName","describeGraph","subgraphEdge","ignoreSubgraphs","mermEdge","describeEdge","createErrorMessage","inputName","metadata","boardTitle","title","bubbleUpInputsIfNeeded","requestInput","InputSchemaReader","createBubbleHandler","default","currentOutputs","newOutputs","property","includes","RequestedInputsManager","cache","createHandler","cachedValue","requestInputResult","transient","noop","AsyncGenQueue","wroteIntoQueue","whenQueuedUp","lastReceipt","abort","setQueuePromise","reject","addToQueue","receipt","AsyncGenIterator","callback","firstTime","bind","err","StackManager","stack","structuredClone","onGraphStart","onNodeStart","onNodeEnd","onGraphEnd","BoardRunner","description","$schema","version","args","slots","validators","outerGraph","breadboardSchema","assign","run","probe","handlersFromBoard","validator","addGraph","machine","requestedInputs","invocationPath","report","newContext","validatorMetadata","getValidatorMetadata","runOnce","addValidator","getSubgraphValidator","mermaid","direction","unstyled","unstyledTemplate","template","toMermaid","fromGraphDescriptor","breadboard","options","loader","fromBreadboardCapability","boardish","runnableBoard","upstreamKits","Core","static","lambda","describe","inputSchema","outputSchema","GraphToKitAdapter","runner","populateDescriptor","initialize","handlerForNode","find","log","create","adapter","KitBuilder","namespacePrefix","addPrefix","prefixedHandlers","nodeFactory","proxy","Proxy","target","prop","configOrLambda","config","getConfigWithLambda","$id","rest","wrap","params","functions","previous","fn","argNames","toString","match","argName","startsWith","lastArgName"],"mappings":"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"}