/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const t=t=>null==t?"null":Array.isArray(t)?"array":typeof t;class e{additionalProperties=!1;required=[];properties={};build(){const t={type:"object",properties:this.properties,additionalProperties:this.additionalProperties};return this.required.length>0&&(t.required=this.required),t}setAdditionalProperties(t){return void 0!==t&&(this.additionalProperties=t),this}addInputs(e){return e?(Object.entries(e).forEach((([e,r])=>{this.addProperty(e,{type:t(r)})})),this):this}addProperty(t,e){return this.properties[t]=e,this}addProperties(t){return Object.entries(t).forEach((([t,e])=>{this.addProperty(t,e)})),this}addRequired(t){return t?("string"==typeof t?this.required=[...this.required,t]:Array.isArray(t)&&t.length>0&&(this.required=[...this.required,...t]),this):this}static empty(t=!1){return(new e).setAdditionalProperties(t).build()}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const r=async(t,e,r)=>{const s=(t=>{if(t instanceof Function)return t;if(t.invoke)return t.invoke;throw new Error("Invalid handler")})(t);return new Promise((t=>{s(e,r).then(t).catch((e=>{t({$error:{error:e}})}))}))},s=t=>t.reduce(((t,e)=>({...e.handlers,...t})),{});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class i{static computeMissingInputs(t,e,r){const s=[...new Set(t.filter((t=>!!t.in&&!t.optional)).map((t=>t.in||"")))],i=new Set;return Object.keys(e).forEach((t=>i.add(t))),r.configuration&&Object.keys(r.configuration).forEach((t=>i.add(t))),s.filter((t=>!i.has(t)))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class n{state=new Map;constants=new Map;#t(t,e,r,s){let i=t.get(e);i||(i=new Map,t.set(e,i));let n=i.get(r);n||(n=[],i.set(r,n)),n.push(s)}wireOutputs(t,e){if(0!==t.filter((e=>e.from!=t[0].from)).length)throw new Error("All opportunities must be from the same node");t.forEach((t=>{const r=t.to,s=t.out,i=t.constant?this.constants:this.state;if(s)if("*"===s)for(const t in e){const s=e[t];null!=s&&null!=s&&this.#t(i,r,t,s)}else if(t.in){const n=e[s];null!=n&&null!=n&&this.#t(i,r,t.in,n)}}))}getAvailableInputs(t){const e={};for(const r of[this.constants.get(t),this.state.get(t)])if(r)for(const[t,s]of r.entries())0!==s.length&&(e[t]=s[0]);return e}useInputs(t,e){const r=this.state.get(t);if(r)for(const t in e){const e=r.get(t);e&&e.shift()}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class o{descriptor;inputs;missingInputs;opportunities;newOpportunities;state;outputsPromise;pendingOutputs;constructor(t,e,r,s,i,n,o){this.descriptor=t,this.inputs=e,this.missingInputs=r,this.opportunities=s,this.newOpportunities=i,this.state=n,this.pendingOutputs=o}get skip(){return this.missingInputs.length>0}static fromObject(t){const e=new n;return e.constants=t.state.constants,e.state=t.state.state,new o(t.descriptor,t.inputs,t.missingInputs,t.opportunities,t.newOpportunities,e,t.pendingOutputs)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class a{graph;#e;#r;constructor(t,e,r=!0){this.graph=t,this.#e=e,this.#r=r}static#s(t,e){const{promiseId:r,outputs:s,newOpportunities:i}=e;t.pendingOutputs.delete(r);const n=s.$error?i.filter((t=>"$error"===t.out)):i;if(t.opportunities.push(...n),t.state.wireOutputs(n,s),s.$error){if(0===n.length)throw new Error("Uncaught exception in node handler. Catch by wiring up the $error output.",{cause:s.$error});globalThis.console.warn("Error in node handler, passing to the wired $error output.",s.$error,n)}}static async processAllPendingNodes(t){return(await Promise.all(t.pendingOutputs.values())).forEach((e=>{a.#s(t,e)})),t}async next(){if(!this.#e.skip){const{inputs:t,outputsPromise:e,newOpportunities:r,descriptor:s}=this.#e;this.#e.state.useInputs(s.id,this.#e.inputs);const i=Symbol(),n=new Promise((n=>{(e||Promise.resolve({})).then((e=>{if(e.$error){const r=e.$error;e.$error={descriptor:s,...r,inputs:{...t,...r.inputs}}}n({promiseId:i,outputs:e,newOpportunities:r})})).catch((e=>{n({promiseId:i,outputs:{$error:{kind:"error",error:e,inputs:t,descriptor:s}},newOpportunities:r.filter((t=>"$error"===t.out))})}))}));this.#e.pendingOutputs.set(i,n)}for(;(0===this.#e.opportunities.length||this.#r)&&this.#e.pendingOutputs.size>0;)a.#s(this.#e,await Promise.race(this.#e.pendingOutputs.values()));if(0===this.#e.opportunities.length)return{done:!0,value:null};const t=this.#e.opportunities.shift(),{heads:e,nodes:r,tails:s}=this.graph,n=t.to,u=r.get(n);if(!u)throw new Error(`No node found for id "${n}"`);const c=e.get(n)||[],p=this.#e.state.getAvailableInputs(n),h=i.computeMissingInputs(c,p,u),d=s.get(n)||[],l={...u.configuration,...p};return this.#e=new o(u,l,h,this.#e.opportunities,d,this.#e.state,this.#e.pendingOutputs),{done:!1,value:this.#e}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class u{tails=new Map;heads=new Map;nodes=new Map;entries=[];constructor(t){this.tails=t.edges.reduce(((t,e)=>{const r=e.from;return t.has(r)?t.get(r)?.push(e):t.set(r,[e]),t}),new Map),this.heads=t.edges.reduce(((t,e)=>{const r=e.to;return t.has(r)?t.get(r)?.push(e):t.set(r,[e]),t}),new Map),this.nodes=t.nodes.reduce(((t,e)=>(t.set(e.id,e),t)),new Map),this.entries=Array.from(this.tails.keys()).filter((t=>!this.heads.has(t)||0===this.heads.get(t)?.length))}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class c{graph;previousResult;constructor(t,e){this.graph=new u(t),this.previousResult=e}[Symbol.asyncIterator](){return this.start()}start(){if(this.previousResult)return new a(this.graph,this.previousResult);const{entries:t}=this.graph;if(0===t.length)throw new Error("No entry node found in graph.");const e=t.map((t=>({from:"$entry",to:t}))),r=new o({id:"$empty",type:"$empty"},{},[],e,[],new n,new Map);return new a(this.graph,r)}static async prepareToSave(t){return await a.processAllPendingNodes(t)}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const p=(t,e)=>e instanceof Map?{$type:"Map",value:Array.from(e.entries())}:e,h=(t,e)=>{const{$type:r}=e||{};return"Map"==r&&e.value?new Map(e.value):e},d=async(t,e)=>{const r=await c.prepareToSave(e);return JSON.stringify({state:r,type:t},p)},l=()=>globalThis.performance.now()
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */;class f{#i;#n;#o;#a;constructor(t,e,r,s){this.#n=t,this.#i=e,this.#o=r,this.#a=s}get invocationId(){return this.#a}get type(){return this.#i}get node(){return this.#n.descriptor}get inputArguments(){return this.#n.inputs}set inputs(t){this.#n.outputsPromise=Promise.resolve(t)}get outputs(){return this.#n.inputs}get state(){return this.#n}async save(){return d(this.#i,this.#n)}get runState(){return this.#o}get timestamp(){return l()}isAtExitNode(){return 0===this.#n.newOpportunities.length&&0===this.#n.opportunities.length&&0===this.#n.pendingOutputs.size}static load(t){const{state:e,type:r}=(t=>{const{state:e,type:r}=JSON.parse(t,h);return{state:o.fromObject(e),type:r}})(t);return new f(e,r,void 0,0)}}class g extends f{constructor(t,e,r){super(t,"input",e,r)}get outputs(){throw new Error('Outputs are not available in the "input" stage')}}class w extends f{constructor(t,e){super(t,"output",void 0,e)}get inputArguments(){throw new Error('Input arguments are not available in the "output" stage')}set inputs(t){throw new Error('Setting inputs is not available in the "output" stage')}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const b=(t,e,r)=>{const s=new URL(e,t),i=s.hash,n=s.href,o="file:"===s.protocol?decodeURIComponent(s.pathname):void 0,a=t.href.replace(t.hash,""),u=n.replace(i,"");if(a==u&&i)return r.push({type:"hash",location:i.substring(1),href:n}),!0;const c=o?{type:"file",location:o,href:n}:n?{type:"fetch",location:u,href:n}:{type:"unknown",location:"",href:n};return r.push(c),!i},y=async t=>{if(void 0===globalThis.process)throw new Error("Unable to use `path` when not running in node");let e;if("function"==typeof require){const{readFile:t}=require("node:fs/promises");e=t}else{const{readFile:t}=await import("node:fs/promises");e=t}return JSON.parse(await e(t,"utf-8"))},m=async t=>{const e=await fetch(t);return await e.json()};class ${loaders;graphs;constructor(t){this.loaders={file:y,fetch:m,hash:async e=>{if(!t)throw new Error("No sub-graphs to load from");return t[e]},unknown:async()=>{throw new Error("Unable to determine Board loader type")}}}async load(t){const e=await this.loaders[t.type](t.location);return e.url=t.href,e}}class v{#u;#c;constructor({base:t,graphs:e}){this.#u=t,this.#c=e}async load(t){const e=[];let r,s=this.#u;for(;!b(s,t,e);)s=new URL(e[e.length-1].href);let i=this.#c,n=!0;for(const t of e){"file"!==t.type&&"fetch"!==t.type||(n=!1);const e=new $(i);r=await e.load(t),i=r.graphs}if(!r)throw new Error("BoardLoader failed to load a graph. This error likely indicates a bug in the BoardLoader.");return{graph:r,isSubgraph:n}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ReadableStream.prototype[Symbol.asyncIterator]||(ReadableStream.prototype[Symbol.asyncIterator]=async function*(){const t=this.getReader();try{for(;;){const{done:e,value:r}=await t.read();if(e)return;yield r}}finally{t.releaseLock()}});class P{writable;readable;controller=null;constructor(){this.writable=new WritableStream({write:t=>this.write(t)}),this.readable=new ReadableStream({start:t=>{this.controller=t}})}write(t){(new TextDecoder).decode(t).split("\n").map((t=>t.trim())).filter((t=>t.length>0)).forEach((t=>{try{if("stop"===t)return void this.controller?.close();const e=JSON.parse(t);this.controller?.enqueue(e)}catch(t){console.error(t)}}))}}const k=async(t,e,r)=>{const s=await fetch(t,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({inputs:e,state:r})});return s.body?.pipeThrough(new P)};async function*O(t){let e,r;for(;;){const s=await k(t,e,r);if(!s)break;for await(const t of s)r=JSON.stringify(t.state),yield t,e=t.inputs;if(!r)break}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const S=t=>t&&t.replace(/-/g,""),E=(t,e="")=>{if(!t)return"";const r=t.id,s=`${e?`${S(e)}_`:""}${S(r)}`,i=t.type,n=`"${i} <br> id='${r}'"`;switch(i){case"include":return`${s}[[${n}]]:::include`;case"slot":return`${s}((${n})):::slot`;case"passthrough":return`${s}((${n})):::passthrough`;case"input":return`${s}[/${n}/]:::input`;case"secrets":return`${s}(${n}):::secrets`;case"output":return`${s}{{${n}}}:::output`;default:return`${s}[${n}]`}};class I{nodeMap;edges;nodes;idPrefix;subgraphs;constructor(t,e=""){const{edges:r,nodes:s}=t;this.nodeMap=new Map(s.map((t=>[t.id,t]))),this.edges=r,this.nodes=s,this.idPrefix=e,this.subgraphs=t.graphs||{}}handleSlotted(t,e){const r=e?`${S(e)}_`:"";if("include"!==t.type)return"";const s=t.configuration?.slotted;if(!s)return"";return Object.entries(s).map((([e,s])=>this.describeSubgraph(s,e,"slotted",t,`${r}${t.id}`))).join("\n")}handleLambda(t,e){const r=e?`${S(e)}_`:"",s=t.configuration?.board;if(!s)return"";const i=s;if("board"!==i.kind)return"";const n=i.board;return this.describeSubgraph(n,t.id,"lamdba",t,`${r}${t.id}`)}describeSubgraphs(t,e=""){const r=this.nodeMap.get(t.from);if(!r)return"";const s=this.handleLambda(r,e);return`${this.handleSlotted(r,e)}${s}`}describeSubgraph(t,e,r,s,i){const n=new I(t,i).describeGraph(),o=this.idPrefix?`${S(this.idPrefix)}_`:"",a=r&&s?`sg_${S(e)}:::slotted -- "${r}->${r}" --o ${o}${S(s.id)}\n`:"";return`\nsubgraph sg_${S(e)} [${e}]\n${n}\nend\n${a}`}describeGraph(t=!1){return[...this.edges.map((e=>{const r=((t,e,r="")=>{const s=t.from,i=E(e.get(s),r),n=t.to,o=E(e.get(n),r),a=t.in,u=t.out,c=t.optional,p=t.constant;return"*"===u?`${i} -- all --\x3e ${o}`:u&&a?c?`${i} -. "${u}->${a}" .-> ${o}`:p?`${i} -- "${u}->${a}" --o ${o}`:`${i} -- "${u}->${a}" --\x3e ${o}`:`${i} --\x3e ${o}`})(e,this.nodeMap,this.idPrefix);return`${r}${t?"":this.describeSubgraphs(e,this.idPrefix)}`})),...t?"":Object.entries(this.subgraphs).map((([t,e])=>this.describeSubgraph(e,t,void 0,void 0,`${t}${this.idPrefix}`)))].join("\n")}}const x=(t,e={},r)=>{const s=e.title??e?.url;return`Missing ${r?"required ":""}input "${t}"${s?` for board "${s}".`:"."}`},q=async(t,e,r,s)=>{if(!e.requestInput)return;const i=await s.outputsPromise??{},n=new M(i,s.inputs);s.outputsPromise=n.read(j(t,e,r))},j=(t,e,r)=>async(s,i,n)=>{if(n)throw new Error(x(s,t,n));if(void 0!==i.default)return"type"in i&&"string"!==i.type?JSON.parse(i.default):i.default;const o=await(e.requestInput?.(s,i,r));if(void 0===o)throw new Error(x(s,t,n));return o};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class M{#p;#h;constructor(t,e){this.#p=t,this.#h=e}async read(t){if(!("schema"in this.#h))return this.#p;const e=this.#h.schema;if(!e.properties)return this.#p;const r=Object.entries(e.properties),s={};for(const[i,n]of r){if(i in this.#p){s[i]=this.#p[i];continue}const r=e.required?.includes(i)??!1,o=await t(i,n,r);s[i]=o}return{...this.#p,...s}}}class N{#d;#l=new Map;constructor(t){this.#d=t}createHandler(t,e){return async(r,s,i)=>{const n=this.#l.get(r);if(void 0!==n)return n;const o={id:i.id,type:i.type},a={...e,descriptor:o,inputs:{schema:{type:"object",properties:{[r]:s}}}};await t(new g(a,void 0,-1));const u=await a.outputsPromise;let c=u&&u[r];return void 0===c&&(c=await(this.#d.requestInput?.(r,s,o))),s.transient||this.#l.set(r,c),c}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const A=()=>{};class R{#f=[];#g=A;#w;#b;abort=A;constructor(){this.#y()}#y(){this.#w=new Promise(((t,e)=>{this.#g=t,this.abort=e}))}#m(t){this.#f.push(t),1==this.#f.length&&(this.#g(),this.#y())}async write(t){return new Promise((e=>{this.#m({value:t,receipt:e})}))}async read(){this.#b&&this.#b(),0===this.#f.length&&await this.#w;const t=this.#f.shift();if(!t)throw new Error("asyncGen queue should never be empty.");return this.#b=t.receipt,t.value?{done:!1,value:t.value}:{done:!0,value:void 0}}close(){this.#m({value:void 0,receipt:A})}}class T{#$;#v=!0;#f=new R;constructor(t){this.#$=t}async#P(t){return this.#f.write(t)}async next(){return this.#v&&(this.#v=!1,this.#$(this.#P.bind(this)).then((()=>{this.#f.close()})).catch((t=>{this.#f.abort(t)}))),this.#f.read()}}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class _{#k;#O;constructor(t){this.#k=structuredClone(t)||[]}onGraphStart(){this.#k.push({graph:0,node:0})}onNodeStart(t){this.#k[this.#k.length-1].node++,this.#O=t}onNodeEnd(){}onGraphEnd(){}async state(){const t=structuredClone(this.#k);return this.#O&&(t[t.length-1].state=await d("nodestart",this.#O)),t}}var G="https://raw.githubusercontent.com/breadboard-ai/breadboard/@google-labs/breadboard-schema@1.2.0/packages/schema/breadboard.schema.json";
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class D{url;title;description;$schema;version;edges=[];nodes=[];kits=[];graphs;args;#S={};#E=[];#I;constructor({url:t,title:e,description:r,version:s,$schema:i}={$schema:G}){Object.assign(this,{$schema:i??G,url:t,title:e,description:r,version:s})}async*run(t={},e){const s=t.base||new URL(this.url||"",import.meta.url);var i;yield*(i=async i=>{const{probe:n}=t,o=await D.handlersFromBoard(this,t.kits),a={...this.#S,...t.slots};this.#E.forEach((t=>t.addGraph(this)));const u=new c(this,e?.state),p=new N(t),h=t.invocationPath||[],d=new _(t.state);await(n?.report?.({type:"graphstart",data:{metadata:this,path:h,timestamp:l()}}));let f=0;d.onGraphStart();const b=()=>[...h,f];for await(const e of u){f++;const{inputs:u,descriptor:c,missingInputs:h}=e;if(e.skip){await(n?.report?.({type:"skip",data:{node:c,inputs:u,missingInputs:h,path:b(),timestamp:l()}}));continue}let y;if(d.onNodeStart(e),await(n?.report?.({type:"nodestart",data:{node:c,inputs:u,path:b(),timestamp:l()},state:await d.state()})),"input"===c.type)await i(new g(e,await d.state(),f)),await q(this,t,c,e),y=e.outputsPromise;else if("output"===c.type)await i(new w(e,f)),y=e.outputsPromise;else{const n=o[c.type];if(!n)throw new Error(`No handler for node type "${c.type}"`);const h={...t,board:this,descriptor:c,outerGraph:this.#I||this,base:s,slots:a,kits:[...t.kits||[],...this.kits],requestInput:p.createHandler(i,e),invocationPath:b(),state:await d.state()};y=r(n,u,h)}d.onNodeEnd(),await(n?.report?.({type:"nodeend",data:{node:c,inputs:u,outputs:await y,validatorMetadata:this.#E.map((t=>t.getValidatorMetadata(c))),path:b(),timestamp:l()}})),e.outputsPromise=y}d.onGraphEnd(),await(n?.report?.({type:"graphend",data:{metadata:this,path:h,timestamp:l()}}))},{[Symbol.asyncIterator]:()=>new T(i)})}get validators(){return this.#E}async runOnce(t,e={}){const r={...t,...this.args},{probe:s}=e;if(e.board&&e.descriptor)for(const t of e.board.validators)this.addValidator(t.getSubgraphValidator(e.descriptor,Object.keys(r)));try{let t={};const i=e.invocationPath||[];for await(const n of this.run(e))if("input"===n.type)n.inputs=r;else if("output"===n.type){t=n.outputs,await(s?.report?.({type:"nodeend",data:{node:n.node,inputs:n.inputs,outputs:t,path:[...i,n.invocationId],timestamp:l()}})),await(s?.report?.({type:"graphend",data:{metadata:this,path:i,timestamp:l()}}));break}return t}catch(t){if(t.cause)return{$error:t.cause};throw t}}addValidator(t){this.#E.push(t)}mermaid(t="TD",e=!1,r=!1){return((t,e="TD",r=!1,s=!1)=>{const i=new I(t).describeGraph(s);return r?((t,e)=>`graph ${e};\n${t}`)(i,e):((t,e)=>`%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%\ngraph ${e};\n${t}\nclassDef default stroke:#ffab40,fill:#fff2ccff,color:#000\nclassDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000\nclassDef output stroke:#38761d,fill:#b6d7a8ff,color:#000\nclassDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef slot stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef config stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef secrets stroke:#db4437,fill:#f4cccc,color:#000\nclassDef slotted stroke:#a64d79`)(i,e)})(this,t,e,r)}static async fromGraphDescriptor(t){const e=new D(t);return e.edges=t.edges,e.nodes=t.nodes,e.graphs=t.graphs,e.args=t.args,e}static async load(t,e){const{base:r,slotted:s,outerGraph:i}=e||{},n=new v({base:r,graphs:i?.graphs}),{isSubgraph:o,graph:a}=await n.load(t),u=await D.fromGraphDescriptor(a);return o&&(u.#I=i),u.#S=s||{},u}static async fromBreadboardCapability(t){if("board"!==t.kind||!t.board)throw new Error(`Expected a "board" Capability, but got ${t}`);const e=t.board;if(!(e.edges&&e.kits&&e.nodes))throw new Error('Supplied "board" Capability argument is not actually a board');let r=t.board;return r.runOnce||(r=await D.fromGraphDescriptor(e)),r}static async handlersFromBoard(t,e=[]){const r=[new C,...e,...t.kits];return s(r)}static runRemote=O}class C{handlers;constructor(){this.handlers={lambda:{describe:async t=>({inputSchema:(new e).setAdditionalProperties(!0).addInputs(t).addProperty("board",{title:"board",description:"The board to run.",type:"object"}).build(),outputSchema:(new e).addProperty("board",{title:"board",description:"The now-runnable board.",type:"object"}).build()}),invoke:async t=>{const{board:e,...r}=t;if(!e||"board"!==e.kind||!e.board)throw new Error('Lambda node requires a BoardCapability as "board" input');const s={...await D.fromBreadboardCapability(e),args:r};return{board:{...e,board:s}}}}}}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class L{graph;handlers;runner;constructor(t){this.graph=t}populateDescriptor(t){const{title:e,description:r,version:s}=this.graph;return{title:e,description:r,version:s,...t}}async#x(t,e=[]){const r=await D.fromGraphDescriptor(this.graph);r.url=t,this.handlers=e?.reduce(((t,e)=>({...t,...e.handlers})),{}),this.runner=r}handlerForNode(t){if(!this.graph)throw new Error("Builder was not yet initialized.");const{nodes:e}=this.graph,i=e.find((e=>e.id===t));if(!i)throw new Error(`Node ${t} not found in graph.`);return{invoke:async(t,e)=>{const n=i.configuration;n&&(t={...n,...t});const o={...this.handlers,...s(e?.kits||[])},a=o?.[i.type];if(!a)throw new Error(`No handler found for node "${i.type}".`);const u=this.runner,c=u.url?new URL(u.url):new URL(import.meta.url);return console.log("KIT HANDLER",e),r(a,t,{...e,outerGraph:u,base:c,kits:[...e.kits||[],...u.kits]})}}}static async create(t,e,r){const s=new L(t);return await s.#x(e,r),s}}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Q{url;title;description;version;namespacePrefix;constructor({title:t,description:e,version:r,url:s,namespacePrefix:i=""}){this.url=s,this.title=t,this.description=e,this.version=r,this.namespacePrefix=i}#q(t){return Object.keys(t).reduce(((e,r)=>(e[`${this.namespacePrefix}${r}`]=t[r],e)),{})}build(t){if(!this.url)throw new Error("Builder was not yet initialized.");const e=this.url,r=this.namespacePrefix,{title:s,description:i,version:n}=this,o=this.#q(t),a=Object.keys(t);return class{title=s;description=i;version=n;url=e;get handlers(){return o}constructor(t){const e=new Proxy(this,{get:(s,i)=>"handlers"===i||"url"===i?s[i]:a.includes(i)?(s={})=>{const n=t.getConfigWithLambda(s),{$id:o,...a}=n;return t.create(e,`${r}${i}`,{...a},o)}:void 0});return e}}}static wrap(t,e){const r=Object.entries(e).reduce(((t,e)=>{const[r,s]=e;return t[r]={invoke:async t=>{let e=[];s&&s.length>0&&(e=s.toString().match(/\((.+?)\)/)?.[1].split(",")??[],s.length>1&&0===e.length&&"___args"in t&&Array.isArray(t.___args)&&(e=["___args"]));for(const r of e)if(r.trim()in t==!1)throw new Error(`Missing input: ${r.trim()}. Valid inputs are: ${Object.keys(t).join(", ")}`);const r=e.filter((t=>0==t.startsWith("___"))).map((e=>t[e.trim()])),i=e[e.length-1];null!=i&&i.startsWith("___")&&r.push(...t[i]);const n=await s(...r);return"object"!=typeof n||Array.isArray(n)?{result:n}:{...n}}},t}),{});return new Q(t).build(r)}}export{L as GraphToKitAdapter,Q as KitBuilder,e as SchemaBuilder};
//# sourceMappingURL=kits.min.js.map
