/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import type { Capability, NodeValue } from "./types.js";
declare const STREAM_KIND: "stream";
export interface StreamCapabilityType<ChunkType = object> extends Capability {
    kind: typeof STREAM_KIND;
    stream: ReadableStream<ChunkType>;
}
export declare class StreamCapability<ChunkType> implements StreamCapabilityType<ChunkType> {
    kind: "stream";
    stream: ReadableStream<ChunkType>;
    constructor(stream: ReadableStream<ChunkType>);
}
export declare const clone: (streamCapability: StreamCapabilityType) => ReadableStream<object>;
export declare const isStreamCapability: (object: unknown) => boolean;
export declare const stringifyWithStreams: (value: unknown) => {
    value: string;
    streams: ReadableStream<any>[];
};
export declare const parseWithStreams: (value: string, getStream: (id: number) => ReadableStream) => any;
export declare const getStreams: (value: NodeValue) => ReadableStream<any>[];
/**
 * Stubs out all streams in the input values with empty streams.
 * This is useful when we don't want the streams to be transferred.
 * @param data
 * @returns
 */
export declare const stubOutStreams: (data: unknown) => unknown;
export type PatchedReadableStream<T> = ReadableStream<T> & AsyncIterable<T>;
interface MessagePortLike {
    postMessage(message: unknown, transfer: Transferable[]): void;
    onmessage: ((ev: MessageEvent) => unknown) | null;
}
export type PortStreams<Read, Write> = {
    readable: ReadableStream<Read>;
    writable: WritableStream<Write>;
};
export declare const portToStreams: <Read, Write>(port: MessagePortLike) => PortStreams<Read, Write>;
export declare const portFactoryToStreams: <Read, Write>(portFactory: () => Promise<MessagePortLike>) => PortStreams<Read, Write>;
export declare class WritableResult<Read, Write> {
    #private;
    data: Read;
    constructor(value: Read, writer: WritableStreamDefaultWriter<Write>);
    reply(chunk: Write): Promise<void>;
}
export type AsyncIterableWithStart<T, S> = AsyncIterable<T> & {
    start: (chunk: S) => Promise<void>;
};
/**
 * A helper to convert a pair of streams to an async iterable that follows
 * the following protocol:
 * - The async iterable yields a `WritableResult` object.
 * - The `WritableResult` object contains the data from the readable stream.
 * - The `WritableResult` object has a `reply` method that can be used to
 *   write a value as a reply to to data in the readable stream.
 *
 * This is particularly useful with bi-directional streams, when the two
 * streams are semantically connected to each other.
 *
 * @param writable The writable stream.
 * @param readable The readable stream.
 * @returns An async iterable.
 */
export declare const streamsToAsyncIterable: <Read, Write>(writable: WritableStream<Write>, readable: ReadableStream<Read>) => AsyncIterableWithStart<WritableResult<Read, Write>, Write>;
export declare const patchReadableStream: () => void;
export declare const streamFromAsyncGen: <T>(iterator: AsyncIterableIterator<T>) => PatchedReadableStream<T>;
export declare const streamFromReader: <Read>(reader: ReadableStreamDefaultReader<Read>) => PatchedReadableStream<Read>;
export declare const streamFromWriter: <Write>(writer: WritableStreamDefaultWriter<Write>) => WritableStream<Write>;
export {};
//# sourceMappingURL=stream.d.ts.map