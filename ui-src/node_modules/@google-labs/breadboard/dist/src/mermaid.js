/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const template = (edges, direction) => {
    return `%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%
graph ${direction};
${edges}
classDef default stroke:#ffab40,fill:#fff2ccff,color:#000
classDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000
classDef output stroke:#38761d,fill:#b6d7a8ff,color:#000
classDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000
classDef slot stroke:#a64d79,fill:#ead1dcff,color:#000
classDef config stroke:#a64d79,fill:#ead1dcff,color:#000
classDef secrets stroke:#db4437,fill:#f4cccc,color:#000
classDef slotted stroke:#a64d79`;
};
const unstyledTemplate = (edges, direction) => {
    return `graph ${direction};
${edges}`;
};
const properNodeId = (node) => {
    // Mermaid gets confused by hyphens in node ids
    // For example `get-graph` id will throw a syntax error, because it thinks
    // that it sees the `graph` token.
    return node && node.replace(/-/g, "");
};
const shape = (descriptor, idPrefix = "") => {
    if (!descriptor)
        return "";
    const node = descriptor.id;
    const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : "";
    const nodeId = `${prefix}${properNodeId(node)}`;
    const nodeType = descriptor.type;
    const text = `"${nodeType} <br> id='${node}'"`;
    switch (nodeType) {
        case "include":
            return `${nodeId}[[${text}]]:::include`;
        case "slot":
            return `${nodeId}((${text})):::slot`;
        case "passthrough":
            return `${nodeId}((${text})):::passthrough`;
        case "input":
            return `${nodeId}[/${text}/]:::input`;
        case "secrets":
            return `${nodeId}(${text}):::secrets`;
        case "output":
            return `${nodeId}{{${text}}}:::output`;
        default:
            return `${nodeId}[${text}]`;
    }
};
const describeEdge = (edge, nodeMap, idPrefix = "") => {
    const from = edge.from;
    const fromNode = shape(nodeMap.get(from), idPrefix);
    const to = edge.to;
    const toNode = shape(nodeMap.get(to), idPrefix);
    const input = edge.in;
    const output = edge.out;
    const optional = edge.optional;
    const constant = edge.constant;
    if (output === "*") {
        return `${fromNode} -- all --> ${toNode}`;
    }
    if (output && input) {
        if (optional)
            return `${fromNode} -. "${output}->${input}" .-> ${toNode}`;
        if (constant)
            return `${fromNode} -- "${output}->${input}" --o ${toNode}`;
        return `${fromNode} -- "${output}->${input}" --> ${toNode}`;
    }
    return `${fromNode} --> ${toNode}`;
};
class MermaidGenerator {
    nodeMap;
    edges;
    nodes;
    idPrefix;
    subgraphs;
    constructor(graph, idPrefix = "") {
        const { edges, nodes } = graph;
        this.nodeMap = new Map(nodes.map((node) => [node.id, node]));
        this.edges = edges;
        this.nodes = nodes;
        this.idPrefix = idPrefix;
        this.subgraphs = graph.graphs || {};
    }
    handleSlotted(fromNode, idPrefix) {
        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : "";
        const type = fromNode.type;
        if (type !== "include")
            return "";
        const slotted = fromNode.configuration?.slotted;
        if (!slotted)
            return "";
        const subgraphs = Object.entries(slotted).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, "slotted", fromNode, `${prefix}${fromNode.id}`));
        return subgraphs.join("\n");
    }
    handleLambda(fromNode, idPrefix) {
        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : "";
        const board = fromNode.configuration?.board;
        if (!board)
            return "";
        const capability = board;
        if (capability.kind !== "board")
            return "";
        const graph = capability.board;
        return this.describeSubgraph(graph, fromNode.id, "lamdba", fromNode, `${prefix}${fromNode.id}`);
    }
    describeSubgraphs(edge, idPrefix = "") {
        const fromNode = this.nodeMap.get(edge.from);
        if (!fromNode)
            return "";
        const lamdba = this.handleLambda(fromNode, idPrefix);
        const slotted = this.handleSlotted(fromNode, idPrefix);
        return `${slotted}${lamdba}`;
    }
    describeSubgraph(subgraph, name, edgeName, fromNode, idPrefix) {
        const subgraphGenerator = new MermaidGenerator(subgraph, idPrefix);
        const edges = subgraphGenerator.describeGraph();
        const prefix = this.idPrefix ? `${properNodeId(this.idPrefix)}_` : "";
        const subgraphEdge = edgeName && fromNode
            ? `sg_${properNodeId(name)}:::slotted -- "${edgeName}->${edgeName}" --o ${prefix}${properNodeId(fromNode.id)}\n`
            : "";
        return `\nsubgraph sg_${properNodeId(name)} [${name}]\n${edges}\nend\n${subgraphEdge}`;
    }
    describeGraph(ignoreSubgraphs = false) {
        const result = this.edges.map((edge) => {
            const mermEdge = describeEdge(edge, this.nodeMap, this.idPrefix);
            const mermSubgraphs = ignoreSubgraphs
                ? ""
                : this.describeSubgraphs(edge, this.idPrefix);
            return `${mermEdge}${mermSubgraphs}`;
        });
        const subgraphs = ignoreSubgraphs
            ? ""
            : Object.entries(this.subgraphs).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, undefined, undefined, `${name}${this.idPrefix}`));
        return [...result, ...subgraphs].join("\n");
    }
}
export const toMermaid = (graph, direction = "TD", unstyled = false, ignoreSubgraphs = false) => {
    const generator = new MermaidGenerator(graph);
    const edges = generator.describeGraph(ignoreSubgraphs);
    return unstyled
        ? unstyledTemplate(edges, direction)
        : template(edges, direction);
};
//# sourceMappingURL=mermaid.js.map