/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { AbstractValue, } from "./types.js";
import { BuilderNode, isBuilderNodeProxy } from "./node.js";
// Because Value is sometimes behind a function Proxy (see NodeImpl's methods),
// we need to use this approach to identify Value instead instanceof.
export const IsValueSymbol = Symbol("IsValue");
export function isValue(obj) {
    return ((typeof obj === "object" || typeof obj === "function") &&
        obj[IsValueSymbol] !== undefined);
}
export class Value extends AbstractValue {
    #node;
    #scope;
    #keymap;
    #constant;
    #schema;
    constructor(node, scope, keymap, constant = false, schema = {}) {
        super();
        this.#node = node;
        this.#scope = scope;
        this.#keymap = typeof keymap === "string" ? { [keymap]: keymap } : keymap;
        this[IsValueSymbol] = this;
        this.#constant = constant;
        this.#schema = schema;
    }
    then(onfulfilled, onrejected) {
        if (Object.keys(this.#keymap).length !== 1)
            throw Error("Can't `await` for multiple values");
        return this.#node.then((o) => o &&
            onfulfilled &&
            this.#scope.asScopeFor(onfulfilled)(o[Object.keys(this.#keymap)[0]]), onrejected && this.#scope.asScopeFor(onrejected));
    }
    asNodeInput() {
        return [this.#node.unProxy(), this.#keymap, this.#constant, this.#schema];
    }
    to(to, config) {
        const toNode = isBuilderNodeProxy(to)
            ? to.unProxy()
            : new BuilderNode(to, this.#scope, config);
        toNode.addInputsFromNode(this.#node, this.#keymap, this.#constant, this.#schema);
        return toNode.asProxy();
    }
    // This doesn't do any type checking on the inputs.
    //
    // TODO: See whether that's somehow possible. The main problem is that
    // node.<field> is typed for the outputs. We could add a new InputValue type
    // and generate those from node.in().field so that the final syntax could be
    // `toNode.toField.in(fromNode.in().fromField)`.
    //
    // That is, today .in() on a value returns void and in the future it would
    // return that new InputValue type, typed with the right input value from the
    // original node. To accomplish this, we'll have to keep passing the
    // node input values type through the chain of values and .as() statements.
    in(inputs) {
        let invertedMap = Object.fromEntries(Object.entries(this.#keymap).map(([fromKey, toKey]) => [toKey, fromKey]));
        if (isValue(inputs)) {
            invertedMap = inputs.#remapKeys(invertedMap);
            this.#node.addInputsFromNode(inputs.#node, invertedMap, inputs.#constant, inputs.#schema);
        }
        else if (isBuilderNodeProxy(inputs)) {
            this.#node.addInputsFromNode(inputs.unProxy(), invertedMap);
        }
        else {
            this.#node.addInputsAsValues(inputs);
        }
    }
    as(newKey) {
        let newMap;
        if (typeof newKey === "string") {
            if (Object.keys(this.#keymap).length !== 1)
                throw new Error("Can't rename multiple values with a single string");
            newMap = { [Object.keys(this.#keymap)[0]]: newKey };
        }
        else {
            newMap = this.#remapKeys(newKey);
        }
        return new Value(this.#node, this.#scope, newMap, this.#constant, this.#schema);
    }
    memoize() {
        return new Value(this.#node, this.#scope, this.#keymap, true, this.#schema);
    }
    // Create a node for the lambda that is being sent as this value. At this
    // point we can't verify that this actually is a BoardCapability, so we just
    // do it and let the runtime throw an error if this wasn't one.
    invoke(config) {
        return new BuilderNode("invoke", this.#scope, {
            ...config,
            $board: this,
        }).asProxy();
    }
    /**
     * The following are type-casting methods that are useful when a node type
     * returns generic types but we want to narrow the types to what we know they
     * are, e.g. a parser node returning the result as raw wires.
     *
     * This is also a way to define the schema of a board, e.g. by casting input
     * wires and what is returned.
     *
     * Use as `foo.asString()` or `foo.asNumber()`. `isArray` and `isObject` cast
     * to generic arrays and objects.
     */
    isUnknown() {
        delete this.#schema.type;
        return this;
    }
    isString() {
        this.#schema.type = "string";
        return this;
    }
    isNumber() {
        this.#schema.type = "number";
        return this;
    }
    isBoolean() {
        this.#schema.type = "boolean";
        return this;
    }
    isArray() {
        this.#schema.type = "array";
        return this;
    }
    isImage(mimeType = "image/png") {
        this.#schema.type = mimeType;
        return this;
    }
    isObject() {
        this.#schema.type = "object";
        return this;
    }
    title(title) {
        this.#schema.title = title;
        return this;
    }
    description(description) {
        this.#schema.description = description;
        return this;
    }
    format(format) {
        this.#schema.format = format;
        return this;
    }
    examples(...examples) {
        this.#schema.examples = examples;
        return this;
    }
    default(value) {
        this.#schema.default = value;
        return this;
    }
    optional() {
        this.#schema.$optional = true;
        return this;
    }
    transient() {
        this.#schema.$optional = true;
        return this;
    }
    #remapKeys(newKeys) {
        const newMap = { ...this.#keymap };
        Object.entries(newKeys).forEach(([fromKey, toKey]) => {
            if (this.#keymap[toKey]) {
                newMap[fromKey] = this.#keymap[toKey];
                delete this.#keymap[toKey];
            }
            else {
                newMap[fromKey] = toKey;
            }
        });
        return newMap;
    }
}
//# sourceMappingURL=value.js.map