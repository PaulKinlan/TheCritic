/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const STREAM_KIND = "stream";
export class StreamCapability {
    kind = STREAM_KIND;
    stream;
    constructor(stream) {
        this.stream = stream;
    }
}
export const clone = (streamCapability) => {
    const [leave, take] = streamCapability.stream.tee();
    streamCapability.stream = leave;
    return take;
};
export const isStreamCapability = (object) => {
    const maybeStream = object;
    return (maybeStream &&
        maybeStream.kind &&
        maybeStream.kind === STREAM_KIND &&
        maybeStream.stream instanceof ReadableStream);
};
// TODO: Remove this once MessageController is gone.
const findStreams = (value, foundStreams) => {
    if (Array.isArray(value)) {
        value.forEach((item) => {
            findStreams(item, foundStreams);
        });
    }
    else if (typeof value === "object") {
        if (value === null || value === undefined)
            return;
        const maybeCapability = value;
        if (maybeCapability.kind && maybeCapability.kind === STREAM_KIND) {
            foundStreams.push(maybeCapability.stream);
        }
        else {
            Object.values(value).forEach((item) => {
                findStreams(item, foundStreams);
            });
        }
    }
};
export const stringifyWithStreams = (value) => {
    const foundStreams = [];
    return {
        value: JSON.stringify(value, (key, value) => {
            if (isStreamCapability(value)) {
                foundStreams.push(value.stream);
                return { $type: "Stream", id: foundStreams.length - 1 };
            }
            return value;
        }),
        streams: foundStreams,
    };
};
export const parseWithStreams = (value, getStream) => {
    const parsed = JSON.parse(value, (key, value) => {
        if (typeof value === "object" && value !== null) {
            if (value.$type === "Stream" && typeof value.id === "number") {
                return new StreamCapability(getStream(value.id));
            }
        }
        return value;
    });
    return parsed;
};
export const getStreams = (value) => {
    const foundStreams = [];
    findStreams(value, foundStreams);
    return foundStreams;
};
/**
 * Stubs out all streams in the input values with empty streams.
 * This is useful when we don't want the streams to be transferred.
 * @param data
 * @returns
 */
export const stubOutStreams = (data) => {
    const stringified = stringifyWithStreams(data).value;
    return parseWithStreams(stringified, () => new ReadableStream());
};
export const portToStreams = (port) => {
    const readable = new ReadableStream({
        start(controller) {
            port.onmessage = (ev) => {
                if (ev.data === null) {
                    controller.close();
                    return;
                }
                controller.enqueue(ev.data);
            };
        },
        cancel() {
            port.onmessage = null;
        },
    });
    const writable = new WritableStream({
        write(chunk) {
            const stringified = stringifyWithStreams(chunk);
            port.postMessage(chunk, stringified.streams);
        },
        close() {
            port.postMessage(null, []);
        },
    });
    return {
        readable,
        writable,
    };
};
export const portFactoryToStreams = (portFactory) => {
    let streams;
    const streamsAvailable = new Promise((resolve) => {
        portFactory().then((port) => {
            streams = portToStreams(port);
            resolve();
        });
    });
    const readable = new ReadableStream({
        async start() {
            await streamsAvailable;
        },
        pull(controller) {
            return streams.readable.pipeTo(new WritableStream({
                write(chunk) {
                    controller.enqueue(chunk);
                },
            }));
        },
        cancel() {
            streams.readable.cancel();
        },
    });
    const writable = new WritableStream({
        async start() {
            await streamsAvailable;
        },
        async write(chunk) {
            const writer = streams.writable.getWriter();
            await writer.write(chunk);
            writer.releaseLock();
        },
        async close() {
            await streams.writable.close();
        },
        async abort(reason) {
            await streams.writable.abort(reason);
        },
    });
    return {
        readable,
        writable,
    };
};
export class WritableResult {
    #writer;
    data;
    constructor(value, writer) {
        this.#writer = writer;
        this.data = value;
    }
    async reply(chunk) {
        await this.#writer.write(chunk);
    }
}
class StreamsAsyncIterator {
    #reader;
    #writer;
    constructor(writable, readable) {
        this.#reader = readable.getReader();
        this.#writer = writable.getWriter();
    }
    async next() {
        const { done, value } = await this.#reader.read();
        if (done) {
            this.#writer.close();
            return { done, value: undefined };
        }
        return {
            done: false,
            value: new WritableResult(value, this.#writer),
        };
    }
    async return() {
        this.#writer.close();
        return { done: true, value: undefined };
    }
    async throw(err) {
        this.#writer.abort(err);
        return { done: true, value: undefined };
    }
}
/**
 * A helper to convert a pair of streams to an async iterable that follows
 * the following protocol:
 * - The async iterable yields a `WritableResult` object.
 * - The `WritableResult` object contains the data from the readable stream.
 * - The `WritableResult` object has a `reply` method that can be used to
 *   write a value as a reply to to data in the readable stream.
 *
 * This is particularly useful with bi-directional streams, when the two
 * streams are semantically connected to each other.
 *
 * @param writable The writable stream.
 * @param readable The readable stream.
 * @returns An async iterable.
 */
export const streamsToAsyncIterable = (writable, readable) => {
    return {
        async start(chunk) {
            const writer = writable.getWriter();
            await writer.write(chunk);
            writer.releaseLock();
        },
        [Symbol.asyncIterator]() {
            return new StreamsAsyncIterator(writable, readable);
        },
    };
};
// Polyfill to make ReadableStream async iterable
// See https://bugs.chromium.org/p/chromium/issues/detail?id=929585
export const patchReadableStream = () => {
    // eslint-disable-next-line
    // @ts-ignore
    ReadableStream.prototype[Symbol.asyncIterator] ||
        // eslint-disable-next-line
        // @ts-ignore
        (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
            const reader = this.getReader();
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done)
                        return;
                    yield value;
                }
            }
            finally {
                reader.releaseLock();
            }
        });
};
// A polyfill for ReadableStream.from:
// See https://streams.spec.whatwg.org/#rs-from
// TODO: Do a proper TypeScript types polyfill.
export const streamFromAsyncGen = (iterator) => {
    return new ReadableStream({
        async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
                controller.close();
                return;
            }
            controller.enqueue(value);
        },
    });
};
export const streamFromReader = (reader) => {
    return new ReadableStream({
        async pull(controller) {
            const { value, done } = await reader.read();
            if (done) {
                controller.close();
                return;
            }
            controller.enqueue(value);
        },
    }, { highWaterMark: 0 });
};
export const streamFromWriter = (writer) => {
    return new WritableStream({
        async write(chunk) {
            return writer.write(chunk);
        },
    }, { highWaterMark: 0 });
};
//# sourceMappingURL=stream.js.map