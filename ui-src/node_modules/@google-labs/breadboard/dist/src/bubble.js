/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { InputStageResult } from "./run.js";
export const createErrorMessage = (inputName, metadata = {}, required) => {
    const boardTitle = metadata.title ?? metadata?.url;
    const requiredText = required ? "required " : "";
    return `Missing ${requiredText}input "${inputName}"${boardTitle ? ` for board "${boardTitle}".` : "."}`;
};
export const bubbleUpInputsIfNeeded = async (metadata, context, descriptor, result) => {
    // If we have no way to bubble up inputs, we just return and not
    // enforce required inputs.
    if (!context.requestInput)
        return;
    const outputs = (await result.outputsPromise) ?? {};
    const reader = new InputSchemaReader(outputs, result.inputs);
    result.outputsPromise = reader.read(createBubbleHandler(metadata, context, descriptor));
};
export const createBubbleHandler = (metadata, context, descriptor) => {
    return (async (name, schema, required) => {
        if (required) {
            throw new Error(createErrorMessage(name, metadata, required));
        }
        if (schema.default !== undefined) {
            if ("type" in schema && schema.type !== "string") {
                return JSON.parse(schema.default);
            }
            return schema.default;
        }
        const value = await context.requestInput?.(name, schema, descriptor);
        if (value === undefined) {
            throw new Error(createErrorMessage(name, metadata, required));
        }
        return value;
    });
};
export class InputSchemaReader {
    #currentOutputs;
    #inputs;
    constructor(currentOutputs, inputs) {
        this.#currentOutputs = currentOutputs;
        this.#inputs = inputs;
    }
    async read(handler) {
        if (!("schema" in this.#inputs))
            return this.#currentOutputs;
        const schema = this.#inputs.schema;
        if (!schema.properties)
            return this.#currentOutputs;
        const entries = Object.entries(schema.properties);
        const newOutputs = {};
        for (const [name, property] of entries) {
            if (name in this.#currentOutputs) {
                newOutputs[name] = this.#currentOutputs[name];
                continue;
            }
            const required = schema.required?.includes(name) ?? false;
            const value = await handler(name, property, required);
            newOutputs[name] = value;
        }
        return {
            ...this.#currentOutputs,
            ...newOutputs,
        };
    }
}
export class RequestedInputsManager {
    #context;
    #cache = new Map();
    constructor(context) {
        this.#context = context;
    }
    createHandler(next, result) {
        return async (name, schema, node) => {
            const cachedValue = this.#cache.get(name);
            if (cachedValue !== undefined)
                return cachedValue;
            const descriptor = { id: node.id, type: node.type };
            const requestInputResult = {
                ...result,
                descriptor,
                inputs: {
                    schema: { type: "object", properties: { [name]: schema } },
                },
            };
            //console.log("requestInputResult", requestInputResult);
            await next(new InputStageResult(requestInputResult, undefined, -1));
            const outputs = await requestInputResult.outputsPromise;
            let value = outputs && outputs[name];
            if (value === undefined) {
                value = await this.#context.requestInput?.(name, schema, descriptor);
            }
            if (!schema.transient)
                this.#cache.set(name, value);
            return value;
        };
    }
}
//# sourceMappingURL=bubble.js.map