{"version":3,"file":"index.min.js","sources":["src/traversal/index.js","src/traversal/state.js","src/traversal/result.js","src/traversal/iterator.js","src/traversal/representation.js","src/traversal/machine.js","src/serialization.js","src/timestamp.js","src/run.js","src/loader.js","src/remote.js","src/handler.js","src/mermaid.js","src/schema.js","src/bubble.js","src/utils/async-gen.js","src/stack.js","src/runner.js","src/id.js","src/node.js","src/kits/ctors.js","src/board.js","src/stream.js","src/new/runner/kits.js","src/new/runner/types.js","src/new/runner/node.js","src/new/runner/state.js","src/new/runner/scope.js","src/new/runner/runner.js","../../../node_modules/zod/lib/index.mjs","../../../node_modules/zod-to-json-schema/dist/esm/errorMessages.js","../../../node_modules/zod-to-json-schema/dist/esm/Options.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/date.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/string.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/record.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/union.js","../../../node_modules/zod-to-json-schema/dist/esm/parseDef.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/number.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/object.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/null.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/array.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/map.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/set.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/never.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/default.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js","../../../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js","../../../node_modules/zod-to-json-schema/dist/esm/Refs.js","../../../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js","src/new/grammar/zod-utils.js","src/new/grammar/default-scope.js","src/new/grammar/scope.js","src/new/grammar/types.js","src/new/grammar/value.js","src/new/grammar/node.js","src/new/grammar/kits.js","src/new/grammar/board.js","src/new/grammar/base.js"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * This class holds important parts of the graph traversal algorithm.\n */\nexport class Traversal {\n    /**\n     * Computes the missing inputs for a node. A missing input is an input that is\n     * required by the node, but is not (yet) available in the current state.\n     * @param heads All the edges that point to the node.\n     * @param inputs The input values that will be passed to the node\n     * @param current The node that is being visited.\n     * @returns Array of missing input names.\n     */\n    static computeMissingInputs(heads, inputs, current) {\n        const requiredInputs = [\n            ...new Set(heads\n                .filter((edge) => !!edge.in && !edge.optional)\n                .map((edge) => edge.in || \"\")),\n        ];\n        const inputsWithConfiguration = new Set();\n        Object.keys(inputs).forEach((key) => inputsWithConfiguration.add(key));\n        if (current.configuration) {\n            Object.keys(current.configuration).forEach((key) => inputsWithConfiguration.add(key));\n        }\n        return requiredInputs.filter((input) => !inputsWithConfiguration.has(input));\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class MachineEdgeState {\n    state = new Map();\n    constants = new Map();\n    #queueOutput(map, node, key, value) {\n        let queuesMap = map.get(node);\n        if (!queuesMap) {\n            queuesMap = new Map();\n            map.set(node, queuesMap);\n        }\n        let queue = queuesMap.get(key);\n        if (!queue) {\n            queue = [];\n            queuesMap.set(key, queue);\n        }\n        queue.push(value);\n    }\n    /**\n     * Processes outputs by wiring them to the destinations according\n     * to the supplied edges. Assumes that the outputs were generated by\n     * the from node.\n     *\n     * @param opportunites {Edge[]} Edges to process\n     * @param outputs {OutputValues} Outputs to wire\n     */\n    wireOutputs(opportunites, outputs) {\n        // Verify that all edges are from the same node.\n        if (opportunites.filter((opportunity) => opportunity.from != opportunites[0].from).length !== 0)\n            throw new Error(\"All opportunities must be from the same node\");\n        opportunites.forEach((opportunity) => {\n            const to = opportunity.to;\n            const out = opportunity.out;\n            const queuesMap = opportunity.constant ? this.constants : this.state;\n            if (!out)\n                return;\n            if (out === \"*\") {\n                for (const key in outputs) {\n                    const output = outputs[key];\n                    if (output != null && output != undefined)\n                        this.#queueOutput(queuesMap, to, key, output);\n                }\n            }\n            else if (opportunity.in) {\n                const output = outputs[out];\n                // TODO: Check and document why we don't allow that\n                if (output != null && output != undefined)\n                    this.#queueOutput(queuesMap, to, opportunity.in, output);\n            }\n        });\n    }\n    /**\n     * Returns the available inputs for a given node.\n     *\n     * @param nodeId {NodeIdentifier} The node to get the inputs for.\n     * @returns {InputValues} The available inputs.\n     */\n    getAvailableInputs(nodeId) {\n        const result = {};\n        for (const queuesMap of [\n            this.constants.get(nodeId), // Constants are overwritten by state.\n            this.state.get(nodeId),\n        ]) {\n            if (!queuesMap)\n                continue;\n            for (const [key, queue] of queuesMap.entries()) {\n                if (queue.length === 0)\n                    continue;\n                result[key] = queue[0];\n            }\n        }\n        return result;\n    }\n    /**\n     * Shifts inputs from the queues. Leaves constants as is.\n     *\n     * @param nodeId {NodeIdentifier} The node to shift the inputs for.\n     * @param inputs {InputValues} The inputs that are used.\n     */\n    useInputs(nodeId, inputs) {\n        const queuesMap = this.state.get(nodeId);\n        if (!queuesMap)\n            return;\n        for (const key in inputs) {\n            const queue = queuesMap.get(key);\n            if (!queue)\n                continue;\n            queue.shift();\n        }\n    }\n}\n//# sourceMappingURL=state.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { MachineEdgeState } from \"./state.js\";\nexport class MachineResult {\n    descriptor;\n    inputs;\n    missingInputs;\n    opportunities;\n    newOpportunities;\n    state;\n    outputsPromise;\n    pendingOutputs;\n    constructor(descriptor, inputs, missingInputs, opportunities, newOpportunities, state, pendingOutputs) {\n        this.descriptor = descriptor;\n        this.inputs = inputs;\n        this.missingInputs = missingInputs;\n        this.opportunities = opportunities;\n        this.newOpportunities = newOpportunities;\n        this.state = state;\n        this.pendingOutputs = pendingOutputs;\n    }\n    /**\n     * `true` if the machine decided that the node should be skipped, rather than\n     * visited.\n     */\n    get skip() {\n        return this.missingInputs.length > 0;\n    }\n    static fromObject(o) {\n        const edgeState = new MachineEdgeState();\n        edgeState.constants = o.state.constants;\n        edgeState.state = o.state.state;\n        return new MachineResult(o.descriptor, o.inputs, o.missingInputs, o.opportunities, o.newOpportunities, edgeState, o.pendingOutputs);\n    }\n}\n//# sourceMappingURL=result.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Traversal } from \"./index.js\";\nimport { MachineResult } from \"./result.js\";\nexport class TraversalMachineIterator {\n    graph;\n    #current;\n    #noParallelExecution;\n    constructor(graph, result, noParallelExecution = true) {\n        this.graph = graph;\n        this.#current = result;\n        this.#noParallelExecution = noParallelExecution;\n    }\n    static #processCompletedNode(result, completedNodeOutput) {\n        const { promiseId, outputs, newOpportunities } = completedNodeOutput;\n        result.pendingOutputs.delete(promiseId);\n        // If there was an error, ignore all other outputs and hence opportunites.\n        const opportunities = outputs.$error\n            ? newOpportunities.filter((e) => e.out === \"$error\")\n            : newOpportunities;\n        // Process outputs.\n        result.opportunities.push(...opportunities);\n        result.state.wireOutputs(opportunities, outputs);\n        if (outputs.$error) {\n            if (opportunities.length === 0) {\n                // If the node threw an exception and it wasn't routed via $error,\n                // throw it again. This will cause the traversal to stop.\n                throw new Error(\"Uncaught exception in node handler. Catch by wiring up the $error output.\", {\n                    cause: outputs.$error,\n                });\n            }\n            else {\n                globalThis.console.warn(\"Error in node handler, passing to the wired $error output.\", outputs.$error, opportunities);\n            }\n        }\n    }\n    static async processAllPendingNodes(result) {\n        const completed = await Promise.all(result.pendingOutputs.values());\n        completed.forEach((completedNodeOutput) => {\n            TraversalMachineIterator.#processCompletedNode(result, completedNodeOutput);\n        });\n        return result;\n    }\n    async next() {\n        // If there are no missing inputs, let's consume the outputs\n        if (!this.#current.skip) {\n            const { inputs, outputsPromise, newOpportunities, descriptor } = this.#current;\n            // Mark inputs as used, i.e. shift inputs queues.\n            this.#current.state.useInputs(descriptor.id, this.#current.inputs);\n            const promiseId = Symbol();\n            const promise = new Promise((resolve) => {\n                (outputsPromise || Promise.resolve({}))\n                    .then((outputs) => {\n                    // If not already present, add inputs and descriptor along for\n                    // context and to support retries. If $error came from another node,\n                    // the descriptor will remain the original, but new inputs will be\n                    // added, though never overwriting prior ones.\n                    if (outputs.$error) {\n                        const $error = outputs.$error;\n                        outputs.$error = {\n                            descriptor,\n                            ...$error,\n                            inputs: { ...inputs, ...$error.inputs },\n                        };\n                    }\n                    resolve({ promiseId, outputs, newOpportunities });\n                })\n                    .catch((error) => {\n                    // If the handler threw an exception, turn it into a $error output.\n                    // Pass the inputs and descriptor along for context and to support\n                    // retries. This Promise will hence always resolve.\n                    resolve({\n                        promiseId,\n                        outputs: {\n                            $error: {\n                                kind: \"error\",\n                                error,\n                                inputs,\n                                descriptor,\n                            },\n                        },\n                        newOpportunities: newOpportunities.filter((edge) => edge.out === \"$error\"),\n                    });\n                });\n            });\n            this.#current.pendingOutputs.set(promiseId, promise);\n        }\n        // If there are no more opportunites or we've disabled parallel execution,\n        // let's wait for pending nodes to be done\n        while ((this.#current.opportunities.length === 0 || this.#noParallelExecution) &&\n            this.#current.pendingOutputs.size > 0) {\n            // Wait for the first pending node to be done.\n            TraversalMachineIterator.#processCompletedNode(this.#current, await Promise.race(this.#current.pendingOutputs.values()));\n        }\n        // If there are no more opportunities and none are pending, we're done.\n        if (this.#current.opportunities.length === 0)\n            return { done: true, value: null };\n        // Now, we're ready to start the next iteration.\n        // Otherwise, let's pop the next opportunity from the queue.\n        const opportunity = this.#current.opportunities.shift();\n        const { heads, nodes, tails } = this.graph;\n        const toNode = opportunity.to;\n        const currentDescriptor = nodes.get(toNode);\n        if (!currentDescriptor)\n            throw new Error(`No node found for id \"${toNode}\"`);\n        const incomingEdges = heads.get(toNode) || [];\n        const inputs = this.#current.state.getAvailableInputs(toNode);\n        const missingInputs = Traversal.computeMissingInputs(incomingEdges, inputs, currentDescriptor);\n        const newOpportunities = tails.get(toNode) || [];\n        // Pour configuration values into inputs. These are effectively like\n        // constants.\n        const inputsWithConfiguration = {\n            ...currentDescriptor.configuration,\n            ...inputs,\n        };\n        this.#current = new MachineResult(currentDescriptor, inputsWithConfiguration, missingInputs, this.#current.opportunities, newOpportunities, this.#current.state, this.#current.pendingOutputs);\n        return { done: false, value: this.#current };\n    }\n}\n//# sourceMappingURL=iterator.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class GraphRepresentation {\n    /**\n     * Tails: a map of all outgoing edges, keyed by node id.\n     */\n    tails = new Map();\n    /**\n     * Heads: a map of all incoming edges, keyed by node id.\n     */\n    heads = new Map();\n    /**\n     * Nodes: a map of all nodes, keyed by node id.\n     */\n    nodes = new Map();\n    /**\n     * Entries: a list of all nodes that have no incoming edges.\n     */\n    entries = [];\n    constructor(descriptor) {\n        this.tails = descriptor.edges.reduce((acc, edge) => {\n            const from = edge.from;\n            acc.has(from) ? acc.get(from)?.push(edge) : acc.set(from, [edge]);\n            return acc;\n        }, new Map());\n        this.heads = descriptor.edges.reduce((acc, edge) => {\n            const to = edge.to;\n            acc.has(to) ? acc.get(to)?.push(edge) : acc.set(to, [edge]);\n            return acc;\n        }, new Map());\n        this.nodes = descriptor.nodes.reduce((acc, node) => {\n            acc.set(node.id, node);\n            return acc;\n        }, new Map());\n        this.entries = Array.from(this.tails.keys()).filter((node) => !this.heads.has(node) || this.heads.get(node)?.length === 0);\n    }\n}\n//# sourceMappingURL=representation.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachineIterator } from \"./iterator.js\";\nimport { GraphRepresentation } from \"./representation.js\";\nimport { MachineResult } from \"./result.js\";\nimport { MachineEdgeState } from \"./state.js\";\nexport class TraversalMachine {\n    graph;\n    previousResult;\n    constructor(descriptor, result) {\n        this.graph = new GraphRepresentation(descriptor);\n        this.previousResult = result;\n    }\n    [Symbol.asyncIterator]() {\n        return this.start();\n    }\n    start() {\n        if (this.previousResult)\n            return new TraversalMachineIterator(this.graph, this.previousResult);\n        const { entries } = this.graph;\n        if (entries.length === 0)\n            throw new Error(\"No entry node found in graph.\");\n        // Create fake edges to represent entry points.\n        const opportunities = entries.map((entry) => ({\n            from: \"$entry\",\n            to: entry,\n        }));\n        const entryResult = new MachineResult({ id: \"$empty\", type: \"$empty\" }, {}, [], opportunities, [], new MachineEdgeState(), new Map());\n        return new TraversalMachineIterator(this.graph, entryResult);\n    }\n    static async prepareToSave(result) {\n        return await TraversalMachineIterator.processAllPendingNodes(result);\n    }\n}\n//# sourceMappingURL=machine.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachine } from \"./traversal/machine.js\";\nimport { MachineResult } from \"./traversal/result.js\";\nexport const replacer = (key, value) => {\n    if (!(value instanceof Map))\n        return value;\n    return { $type: \"Map\", value: Array.from(value.entries()) };\n};\nexport const reviver = (key, value) => {\n    const { $type } = (value || {});\n    return $type == \"Map\" && value.value\n        ? new Map(value.value)\n        : value;\n};\nexport const saveRunnerState = async (type, result) => {\n    const state = await TraversalMachine.prepareToSave(result);\n    return JSON.stringify({ state, type }, replacer);\n};\nexport const loadRunnerState = (s) => {\n    const { state: o, type } = JSON.parse(s, reviver);\n    const state = MachineResult.fromObject(o);\n    return { state, type };\n};\n//# sourceMappingURL=serialization.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const timestamp = () => globalThis.performance.now();\n//# sourceMappingURL=timestamp.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { loadRunnerState, saveRunnerState } from \"./serialization.js\";\nimport { timestamp } from \"./timestamp.js\";\nexport class RunResult {\n    #type;\n    #state;\n    // TODO: Remove #state and rename this to #state\n    #runState;\n    // TODO: Remove this once RunState machinery works\n    #invocationId;\n    constructor(state, type, runState, invocationId) {\n        this.#state = state;\n        this.#type = type;\n        this.#runState = runState;\n        this.#invocationId = invocationId;\n    }\n    get invocationId() {\n        return this.#invocationId;\n    }\n    get type() {\n        return this.#type;\n    }\n    get node() {\n        return this.#state.descriptor;\n    }\n    get inputArguments() {\n        return this.#state.inputs;\n    }\n    set inputs(inputs) {\n        this.#state.outputsPromise = Promise.resolve(inputs);\n    }\n    get outputs() {\n        return this.#state.inputs;\n    }\n    get state() {\n        return this.#state;\n    }\n    async save() {\n        return saveRunnerState(this.#type, this.#state);\n    }\n    get runState() {\n        return this.#runState;\n    }\n    get timestamp() {\n        return timestamp();\n    }\n    isAtExitNode() {\n        return (this.#state.newOpportunities.length === 0 &&\n            this.#state.opportunities.length === 0 &&\n            this.#state.pendingOutputs.size === 0);\n    }\n    static load(stringifiedResult) {\n        const { state, type } = loadRunnerState(stringifiedResult);\n        return new RunResult(state, type, undefined, 0);\n    }\n}\nexport class InputStageResult extends RunResult {\n    constructor(state, runState, invocationId) {\n        super(state, \"input\", runState, invocationId);\n    }\n    get outputs() {\n        throw new Error('Outputs are not available in the \"input\" stage');\n    }\n}\nexport class OutputStageResult extends RunResult {\n    constructor(state, invocationId) {\n        super(state, \"output\", undefined, invocationId);\n    }\n    get inputArguments() {\n        throw new Error('Input arguments are not available in the \"output\" stage');\n    }\n    set inputs(inputs) {\n        throw new Error('Setting inputs is not available in the \"output\" stage');\n    }\n}\n//# sourceMappingURL=run.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const resolveURL = (base, urlString, results) => {\n    const url = new URL(urlString, base);\n    const hash = url.hash;\n    const href = url.href;\n    const path = url.protocol === \"file:\" ? decodeURIComponent(url.pathname) : undefined;\n    const baseWithoutHash = base.href.replace(base.hash, \"\");\n    const hrefWithoutHash = href.replace(hash, \"\");\n    if (baseWithoutHash == hrefWithoutHash && hash) {\n        results.push({ type: \"hash\", location: hash.substring(1), href });\n        return true;\n    }\n    const result = path\n        ? { type: \"file\", location: path, href }\n        : href\n            ? { type: \"fetch\", location: hrefWithoutHash, href }\n            : { type: \"unknown\", location: \"\", href };\n    results.push(result);\n    return !hash;\n};\nexport const loadFromFile = async (path) => {\n    if (typeof globalThis.process === \"undefined\")\n        throw new Error(\"Unable to use `path` when not running in node\");\n    let readFileFn;\n    // The CJS transpilation process for node/vscode seems to miss this import,\n    // and leaves it as an import statement rather than converting it to a\n    // require. We therefore need a runtime check that prefers `require` if it\n    // is available.\n    if (typeof require === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const { readFile } = require(\"node:fs/promises\");\n        readFileFn = readFile;\n    }\n    else {\n        const { readFile } = await import(/* vite-ignore */ \"node:fs/promises\");\n        readFileFn = readFile;\n    }\n    return JSON.parse(await readFileFn(path, \"utf-8\"));\n};\nexport const loadWithFetch = async (url) => {\n    const response = await fetch(url);\n    return await response.json();\n};\nexport class BoardLoadingStep {\n    loaders;\n    graphs;\n    constructor(graphs) {\n        this.loaders = {\n            file: loadFromFile,\n            fetch: loadWithFetch,\n            hash: async (hash) => {\n                if (!graphs)\n                    throw new Error(\"No sub-graphs to load from\");\n                return graphs[hash];\n            },\n            unknown: async () => {\n                throw new Error(\"Unable to determine Board loader type\");\n            },\n        };\n    }\n    async load(result) {\n        const graph = await this.loaders[result.type](result.location);\n        graph.url = result.href;\n        return graph;\n    }\n}\nexport class BoardLoader {\n    #base;\n    #graphs;\n    constructor({ base, graphs }) {\n        this.#base = base;\n        this.#graphs = graphs;\n    }\n    async load(urlString) {\n        const results = [];\n        let base = this.#base;\n        while (!resolveURL(base, urlString, results)) {\n            base = new URL(results[results.length - 1].href);\n        }\n        let graph;\n        let subgraphs = this.#graphs;\n        let isSubgraph = true;\n        for (const result of results) {\n            if (result.type === \"file\" || result.type === \"fetch\")\n                isSubgraph = false;\n            const step = new BoardLoadingStep(subgraphs);\n            graph = await step.load(result);\n            subgraphs = graph.graphs;\n        }\n        if (!graph)\n            throw new Error(\"BoardLoader failed to load a graph. This error likely indicates a bug in the BoardLoader.\");\n        return { graph, isSubgraph };\n    }\n}\n//# sourceMappingURL=loader.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Polyfill to make ReadableStream async iterable\n// See https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n// eslint-disable-next-line\n// @ts-ignore\nReadableStream.prototype[Symbol.asyncIterator] ||\n    // eslint-disable-next-line\n    // @ts-ignore\n    (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {\n        const reader = this.getReader();\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    return;\n                yield value;\n            }\n        }\n        finally {\n            reader.releaseLock();\n        }\n    });\nclass BoardStreamer {\n    writable;\n    readable;\n    controller = null;\n    constructor() {\n        this.writable = new WritableStream({\n            write: (chunk) => this.write(chunk),\n        });\n        this.readable = new ReadableStream({\n            start: (controller) => {\n                this.controller = controller;\n            },\n        });\n    }\n    write(chunk) {\n        const decoder = new TextDecoder();\n        const s = decoder.decode(chunk);\n        s.split(\"\\n\")\n            .map((line) => line.trim())\n            .filter((line) => line.length > 0)\n            .forEach((line) => {\n            try {\n                if (line === \"stop\") {\n                    this.controller?.close();\n                    return;\n                }\n                const data = JSON.parse(line);\n                this.controller?.enqueue(data);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        });\n    }\n}\n/**\n * Posts the inputs to the breadboard-server and returns a stream of results.\n */\nconst post = async (url, inputs, state) => {\n    const response = await fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ inputs, state }),\n    });\n    return response.body?.pipeThrough(new BoardStreamer());\n};\nexport async function* runRemote(url) {\n    let inputs = undefined;\n    let state = undefined;\n    for (;;) {\n        const stream = await post(url, inputs, state);\n        if (!stream)\n            break;\n        for await (const result of stream) {\n            state = JSON.stringify(result.state);\n            yield result;\n            inputs = result.inputs;\n        }\n        if (!state)\n            break;\n    }\n}\n//# sourceMappingURL=remote.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst getHandlerFunction = (handler) => {\n    if (handler instanceof Function)\n        return handler;\n    if (handler.invoke)\n        return handler.invoke;\n    throw new Error(\"Invalid handler\");\n};\nexport const callHandler = async (handler, inputs, context) => {\n    // if (handler instanceof Function) return handler(inputs, context);\n    // if (handler.invoke) return handler.invoke(inputs, context);\n    const handlerFunction = getHandlerFunction(handler);\n    return new Promise((resolve) => {\n        handlerFunction(inputs, context)\n            .then(resolve)\n            .catch((error) => {\n            resolve({ $error: { error } });\n        });\n    });\n};\nexport const handlersFromKits = (kits) => {\n    return kits.reduce((handlers, kit) => {\n        // If multiple kits have the same handler, the kit earlier in the list\n        // gets precedence, including upstream kits getting precedence over kits\n        // defined in the graph.\n        //\n        // TODO: This means kits are fallback, consider non-fallback as well.\n        return { ...kit.handlers, ...handlers };\n    }, {});\n};\n//# sourceMappingURL=handler.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst template = (edges, direction) => {\n    return `%%{init: 'themeVariables': { 'fontFamily': 'Fira Code, monospace' }}%%\ngraph ${direction};\n${edges}\nclassDef default stroke:#ffab40,fill:#fff2ccff,color:#000\nclassDef input stroke:#3c78d8,fill:#c9daf8ff,color:#000\nclassDef output stroke:#38761d,fill:#b6d7a8ff,color:#000\nclassDef passthrough stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef slot stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef config stroke:#a64d79,fill:#ead1dcff,color:#000\nclassDef secrets stroke:#db4437,fill:#f4cccc,color:#000\nclassDef slotted stroke:#a64d79`;\n};\nconst unstyledTemplate = (edges, direction) => {\n    return `graph ${direction};\n${edges}`;\n};\nconst properNodeId = (node) => {\n    // Mermaid gets confused by hyphens in node ids\n    // For example `get-graph` id will throw a syntax error, because it thinks\n    // that it sees the `graph` token.\n    return node && node.replace(/-/g, \"\");\n};\nconst shape = (descriptor, idPrefix = \"\") => {\n    if (!descriptor)\n        return \"\";\n    const node = descriptor.id;\n    const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n    const nodeId = `${prefix}${properNodeId(node)}`;\n    const nodeType = descriptor.type;\n    const text = `\"${nodeType} <br> id='${node}'\"`;\n    switch (nodeType) {\n        case \"include\":\n            return `${nodeId}[[${text}]]:::include`;\n        case \"slot\":\n            return `${nodeId}((${text})):::slot`;\n        case \"passthrough\":\n            return `${nodeId}((${text})):::passthrough`;\n        case \"input\":\n            return `${nodeId}[/${text}/]:::input`;\n        case \"secrets\":\n            return `${nodeId}(${text}):::secrets`;\n        case \"output\":\n            return `${nodeId}{{${text}}}:::output`;\n        default:\n            return `${nodeId}[${text}]`;\n    }\n};\nconst describeEdge = (edge, nodeMap, idPrefix = \"\") => {\n    const from = edge.from;\n    const fromNode = shape(nodeMap.get(from), idPrefix);\n    const to = edge.to;\n    const toNode = shape(nodeMap.get(to), idPrefix);\n    const input = edge.in;\n    const output = edge.out;\n    const optional = edge.optional;\n    const constant = edge.constant;\n    if (output === \"*\") {\n        return `${fromNode} -- all --> ${toNode}`;\n    }\n    if (output && input) {\n        if (optional)\n            return `${fromNode} -. \"${output}->${input}\" .-> ${toNode}`;\n        if (constant)\n            return `${fromNode} -- \"${output}->${input}\" --o ${toNode}`;\n        return `${fromNode} -- \"${output}->${input}\" --> ${toNode}`;\n    }\n    return `${fromNode} --> ${toNode}`;\n};\nclass MermaidGenerator {\n    nodeMap;\n    edges;\n    nodes;\n    idPrefix;\n    subgraphs;\n    constructor(graph, idPrefix = \"\") {\n        const { edges, nodes } = graph;\n        this.nodeMap = new Map(nodes.map((node) => [node.id, node]));\n        this.edges = edges;\n        this.nodes = nodes;\n        this.idPrefix = idPrefix;\n        this.subgraphs = graph.graphs || {};\n    }\n    handleSlotted(fromNode, idPrefix) {\n        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n        const type = fromNode.type;\n        if (type !== \"include\")\n            return \"\";\n        const slotted = fromNode.configuration?.slotted;\n        if (!slotted)\n            return \"\";\n        const subgraphs = Object.entries(slotted).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, \"slotted\", fromNode, `${prefix}${fromNode.id}`));\n        return subgraphs.join(\"\\n\");\n    }\n    handleLambda(fromNode, idPrefix) {\n        const prefix = idPrefix ? `${properNodeId(idPrefix)}_` : \"\";\n        const board = fromNode.configuration?.board;\n        if (!board)\n            return \"\";\n        const capability = board;\n        if (capability.kind !== \"board\")\n            return \"\";\n        const graph = capability.board;\n        return this.describeSubgraph(graph, fromNode.id, \"lamdba\", fromNode, `${prefix}${fromNode.id}`);\n    }\n    describeSubgraphs(edge, idPrefix = \"\") {\n        const fromNode = this.nodeMap.get(edge.from);\n        if (!fromNode)\n            return \"\";\n        const lamdba = this.handleLambda(fromNode, idPrefix);\n        const slotted = this.handleSlotted(fromNode, idPrefix);\n        return `${slotted}${lamdba}`;\n    }\n    describeSubgraph(subgraph, name, edgeName, fromNode, idPrefix) {\n        const subgraphGenerator = new MermaidGenerator(subgraph, idPrefix);\n        const edges = subgraphGenerator.describeGraph();\n        const prefix = this.idPrefix ? `${properNodeId(this.idPrefix)}_` : \"\";\n        const subgraphEdge = edgeName && fromNode\n            ? `sg_${properNodeId(name)}:::slotted -- \"${edgeName}->${edgeName}\" --o ${prefix}${properNodeId(fromNode.id)}\\n`\n            : \"\";\n        return `\\nsubgraph sg_${properNodeId(name)} [${name}]\\n${edges}\\nend\\n${subgraphEdge}`;\n    }\n    describeGraph(ignoreSubgraphs = false) {\n        const result = this.edges.map((edge) => {\n            const mermEdge = describeEdge(edge, this.nodeMap, this.idPrefix);\n            const mermSubgraphs = ignoreSubgraphs\n                ? \"\"\n                : this.describeSubgraphs(edge, this.idPrefix);\n            return `${mermEdge}${mermSubgraphs}`;\n        });\n        const subgraphs = ignoreSubgraphs\n            ? \"\"\n            : Object.entries(this.subgraphs).map(([name, subgraph]) => this.describeSubgraph(subgraph, name, undefined, undefined, `${name}${this.idPrefix}`));\n        return [...result, ...subgraphs].join(\"\\n\");\n    }\n}\nexport const toMermaid = (graph, direction = \"TD\", unstyled = false, ignoreSubgraphs = false) => {\n    const generator = new MermaidGenerator(graph);\n    const edges = generator.describeGraph(ignoreSubgraphs);\n    return unstyled\n        ? unstyledTemplate(edges, direction)\n        : template(edges, direction);\n};\n//# sourceMappingURL=mermaid.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const getSchemaType = (value) => {\n    if (value === null || value === undefined) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"array\";\n    }\n    return typeof value;\n};\nexport class SchemaBuilder {\n    additionalProperties = false;\n    required = [];\n    properties = {};\n    build() {\n        const result = {\n            type: \"object\",\n            properties: this.properties,\n            additionalProperties: this.additionalProperties,\n        };\n        if (this.required.length > 0) {\n            result.required = this.required;\n        }\n        return result;\n    }\n    setAdditionalProperties(additionalProperties) {\n        if (additionalProperties !== undefined) {\n            this.additionalProperties = additionalProperties;\n        }\n        return this;\n    }\n    addInputs(inputs) {\n        if (!inputs)\n            return this;\n        Object.entries(inputs).forEach(([name, value]) => {\n            this.addProperty(name, { type: getSchemaType(value) });\n        });\n        return this;\n    }\n    addProperty(name, schema) {\n        this.properties[name] = schema;\n        return this;\n    }\n    addProperties(properties) {\n        Object.entries(properties).forEach(([name, schema]) => {\n            this.addProperty(name, schema);\n        });\n        return this;\n    }\n    addRequired(required) {\n        if (!required)\n            return this;\n        if (typeof required === \"string\") {\n            this.required = [...this.required, required];\n        }\n        else if (Array.isArray(required) && required.length > 0) {\n            this.required = [...this.required, ...required];\n        }\n        return this;\n    }\n    static empty(additionalProperties = false) {\n        return new SchemaBuilder()\n            .setAdditionalProperties(additionalProperties)\n            .build();\n    }\n}\n//# sourceMappingURL=schema.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { InputStageResult } from \"./run.js\";\nexport const createErrorMessage = (inputName, metadata = {}, required) => {\n    const boardTitle = metadata.title ?? metadata?.url;\n    const requiredText = required ? \"required \" : \"\";\n    return `Missing ${requiredText}input \"${inputName}\"${boardTitle ? ` for board \"${boardTitle}\".` : \".\"}`;\n};\nexport const bubbleUpInputsIfNeeded = async (metadata, context, descriptor, result) => {\n    // If we have no way to bubble up inputs, we just return and not\n    // enforce required inputs.\n    if (!context.requestInput)\n        return;\n    const outputs = (await result.outputsPromise) ?? {};\n    const reader = new InputSchemaReader(outputs, result.inputs);\n    result.outputsPromise = reader.read(createBubbleHandler(metadata, context, descriptor));\n};\nexport const createBubbleHandler = (metadata, context, descriptor) => {\n    return (async (name, schema, required) => {\n        if (required) {\n            throw new Error(createErrorMessage(name, metadata, required));\n        }\n        if (schema.default !== undefined) {\n            if (\"type\" in schema && schema.type !== \"string\") {\n                return JSON.parse(schema.default);\n            }\n            return schema.default;\n        }\n        const value = await context.requestInput?.(name, schema, descriptor);\n        if (value === undefined) {\n            throw new Error(createErrorMessage(name, metadata, required));\n        }\n        return value;\n    });\n};\nexport class InputSchemaReader {\n    #currentOutputs;\n    #inputs;\n    constructor(currentOutputs, inputs) {\n        this.#currentOutputs = currentOutputs;\n        this.#inputs = inputs;\n    }\n    async read(handler) {\n        if (!(\"schema\" in this.#inputs))\n            return this.#currentOutputs;\n        const schema = this.#inputs.schema;\n        if (!schema.properties)\n            return this.#currentOutputs;\n        const entries = Object.entries(schema.properties);\n        const newOutputs = {};\n        for (const [name, property] of entries) {\n            if (name in this.#currentOutputs) {\n                newOutputs[name] = this.#currentOutputs[name];\n                continue;\n            }\n            const required = schema.required?.includes(name) ?? false;\n            const value = await handler(name, property, required);\n            newOutputs[name] = value;\n        }\n        return {\n            ...this.#currentOutputs,\n            ...newOutputs,\n        };\n    }\n}\nexport class RequestedInputsManager {\n    #context;\n    #cache = new Map();\n    constructor(context) {\n        this.#context = context;\n    }\n    createHandler(next, result) {\n        return async (name, schema, node) => {\n            const cachedValue = this.#cache.get(name);\n            if (cachedValue !== undefined)\n                return cachedValue;\n            const descriptor = { id: node.id, type: node.type };\n            const requestInputResult = {\n                ...result,\n                descriptor,\n                inputs: {\n                    schema: { type: \"object\", properties: { [name]: schema } },\n                },\n            };\n            //console.log(\"requestInputResult\", requestInputResult);\n            await next(new InputStageResult(requestInputResult, undefined, -1));\n            const outputs = await requestInputResult.outputsPromise;\n            let value = outputs && outputs[name];\n            if (value === undefined) {\n                value = await this.#context.requestInput?.(name, schema, descriptor);\n            }\n            if (!schema.transient)\n                this.#cache.set(name, value);\n            return value;\n        };\n    }\n}\n//# sourceMappingURL=bubble.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// only here for historical purposes. Use asyncGen instead.\n// Remove this when we're sure we don't need it anymore.\nexport const asyncGenOld = (callback) => {\n    let proceedToNext;\n    let nextCalled;\n    let nextThrew;\n    const next = async (result) => {\n        nextCalled(result);\n        return new Promise((resolve) => {\n            proceedToNext = resolve;\n        });\n    };\n    return {\n        [Symbol.asyncIterator]() {\n            let waitForCallbackToCallNext;\n            let done = false;\n            const resolver = (resolve, reject) => {\n                nextCalled = resolve;\n                nextThrew = reject;\n            };\n            waitForCallbackToCallNext = new Promise(resolver);\n            proceedToNext = () => {\n                callback(next)\n                    .then(() => {\n                    done = true;\n                    nextCalled(undefined);\n                })\n                    .catch((err) => {\n                    nextThrew(err);\n                });\n            };\n            return {\n                async next() {\n                    proceedToNext && proceedToNext();\n                    const value = await waitForCallbackToCallNext;\n                    waitForCallbackToCallNext = new Promise(resolver);\n                    return { done, value };\n                },\n            };\n        },\n    };\n};\nconst noop = () => {\n    /* noop */\n};\nclass AsyncGenQueue {\n    #queue = [];\n    #wroteIntoQueue = noop;\n    #whenQueuedUp;\n    #lastReceipt;\n    abort = noop;\n    constructor() {\n        this.#setQueuePromise();\n    }\n    #setQueuePromise() {\n        this.#whenQueuedUp = new Promise((resolve, reject) => {\n            this.#wroteIntoQueue = resolve;\n            this.abort = reject;\n        });\n    }\n    #addToQueue(entry) {\n        this.#queue.push(entry);\n        if (this.#queue.length == 1) {\n            this.#wroteIntoQueue();\n            this.#setQueuePromise();\n        }\n    }\n    async write(value) {\n        return new Promise((receipt) => {\n            this.#addToQueue({ value, receipt });\n        });\n    }\n    async read() {\n        this.#lastReceipt && this.#lastReceipt();\n        if (this.#queue.length === 0) {\n            await this.#whenQueuedUp;\n        }\n        const entry = this.#queue.shift();\n        if (!entry) {\n            throw new Error(\"asyncGen queue should never be empty.\");\n        }\n        this.#lastReceipt = entry.receipt;\n        if (!entry.value) {\n            return { done: true, value: undefined };\n        }\n        return { done: false, value: entry.value };\n    }\n    close() {\n        this.#addToQueue({ value: undefined, receipt: noop });\n    }\n}\nclass AsyncGenIterator {\n    #callback;\n    #firstTime = true;\n    #queue = new AsyncGenQueue();\n    constructor(callback) {\n        this.#callback = callback;\n    }\n    /**\n     * Called by the callback to advance to the next value.\n     * Roughly equivalent to \"yield\":\n     * ```ts\n     * yield value;\n     * ```\n     * same as\n     * ```ts\n     * await next(value);\n     * ```\n     * @param value\n     */\n    async #next(value) {\n        return this.#queue.write(value);\n    }\n    async next() {\n        if (this.#firstTime) {\n            this.#firstTime = false;\n            this.#callback(this.#next.bind(this))\n                .then(() => {\n                this.#queue.close();\n            })\n                .catch((err) => {\n                this.#queue.abort(err);\n            });\n        }\n        return this.#queue.read();\n    }\n}\n/**\n * Converts async/await style code into an async generator.\n * Useful when you need to combine arrow-style functions and yield.\n *\n * Example:\n *\n * ```ts\n * async function* foo() {\n *   yield 1;\n *   yield* asyncGen(async (next) => {\n *     await next(2);\n *     await next(3);\n *   });\n *   yield 4;\n * }\n *\n * for await (const val of foo()) {\n *   console.log(val);\n * }\n * ```\n *\n * This code will print:\n *\n * ```\n * 1\n * 2\n * 3\n * 4\n * ```\n *\n * @param callback A callback that will be called with a `next` function.\n * The callback should call `next` with the next value to yield.\n * @returns An async generator.\n */\nexport const asyncGen = (callback) => {\n    return {\n        [Symbol.asyncIterator]() {\n            return new AsyncGenIterator(callback);\n        },\n    };\n};\n//# sourceMappingURL=async-gen.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { loadRunnerState, saveRunnerState } from \"./serialization.js\";\n// TODO: Support stream serialization somehow.\n// see https://github.com/breadboard-ai/breadboard/issues/423\nexport class StackManager {\n    #stack;\n    #result;\n    constructor(stack) {\n        this.#stack = structuredClone(stack) || [];\n    }\n    onGraphStart() {\n        this.#stack.push({ graph: 0, node: 0 });\n    }\n    onNodeStart(result) {\n        this.#stack[this.#stack.length - 1].node++;\n        this.#result = result;\n    }\n    onNodeEnd() {\n        // TODO: implement\n    }\n    onGraphEnd() {\n        // TODO: implement\n    }\n    async state() {\n        // Assemble the stack from existing pieces.\n        const stack = structuredClone(this.#stack);\n        if (this.#result) {\n            stack[stack.length - 1].state = await saveRunnerState(\"nodestart\", this.#result);\n        }\n        return stack;\n    }\n}\nexport const traversalResultFromStack = (stack) => {\n    const { state } = stack[stack.length - 1];\n    return state ? loadRunnerState(state).state : undefined;\n};\n//# sourceMappingURL=stack.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachine } from \"./traversal/machine.js\";\nimport { InputStageResult, OutputStageResult } from \"./run.js\";\nimport { BoardLoader } from \"./loader.js\";\nimport { runRemote } from \"./remote.js\";\nimport { callHandler, handlersFromKits } from \"./handler.js\";\nimport { toMermaid } from \"./mermaid.js\";\nimport { SchemaBuilder } from \"./schema.js\";\nimport { RequestedInputsManager, bubbleUpInputsIfNeeded } from \"./bubble.js\";\nimport { asyncGen } from \"./utils/async-gen.js\";\nimport { StackManager } from \"./stack.js\";\nimport { timestamp } from \"./timestamp.js\";\nimport breadboardSchema from \"@google-labs/breadboard-schema/breadboard.schema.json\" assert { type: \"json\" };\n/**\n * This class is the main entry point for running a board.\n *\n * It contains everything that is needed to run a board, either loaded from a\n * serialized board or created via the {Board} class.\n *\n * See the {Board} class for a way to build a board that can also be serialized.\n */\nexport class BoardRunner {\n    // GraphDescriptor implementation.\n    url;\n    title;\n    description;\n    $schema;\n    version;\n    edges = [];\n    nodes = [];\n    kits = [];\n    graphs;\n    args;\n    #slots = {};\n    #validators = [];\n    /**\n     * The parent board, if this is board is a subgraph of a larger board.\n     */\n    #outerGraph;\n    /**\n     *\n     * @param metadata - optional metadata for the board. Use this parameter\n     * to provide title, description, version, and URL for the board.\n     */\n    constructor({ url, title, description, version, $schema } = {\n        $schema: breadboardSchema.$id,\n    }) {\n        Object.assign(this, {\n            $schema: $schema ?? breadboardSchema.$id,\n            url,\n            title,\n            description,\n            version,\n        });\n    }\n    /**\n     * Runs the board. This method is an async generator that\n     * yields the results of each stage of the run.\n     *\n     * Conceptually, when we ask the board to run, it will occasionally pause\n     * and give us a chance to interact with it.\n     *\n     * It's typically used like this:\n     *\n     * ```js\n     * for await (const stop of board.run()) {\n     * // do something with `stop`\n     * }\n     * ```\n     *\n     * The `stop` iterator result will be a `RunResult` and provide ability\n     * to influence running of the board.\n     *\n     * The two key use cases are providing input and receiving output.\n     *\n     * If `stop.type` is `input`, the board is waiting for input values.\n     * When that is the case, use `stop.inputs` to provide input values.\n     *\n     * If `stop.type` is `output`, the board is providing output values.\n     * When that is the case, use `stop.outputs` to receive output values.\n     *\n     * See [Chapter 8: Continuous runs](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-8-continuous-runs) of Breadboard tutorial for an example of how to use this method.\n     *\n     * @param probe - an optional probe. If provided, the board will dispatch\n     * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.\n     * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.\n     * @param result - an optional result of a previous run. If provided, the\n     * board will resume from the state of the previous run.\n     * @param kits - an optional map of kits to use when running the board.\n     */\n    async *run(context = {}, result) {\n        const base = context.base || new URL(this.url || \"\", import.meta.url);\n        yield* asyncGen(async (next) => {\n            const { probe } = context;\n            const handlers = await BoardRunner.handlersFromBoard(this, context.kits);\n            const slots = { ...this.#slots, ...context.slots };\n            this.#validators.forEach((validator) => validator.addGraph(this));\n            const machine = new TraversalMachine(this, result?.state);\n            const requestedInputs = new RequestedInputsManager(context);\n            const invocationPath = context.invocationPath || [];\n            const stack = new StackManager(context.state);\n            await probe?.report?.({\n                type: \"graphstart\",\n                data: { metadata: this, path: invocationPath, timestamp: timestamp() },\n            });\n            let invocationId = 0;\n            stack.onGraphStart();\n            const path = () => [...invocationPath, invocationId];\n            for await (const result of machine) {\n                invocationId++;\n                const { inputs, descriptor, missingInputs } = result;\n                if (result.skip) {\n                    await probe?.report?.({\n                        type: \"skip\",\n                        data: {\n                            node: descriptor,\n                            inputs,\n                            missingInputs,\n                            path: path(),\n                            timestamp: timestamp(),\n                        },\n                    });\n                    continue;\n                }\n                stack.onNodeStart(result);\n                await probe?.report?.({\n                    type: \"nodestart\",\n                    data: {\n                        node: descriptor,\n                        inputs,\n                        path: path(),\n                        timestamp: timestamp(),\n                    },\n                    state: await stack.state(),\n                });\n                let outputsPromise = undefined;\n                if (descriptor.type === \"input\") {\n                    await next(new InputStageResult(result, await stack.state(), invocationId));\n                    await bubbleUpInputsIfNeeded(this, context, descriptor, result);\n                    outputsPromise = result.outputsPromise;\n                }\n                else if (descriptor.type === \"output\") {\n                    await next(new OutputStageResult(result, invocationId));\n                    outputsPromise = result.outputsPromise;\n                }\n                else {\n                    const handler = handlers[descriptor.type];\n                    if (!handler)\n                        throw new Error(`No handler for node type \"${descriptor.type}\"`);\n                    const newContext = {\n                        ...context,\n                        board: this,\n                        descriptor,\n                        outerGraph: this.#outerGraph || this,\n                        base,\n                        slots,\n                        kits: [...(context.kits || []), ...this.kits],\n                        requestInput: requestedInputs.createHandler(next, result),\n                        invocationPath: path(),\n                        state: await stack.state(),\n                    };\n                    outputsPromise = callHandler(handler, inputs, newContext);\n                }\n                stack.onNodeEnd();\n                await probe?.report?.({\n                    type: \"nodeend\",\n                    data: {\n                        node: descriptor,\n                        inputs,\n                        outputs: (await outputsPromise),\n                        validatorMetadata: this.#validators.map((validator) => validator.getValidatorMetadata(descriptor)),\n                        path: path(),\n                        timestamp: timestamp(),\n                    },\n                });\n                result.outputsPromise = outputsPromise;\n            }\n            stack.onGraphEnd();\n            await probe?.report?.({\n                type: \"graphend\",\n                data: { metadata: this, path: invocationPath, timestamp: timestamp() },\n            });\n        });\n    }\n    get validators() {\n        return this.#validators;\n    }\n    /**\n     * A simplified version of `run` that runs the board until the board provides\n     * an output, and returns that output.\n     *\n     * This is useful for running boards that don't have multiple outputs\n     * or the the outputs are only expected to be visited once.\n     *\n     * @param inputs - the input values to provide to the board.\n     * @param probe - an optional probe. If provided, the board will dispatch\n     * events to it. See [Chapter 7: Probes](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the Breadboard tutorial for more information.\n     * @param slots - an optional map of slotted graphs. See [Chapter 6: Boards with slots](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-6-boards-with-slots) of the Breadboard tutorial for more information.\n     * @param kits - an optional map of kits to use when running the board.\n     * @returns - outputs provided by the board.\n     */\n    async runOnce(inputs, context = {}) {\n        const args = { ...inputs, ...this.args };\n        const { probe } = context;\n        if (context.board && context.descriptor) {\n            // If called from another node in a parent board, add the parent board's\n            // validators to the board, with the current arguments.\n            for (const validator of context.board.validators)\n                this.addValidator(validator.getSubgraphValidator(context.descriptor, Object.keys(args)));\n        }\n        try {\n            let outputs = {};\n            const path = context.invocationPath || [];\n            for await (const result of this.run(context)) {\n                if (result.type === \"input\") {\n                    // Pass the inputs to the board. If there are inputs bound to the\n                    // board (e.g. from a lambda node that had incoming wires), they will\n                    // overwrite supplied inputs.\n                    result.inputs = args;\n                }\n                else if (result.type === \"output\") {\n                    outputs = result.outputs;\n                    // Exit once we receive the first output.\n                    await probe?.report?.({\n                        type: \"nodeend\",\n                        data: {\n                            node: result.node,\n                            inputs: result.inputs,\n                            outputs,\n                            path: [...path, result.invocationId],\n                            timestamp: timestamp(),\n                        },\n                    });\n                    await probe?.report?.({\n                        type: \"graphend\",\n                        data: { metadata: this, path, timestamp: timestamp() },\n                    });\n                    break;\n                }\n            }\n            return outputs;\n        }\n        catch (e) {\n            // Unwrap unhandled error (handled errors are just outputs of the board!)\n            if (e.cause)\n                return { $error: e.cause };\n            else\n                throw e;\n        }\n    }\n    /**\n     * Add validator to the board.\n     * Will call .addGraph() on the validator before executing a graph.\n     *\n     * @param validator - a validator to add to the board.\n     */\n    addValidator(validator) {\n        this.#validators.push(validator);\n    }\n    /**\n     * Returns a [Mermaid](https://mermaid-js.github.io/mermaid/#/) representation\n     * of the board.\n     *\n     * This is useful for visualizing the board.\n     *\n     * @returns - a string containing the Mermaid representation of the board.\n     */\n    mermaid(direction = \"TD\", unstyled = false, ignoreSubgraphs = false) {\n        return toMermaid(this, direction, unstyled, ignoreSubgraphs);\n    }\n    /**\n     * Creates a new board from JSON. If you have a serialized board, you can\n     * use this method to turn it into into a new Board instance.\n     *\n     * @param graph - the JSON representation of the board.\n     * @returns - a new `Board` instance.\n     */\n    static async fromGraphDescriptor(graph) {\n        const breadboard = new BoardRunner(graph);\n        breadboard.edges = graph.edges;\n        breadboard.nodes = graph.nodes;\n        breadboard.graphs = graph.graphs;\n        breadboard.args = graph.args;\n        return breadboard;\n    }\n    /**\n     * Loads a board from a URL or a file path.\n     *\n     * @param url - the URL or a file path to the board.\n     * @param slots - optional slots to provide to the board.\n     * @returns - a new `Board` instance.\n     */\n    static async load(url, options) {\n        const { base, slotted, outerGraph } = options || {};\n        const loader = new BoardLoader({\n            base,\n            graphs: outerGraph?.graphs,\n        });\n        const { isSubgraph, graph } = await loader.load(url);\n        const board = await BoardRunner.fromGraphDescriptor(graph);\n        if (isSubgraph)\n            board.#outerGraph = outerGraph;\n        board.#slots = slotted || {};\n        return board;\n    }\n    /**\n     * Creates a runnable board from a BreadboardCapability,\n     * @param board {BreadboardCapability} A BreadboardCapability including a board\n     * @returns {Board} A runnable board.\n     */\n    static async fromBreadboardCapability(board) {\n        if (board.kind !== \"board\" || !board.board) {\n            throw new Error(`Expected a \"board\" Capability, but got ${board}`);\n        }\n        // TODO: Use JSON schema to validate rather than this hack.\n        const boardish = board.board;\n        if (!(boardish.edges && boardish.kits && boardish.nodes)) {\n            throw new Error('Supplied \"board\" Capability argument is not actually a board');\n        }\n        // If all we got is a GraphDescriptor, build a runnable board from it.\n        // TODO: Use JSON schema to validate rather than this hack.\n        let runnableBoard = board.board;\n        if (!runnableBoard.runOnce) {\n            runnableBoard = await BoardRunner.fromGraphDescriptor(boardish);\n        }\n        return runnableBoard;\n    }\n    static async handlersFromBoard(board, upstreamKits = []) {\n        const core = new Core();\n        const kits = [core, ...upstreamKits, ...board.kits];\n        return handlersFromKits(kits);\n    }\n    static runRemote = runRemote;\n}\n// HACK: Move the Core and Lambda logic into the same file as the BoardRunner to remove the cyclic module dependency (Lambda needs BoardRunner, BoardRunner needs Core).\nclass Core {\n    handlers;\n    constructor() {\n        this.handlers = {\n            lambda: {\n                describe: async (inputs) => ({\n                    inputSchema: new SchemaBuilder()\n                        .setAdditionalProperties(true)\n                        .addInputs(inputs)\n                        .addProperty(\"board\", {\n                        title: \"board\",\n                        description: \"The board to run.\",\n                        type: \"object\",\n                    })\n                        .build(),\n                    outputSchema: new SchemaBuilder()\n                        .addProperty(\"board\", {\n                        title: \"board\",\n                        description: \"The now-runnable board.\",\n                        type: \"object\",\n                    })\n                        .build(),\n                }),\n                invoke: async (inputs) => {\n                    const { board, ...args } = inputs;\n                    if (!board || board.kind !== \"board\" || !board.board)\n                        throw new Error(`Lambda node requires a BoardCapability as \"board\" input`);\n                    const runnableBoard = {\n                        ...(await BoardRunner.fromBreadboardCapability(board)),\n                        args,\n                    };\n                    return {\n                        board: { ...board, board: runnableBoard },\n                    };\n                },\n            },\n        };\n    }\n}\n//# sourceMappingURL=runner.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class IdVendor {\n    #map = new Map();\n    vendId(o, prefix) {\n        let count = this.#map.get(o) || 0;\n        count++;\n        this.#map.set(o, count);\n        return `${prefix}-${count}`;\n    }\n}\n//# sourceMappingURL=id.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { IdVendor } from \"./id.js\";\nconst specRegex = /^((?<a>.*)(?<dir><-|->))?(?<b>[^(.|?)]*)(?<q>\\.|\\?)?$/m;\n/**\n * Parses a given string according to the following grammar:\n * *|[{out}[->{in}][?|.]]\n * - if \"*\" is specified, this is all-value wiring. All available output values\n * will pass through this edge as input values.\n * - if \"out\" is not specified, this is an empty string, which means control-only\n * edge. No data passes through this edge.\n * - if \"in\" is not specified, \"in\" is assumed to be of the same value\n * as \"out\".\n * - if \"?\" is specified, this is an optional edge.\n * - if \".\" is specified, this is a constant edge.\n */\nexport const parseSpec = (spec) => {\n    const result = { ltr: true };\n    const match = spec.match(specRegex);\n    if (!match)\n        throw new Error(`Invalid edge spec: ${spec}`);\n    const { a, b, dir, q } = match?.groups;\n    const ltr = dir !== \"<-\";\n    result.ltr = ltr;\n    const optional = q === \"?\";\n    const constant = q === \".\";\n    result.edge = {};\n    if (constant)\n        result.edge.constant = true;\n    if (optional)\n        result.edge.optional = true;\n    if (!a && !b)\n        return result;\n    if (a === \"*\" || b === \"*\") {\n        result.edge.out = \"*\";\n        return result;\n    }\n    if (!a) {\n        result.edge.out = b;\n        result.edge.in = b;\n        return result;\n    }\n    if (!b) {\n        result.edge.out = a;\n        result.edge.in = a;\n        return result;\n    }\n    if (ltr) {\n        result.edge.out = a;\n        result.edge.in = b;\n    }\n    else {\n        result.edge.out = b;\n        result.edge.in = a;\n    }\n    return result;\n};\nconst nodeIdVendor = new IdVendor();\nexport const hasValues = (configuration) => {\n    return Object.values(configuration).length > 0;\n};\nexport class Node {\n    #descriptor;\n    #breadboard;\n    constructor(breadboard, kit, type, configuration, id) {\n        this.#breadboard = breadboard.currentBoardToAddTo();\n        this.#descriptor = {\n            id: id ?? nodeIdVendor.vendId(this.#breadboard, type),\n            type,\n        };\n        if (configuration && hasValues(configuration)) {\n            // For convenience we allow passing nodes as configuration, which are\n            // instead turned into constant incoming wires behind the scenes.\n            const incomingWiresToAdd = Object.entries(configuration).filter(([_, value]) => value instanceof Node);\n            for (const [wire, from] of incomingWiresToAdd) {\n                delete configuration[wire];\n                if (wire.indexOf(\"->\") !== -1)\n                    throw Error(\"Cannot pass output wire in confdig\");\n                this.wire(wire.indexOf(\"<-\") === -1 ? `${wire}<-.` : wire, from);\n            }\n            this.#descriptor.configuration = configuration;\n        }\n        if (kit?.url && !this.#breadboard.kits.find((k) => k.url === kit.url))\n            this.#breadboard.kits.push(kit);\n        this.#breadboard.addNode(this.#descriptor);\n    }\n    wire(spec, to) {\n        const { ltr, edge } = parseSpec(spec);\n        const [fromNode, toNode] = ltr\n            ? [this, to]\n            : [to, this];\n        const result = {\n            from: fromNode.#descriptor.id,\n            to: toNode.#descriptor.id,\n            ...edge,\n        };\n        if (fromNode.#breadboard !== toNode.#breadboard) {\n            // Note edge on the target board, which is the only currently supported\n            // version. Board.lambda() will use this to create a constant wire from\n            // the input node to this node, and from fromNode to the lambda node in\n            // the parent context, recursively if necessary.\n            toNode.#breadboard.addEdgeAcrossBoards(result, fromNode.#breadboard, toNode.#breadboard);\n        }\n        else {\n            this.#breadboard.addEdge(result);\n        }\n        return this;\n    }\n    get id() {\n        return this.#descriptor.id;\n    }\n}\n//# sourceMappingURL=node.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Node } from \"../node.js\";\n/**\n * Takes a kit constructor and creates a kit instance that can be used at\n * run-time.\n *\n * @param ctor Kit constructor\n * @returns A kit instance prepare for run-time use.\n */\nexport const asRuntimeKit = (ctor) => {\n    return new ctor({\n        create: () => {\n            throw Error(\"Node instantiation can't (yet) happen during runtime\");\n        },\n    });\n};\n/**\n * Takes a kit constructor and creates a kit instance that can be used at\n * compose-time (wiring the graph).\n * @param ctor Kit constructor\n * @param board The board with which the kit is associated.\n * @returns Kit instance prepared for compose-time use.\n */\nexport const asComposeTimeKit = (ctor, board) => {\n    return new ctor({\n        create: (...args) => {\n            return new Node(board, ...args);\n        },\n        getConfigWithLambda: (config) => {\n            return getConfigWithLambda(board, config);\n        },\n    });\n};\n/**\n * Synctactic sugar for node factories that accept lambdas. This allows passing\n * either\n *  - A JS function that is a lambda function defining the board\n *  - A board capability, i.e. the result of calling lambda()\n *  - A board node, which should be a node with a `board` output\n * or\n *  - A regular config, with a `board` property with any of the above.\n *\n * @param config {ConfigOrLambda} the overloaded config\n * @returns {NodeConfigurationConstructor} config with a board property\n */\nconst getConfigWithLambda = (board, config) => {\n    // Did we get a graph?\n    const gotGraph = config.nodes !== undefined &&\n        config.edges !== undefined &&\n        config.kits !== undefined;\n    // Look for functions, nodes and board capabilities.\n    const gotBoard = gotGraph ||\n        typeof config === \"function\" ||\n        config instanceof Node ||\n        (config.kind === \"board\" &&\n            config.board);\n    const result = (gotBoard\n        ? { board: gotGraph ? { kind: \"board\", board: config } : config }\n        : config);\n    // Convert passed JS function into a board node.\n    if (typeof result.board === \"function\")\n        result.board = board.lambda(result.board);\n    return result;\n};\n//# sourceMappingURL=ctors.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BoardRunner } from \"./runner.js\";\nimport { Node } from \"./node.js\";\nimport { asComposeTimeKit } from \"./kits/ctors.js\";\n/**\n * This is the heart of the Breadboard library.\n * Just like for hardware makers, the `Board` is the place where wiring of\n * a prototype happens.\n *\n * To start making, create a new breadboard:\n *\n * ```js\n * const board = new Board();\n * ```\n *\n * For more information on how to use Breadboard, start with [Chapter 1: Hello, world?](https://github.com/breadboard-ai/breadboard/tree/main/packages/breadboard/docs/tutorial#chapter-7-probes) of the tutorial.\n */\nexport class Board extends BoardRunner {\n    #closureStack = [];\n    #topClosure;\n    #acrossBoardsEdges = [];\n    /**\n     * Core nodes. Breadboard won't function without these.\n     * These are always included.\n     */\n    /**\n     * Places an `input` node on the board.\n     *\n     * An `input` node is a node that asks for inputs from the user.\n     *\n     * See [`input` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#input) for more information.\n     *\n     * @param config - optional configuration for the node.\n     * @returns - a `Node` object that represents the placed node.\n     */\n    input(config = {}) {\n        const { $id, ...rest } = config;\n        return new Node(this, undefined, \"input\", { ...rest }, $id);\n    }\n    /**\n     * Places an `output` node on the board.\n     *\n     * An `output` node is a node that provides outputs to the user.\n     *\n     * See [`output` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#output) for more information.\n     *\n     * @param config - optional configuration for the node.\n     * @returns - a `Node` object that represents the placed node.\n     */\n    output(config = {}) {\n        const { $id, ...rest } = config;\n        return new Node(this, undefined, \"output\", { ...rest }, $id);\n    }\n    /**\n     * Place a `lambda` node on the board.\n     *\n     * It is a node that represents a subgraph of nodes. It can be passed to\n     * `invoke` or nodes like `map` (defined in another kit) that invoke boards.\n     *\n     * Input wires are made available as input values to the lambda board.\n     *\n     * `board` is the only output and represents a BoardCapability that invoke and\n     * others consume.\n     *\n     * You can either pass a `Board` or a Javascript function to this method. The\n     * JS function is called with a `board` to add things to, and for convenience,\n     * input and output nodes attached to the board.\n     *\n     * Example: board.lambda((board, input, output) => { input.wire( \"item->item\",\n     * kit.someNode().wire( \"value->value\", output));\n     * });\n     *\n     * @param boardOrFunction A board or a function that builds the board\n     * @param config - optional configuration for the node.\n     * @returns - a `Node` object that represents the placed node.\n     */\n    lambda(boardOrFunction, config = {}) {\n        const { $id, ...rest } = config;\n        let board;\n        let input;\n        if (typeof boardOrFunction === \"function\") {\n            board = new Board();\n            input = board.input();\n            const output = board.output();\n            board.#topClosure = this.#topClosure ?? this;\n            board.#topClosure.#closureStack.push(board);\n            boardOrFunction(board, input, output);\n            board.#topClosure.#closureStack.pop();\n        }\n        else {\n            board = boardOrFunction;\n        }\n        const node = new Node(this, undefined, \"lambda\", {\n            board: { kind: \"board\", board },\n            ...rest,\n        }, $id);\n        // Process edges that span lambdas. We have to turn this into two wires:\n        //  (1) From the input node in the child board to the destination node\n        //  (2) From the source node to this node. If the source node is in a\n        //      parent board, then instead ask parent to wire it up.\n        if (input && board.#acrossBoardsEdges.length > 0) {\n            for (const { edge, from, to } of board.#acrossBoardsEdges) {\n                if (to !== board || !edge.constant)\n                    throw new Error(\"Across board wires: Must be constant and from parent to child\");\n                // Hopefully unique enough name that doesn't class with other inputs\n                const label = `$l-${edge.to}-${edge.in}`;\n                board.addEdge({ ...edge, from: input.id, out: label });\n                const outerEdge = { ...edge, to: node.id, in: label };\n                if (from === this) {\n                    this.addEdge(outerEdge);\n                }\n                else {\n                    this.addEdgeAcrossBoards(outerEdge, from, this);\n                }\n            }\n            // Clear the edges, as they are now added to the board itself.\n            // TODO: Add code in .run() to verify that all edges are consumed.\n            board.#acrossBoardsEdges = [];\n        }\n        return node;\n    }\n    addEdge(edge) {\n        this.edges.push(edge);\n    }\n    addNode(node) {\n        this.nodes.push(node);\n    }\n    /**\n     * Adds a new kit to the board.\n     *\n     * Kits are collections of nodes that are bundled together for a specific\n     * purpose. For example, the [Core Kit](https://github.com/breadboard-ai/breadboard/tree/main/packages/core) provides a nodes that\n     * are useful for making boards.\n     *\n     * Typically, kits are distributed as NPM packages. To add a kit to the board,\n     * simply install it using `npm` or `yarn`, and then add it to the board:\n     *\n     * ```js\n     * import { Board } from \"@google-labs/breadboard\";\n     * import { Core } from \"@google-labs/core-kit\";\n     *\n     * const board = new Board();\n     * const kit = board.addKit(Core);\n     * ```\n     *\n     * @param ctr - the kit constructor.\n     * @returns - the kit object, which is associated with\n     * the board and can be used to place nodes on that board.\n     */\n    addKit(ctr) {\n        const kit = asComposeTimeKit(ctr, this);\n        this.kits.push(kit);\n        return kit;\n    }\n    /**\n     * Used in the context of board.lambda(): Returns the board that is currently\n     * being constructed, according to the nesting level of board.lambda() calls\n     * with JS functions.\n     *\n     * Only called by Node constructor, when adding nodes.\n     */\n    currentBoardToAddTo() {\n        const closureStack = this.#topClosure\n            ? this.#topClosure.#closureStack\n            : this.#closureStack;\n        if (closureStack.length === 0)\n            return this;\n        else\n            return closureStack[closureStack.length - 1];\n    }\n    /**\n     *\n     */\n    addEdgeAcrossBoards(edge, from, to) {\n        if (edge.out === \"*\")\n            throw new Error(\"Across board wires: * wires not supported\");\n        if (!edge.constant)\n            throw new Error(\"Across board wires: Must be constant for now\");\n        if (to !== this)\n            throw new Error(\"Across board wires: Must be invoked on to board\");\n        const closureStack = this.#topClosure\n            ? this.#topClosure.#closureStack\n            : this.#closureStack;\n        if (from !== this.#topClosure && !closureStack.includes(from))\n            throw new Error(\"Across board wires: From must be parent of to\");\n        this.#acrossBoardsEdges.push({ edge, from, to });\n    }\n}\n//# sourceMappingURL=board.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst STREAM_KIND = \"stream\";\nexport class StreamCapability {\n    kind = STREAM_KIND;\n    stream;\n    constructor(stream) {\n        this.stream = stream;\n    }\n}\nexport const clone = (streamCapability) => {\n    const [leave, take] = streamCapability.stream.tee();\n    streamCapability.stream = leave;\n    return take;\n};\nexport const isStreamCapability = (object) => {\n    const maybeStream = object;\n    return (maybeStream &&\n        maybeStream.kind &&\n        maybeStream.kind === STREAM_KIND &&\n        maybeStream.stream instanceof ReadableStream);\n};\n// TODO: Remove this once MessageController is gone.\nconst findStreams = (value, foundStreams) => {\n    if (Array.isArray(value)) {\n        value.forEach((item) => {\n            findStreams(item, foundStreams);\n        });\n    }\n    else if (typeof value === \"object\") {\n        if (value === null || value === undefined)\n            return;\n        const maybeCapability = value;\n        if (maybeCapability.kind && maybeCapability.kind === STREAM_KIND) {\n            foundStreams.push(maybeCapability.stream);\n        }\n        else {\n            Object.values(value).forEach((item) => {\n                findStreams(item, foundStreams);\n            });\n        }\n    }\n};\nexport const stringifyWithStreams = (value) => {\n    const foundStreams = [];\n    return {\n        value: JSON.stringify(value, (key, value) => {\n            if (isStreamCapability(value)) {\n                foundStreams.push(value.stream);\n                return { $type: \"Stream\", id: foundStreams.length - 1 };\n            }\n            return value;\n        }),\n        streams: foundStreams,\n    };\n};\nexport const parseWithStreams = (value, getStream) => {\n    const parsed = JSON.parse(value, (key, value) => {\n        if (typeof value === \"object\" && value !== null) {\n            if (value.$type === \"Stream\" && typeof value.id === \"number\") {\n                return new StreamCapability(getStream(value.id));\n            }\n        }\n        return value;\n    });\n    return parsed;\n};\nexport const getStreams = (value) => {\n    const foundStreams = [];\n    findStreams(value, foundStreams);\n    return foundStreams;\n};\n/**\n * Stubs out all streams in the input values with empty streams.\n * This is useful when we don't want the streams to be transferred.\n * @param data\n * @returns\n */\nexport const stubOutStreams = (data) => {\n    const stringified = stringifyWithStreams(data).value;\n    return parseWithStreams(stringified, () => new ReadableStream());\n};\nexport const portToStreams = (port) => {\n    const readable = new ReadableStream({\n        start(controller) {\n            port.onmessage = (ev) => {\n                if (ev.data === null) {\n                    controller.close();\n                    return;\n                }\n                controller.enqueue(ev.data);\n            };\n        },\n        cancel() {\n            port.onmessage = null;\n        },\n    });\n    const writable = new WritableStream({\n        write(chunk) {\n            const stringified = stringifyWithStreams(chunk);\n            port.postMessage(chunk, stringified.streams);\n        },\n        close() {\n            port.postMessage(null, []);\n        },\n    });\n    return {\n        readable,\n        writable,\n    };\n};\nexport const portFactoryToStreams = (portFactory) => {\n    let streams;\n    const streamsAvailable = new Promise((resolve) => {\n        portFactory().then((port) => {\n            streams = portToStreams(port);\n            resolve();\n        });\n    });\n    const readable = new ReadableStream({\n        async start() {\n            await streamsAvailable;\n        },\n        pull(controller) {\n            return streams.readable.pipeTo(new WritableStream({\n                write(chunk) {\n                    controller.enqueue(chunk);\n                },\n            }));\n        },\n        cancel() {\n            streams.readable.cancel();\n        },\n    });\n    const writable = new WritableStream({\n        async start() {\n            await streamsAvailable;\n        },\n        async write(chunk) {\n            const writer = streams.writable.getWriter();\n            await writer.write(chunk);\n            writer.releaseLock();\n        },\n        async close() {\n            await streams.writable.close();\n        },\n        async abort(reason) {\n            await streams.writable.abort(reason);\n        },\n    });\n    return {\n        readable,\n        writable,\n    };\n};\nexport class WritableResult {\n    #writer;\n    data;\n    constructor(value, writer) {\n        this.#writer = writer;\n        this.data = value;\n    }\n    async reply(chunk) {\n        await this.#writer.write(chunk);\n    }\n}\nclass StreamsAsyncIterator {\n    #reader;\n    #writer;\n    constructor(writable, readable) {\n        this.#reader = readable.getReader();\n        this.#writer = writable.getWriter();\n    }\n    async next() {\n        const { done, value } = await this.#reader.read();\n        if (done) {\n            this.#writer.close();\n            return { done, value: undefined };\n        }\n        return {\n            done: false,\n            value: new WritableResult(value, this.#writer),\n        };\n    }\n    async return() {\n        this.#writer.close();\n        return { done: true, value: undefined };\n    }\n    async throw(err) {\n        this.#writer.abort(err);\n        return { done: true, value: undefined };\n    }\n}\n/**\n * A helper to convert a pair of streams to an async iterable that follows\n * the following protocol:\n * - The async iterable yields a `WritableResult` object.\n * - The `WritableResult` object contains the data from the readable stream.\n * - The `WritableResult` object has a `reply` method that can be used to\n *   write a value as a reply to to data in the readable stream.\n *\n * This is particularly useful with bi-directional streams, when the two\n * streams are semantically connected to each other.\n *\n * @param writable The writable stream.\n * @param readable The readable stream.\n * @returns An async iterable.\n */\nexport const streamsToAsyncIterable = (writable, readable) => {\n    return {\n        async start(chunk) {\n            const writer = writable.getWriter();\n            await writer.write(chunk);\n            writer.releaseLock();\n        },\n        [Symbol.asyncIterator]() {\n            return new StreamsAsyncIterator(writable, readable);\n        },\n    };\n};\n// Polyfill to make ReadableStream async iterable\n// See https://bugs.chromium.org/p/chromium/issues/detail?id=929585\nexport const patchReadableStream = () => {\n    // eslint-disable-next-line\n    // @ts-ignore\n    ReadableStream.prototype[Symbol.asyncIterator] ||\n        // eslint-disable-next-line\n        // @ts-ignore\n        (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {\n            const reader = this.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done)\n                        return;\n                    yield value;\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        });\n};\n// A polyfill for ReadableStream.from:\n// See https://streams.spec.whatwg.org/#rs-from\n// TODO: Do a proper TypeScript types polyfill.\nexport const streamFromAsyncGen = (iterator) => {\n    return new ReadableStream({\n        async pull(controller) {\n            const { value, done } = await iterator.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(value);\n        },\n    });\n};\nexport const streamFromReader = (reader) => {\n    return new ReadableStream({\n        async pull(controller) {\n            const { value, done } = await reader.read();\n            if (done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(value);\n        },\n    }, { highWaterMark: 0 });\n};\nexport const streamFromWriter = (writer) => {\n    return new WritableStream({\n        async write(chunk) {\n            return writer.write(chunk);\n        },\n    }, { highWaterMark: 0 });\n};\n//# sourceMappingURL=stream.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO: This is wraps classic handlers that expected resolved inputs into\n// something that accepts promises. We should either change all handlers to\n// support promises or add a flag or something to support either mode. (Almost\n// all handlers will immediately await, so it's a bit of a pain...)\nexport function handlersFromKit(kit) {\n    return Object.fromEntries(Object.entries(kit.handlers).map(([name, handler]) => {\n        const handlerFunction = handler instanceof Function ? handler : handler.invoke;\n        const describeFunction = handler instanceof Function ? undefined : handler.describe;\n        const describe = describeFunction ? { describe: describeFunction } : {};\n        return [\n            name,\n            {\n                invoke: async (inputs) => {\n                    return handlerFunction((await inputs), {});\n                },\n                ...describe,\n            },\n        ];\n    }));\n}\n//# sourceMappingURL=kits.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class AbstractNode {\n}\n//# sourceMappingURL=types.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AbstractNode, } from \"./types.js\";\nimport { IdVendor } from \"../../id.js\";\nconst nodeIdVendor = new IdVendor();\n// TODO:BASE Extract base class that isn't opinionated about the syntax. Marking\n// methods that should be base as \"TODO:BASE\" below, including complications.\nexport class BaseNode extends AbstractNode {\n    id;\n    type;\n    outgoing = [];\n    incoming = [];\n    configuration = {};\n    #handler;\n    #scope;\n    constructor(handler, scope, config = {}) {\n        super();\n        this.#scope = scope;\n        if (typeof handler === \"string\") {\n            this.type = handler;\n        }\n        else {\n            this.type = \"fn\";\n            this.#handler = handler;\n        }\n        const { $id, ...rest } = config;\n        this.id = $id ?? nodeIdVendor.vendId(scope, this.type);\n        this.configuration = rest;\n    }\n    addIncomingEdge(from, out, in_, constant, schema) {\n        if (from.#scope !== this.#scope)\n            throw new Error(\"Can't connect nodes from different scopes\");\n        const edge = {\n            to: this,\n            from: from,\n            out,\n            in: in_,\n            schema,\n        };\n        if (constant)\n            edge.constant = true;\n        this.incoming.push(edge);\n        from.outgoing.push(edge);\n    }\n    #getHandlerDescribe(scope) {\n        const handler = this.#handler ?? scope.getHandler(this.type);\n        return handler && typeof handler !== \"function\"\n            ? handler.describe\n            : undefined;\n    }\n    // In the end, we need to capture the outputs and resolve the promise. But\n    // before that there is a bit of refactoring to do to allow returning of\n    // graphs, parallel execution, etc.\n    //\n    // The logic from BuilderNode.invoke should be somehow called from here, for\n    // deserialized nodes that require the Builder environment.\n    async invoke(inputs, dynamicScope) {\n        const scope = dynamicScope ?? this.#scope;\n        const handler = this.#handler ?? scope.getHandler(this.type);\n        let result;\n        const handlerFn = typeof handler === \"function\" ? handler : handler?.invoke;\n        if (handlerFn) {\n            result = (await handlerFn(inputs, this));\n        }\n        else if (handler && typeof handler !== \"function\" && handler.graph) {\n            // TODO: This isn't quite right, but good enough for now. Instead what\n            // this should be in invoking a graph from a lexical scope in a dynamic\n            // scope. This requires moving state management into the dyanmic scope.\n            const graphs = handler.graph.getPinnedNodes();\n            if (graphs.length !== 1)\n                throw new Error(\"Expected exactly one graph\");\n            result = (await scope.invokeOneRound(inputs, graphs[0]));\n        }\n        else {\n            throw new Error(`Can't find handler for ${this.id}`);\n        }\n        return result;\n    }\n    async describe(scope = this.#scope, inputs, inputSchema, outputSchema) {\n        const describe = this.#getHandlerDescribe(scope);\n        return describe\n            ? await describe(inputs, inputSchema, outputSchema)\n            : undefined;\n    }\n    async serialize(metadata) {\n        return this.#scope.serialize(metadata, this);\n    }\n    async serializeNode() {\n        const node = {\n            id: this.id,\n            type: this.type,\n            configuration: this.configuration,\n        };\n        return [node];\n    }\n}\n//# sourceMappingURL=node.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO: To support parallelism, we need to track which nodes are still pending\nexport class State {\n    queue = [];\n    inputs = new Map();\n    constants = new Map();\n    controlWires = new Map();\n    haveRun = new Set();\n    queueUp(node) {\n        if (!this.queue.includes(node))\n            this.queue.push(node);\n    }\n    next() {\n        if (!this.queue.length)\n            throw new Error(\"No nodes in queue\");\n        return this.queue.shift();\n    }\n    done() {\n        return this.queue.length === 0;\n    }\n    /**\n     * Compute required inputs from edges and compare with present inputs\n     *\n     * Required inputs are\n     *  - for all named incoming edges, the presence of any data, irrespective of\n     *    which node they come from\n     *  - at least one of the incoming empty or * wires, if present (TODO: Is that\n     *    correct?)\n     *  - data from at least one node if it already ran\n     *\n     * @returns false if none are missing, otherwise string[] of missing inputs.\n     * NOTE: A node with no incoming wires returns an empty array after  first\n     * run.\n     */\n    missingInputs(node) {\n        if (node.incoming.length === 0 && this.haveRun.has(node))\n            return [];\n        const requiredKeys = new Set(node.incoming.map((edge) => edge.in));\n        const presentKeys = new Set([\n            ...Object.keys(node.configuration),\n            ...Object.keys(this.constants.get(node) ?? {}),\n        ]);\n        for (const [port, values] of (this.inputs.get(node) ?? new Map()).entries())\n            if (values.length)\n                presentKeys.add(port);\n        if (this.controlWires.get(node)?.length)\n            presentKeys.add(\"\");\n        const missingInputs = [...requiredKeys].filter((key) => !presentKeys.has(key));\n        return missingInputs.length ? missingInputs : false;\n    }\n    shiftInputs(node) {\n        const inputs = { ...node.configuration, ...this.constants.get(node) };\n        // Shift inputs from queues\n        const queues = this.inputs.get(node) ?? new Map();\n        for (const [port, values] of queues.entries())\n            if (values.length > 0)\n                inputs[port] = values.shift();\n        // Mark as run, reset control wires\n        this.haveRun.add(node);\n        this.controlWires.delete(node);\n        return inputs;\n    }\n    processResult(node, result) {\n        const distribution = { nodes: [], unused: [] };\n        const unusedPorts = new Set(Object.keys(result));\n        for (const edge of node.outgoing) {\n            const ports = this.distributeResults(edge, result);\n            ports.forEach((key) => unusedPorts.delete(key));\n            // If it's ready to run, add it to the queue\n            const missing = this.missingInputs(edge.to);\n            if (!missing)\n                this.queueUp(edge.to);\n            distribution.nodes.push({ node: edge.to, received: ports, missing });\n        }\n        distribution.unused = [...unusedPorts];\n        return distribution;\n    }\n    distributeResults(edge, inputs) {\n        const data = edge.out === \"*\"\n            ? inputs\n            : edge.out === \"\"\n                ? {}\n                : inputs[edge.out] !== undefined\n                    ? { [edge.in]: inputs[edge.out] }\n                    : {};\n        // Update constants; pverwrite current values if present\n        if (edge.constant)\n            this.constants.set(edge.to, { ...this.constants.get(edge.to), ...data });\n        // Regular inputs: Add to the input queues\n        if (!this.inputs.has(edge.to))\n            this.inputs.set(edge.to, new Map());\n        const queues = this.inputs.get(edge.to);\n        for (const port of Object.keys(data)) {\n            if (!queues?.has(port))\n                queues?.set(port, []);\n            queues?.get(port)?.push(data[port]);\n        }\n        if (edge.in === \"\")\n            this.controlWires.set(edge.to, [\n                ...(this.controlWires.get(edge.to) ?? []),\n                edge.from,\n            ]);\n        // return which wires were used\n        return Object.keys(data);\n    }\n}\n//# sourceMappingURL=state.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { State } from \"./state.js\";\nconst buildRequiredPropertyList = (properties) => {\n    return Object.entries(properties)\n        .map(([key, value]) => {\n        const mayHaveOptional = value;\n        if (mayHaveOptional.$optional) {\n            delete mayHaveOptional.$optional;\n            return undefined;\n        }\n        return key;\n    })\n        .filter(Boolean);\n};\nexport class Scope {\n    parentLexicalScope;\n    parentDynamicScope;\n    #handlers = {};\n    #pinnedNodes = [];\n    #callbacks = [];\n    constructor(config = {}) {\n        this.parentLexicalScope = config.lexicalScope;\n        this.parentDynamicScope = config.dynamicScope;\n    }\n    addHandlers(handlers) {\n        Object.entries(handlers).forEach(([name, handler]) => (this.#handlers[name] = handler));\n    }\n    getHandler(name) {\n        return (this.#handlers[name] ||\n            this.parentDynamicScope?.getHandler(name) ||\n            this.parentLexicalScope?.getHandler(name));\n    }\n    pin(node) {\n        this.#pinnedNodes.push(node);\n    }\n    compactPins() {\n        const visited = new Set();\n        const disjointPins = [];\n        for (const node of this.#pinnedNodes) {\n            if (visited.has(node))\n                continue;\n            disjointPins.push(node);\n            const connected = this.#findAllConnectedNodes(node);\n            connected.forEach((node) => visited.add(node));\n        }\n        this.#pinnedNodes = disjointPins;\n    }\n    getPinnedNodes() {\n        return this.#pinnedNodes;\n    }\n    addCallbacks(callbacks) {\n        this.#callbacks.push(callbacks);\n    }\n    #getAllCallbacks() {\n        // Callbacks are called in reverse order that they are added. Important for\n        // the `before` callback, which can override execution with output values.\n        // So while all are called, the last one added that returns something other\n        // than undefined gets precedence.\n        return [\n            ...this.#callbacks,\n            ...(this.parentDynamicScope\n                ? this.parentDynamicScope.#getAllCallbacks()\n                : []),\n        ];\n    }\n    async invoke(node, state = new State()) {\n        try {\n            if (node !== false)\n                (node ? (node instanceof Array ? node : [node]) : this.#pinnedNodes)\n                    .flatMap((node) => this.#findAllConnectedNodes(node).filter((node) => state?.missingInputs(node) === false))\n                    .forEach((node) => state?.queueUp(node));\n            const callbacks = this.#getAllCallbacks();\n            while (!state.done()) {\n                for (const callback of callbacks)\n                    if (await callback.stop?.(this, state))\n                        return;\n                const node = state.next();\n                const inputs = state.shiftInputs(node);\n                let callbackResult = undefined;\n                for (const callback of callbacks)\n                    callbackResult ??= await callback.before?.(this, node, inputs);\n                // Invoke node, unless before callback already provided a result.\n                const result = callbackResult ??\n                    (await node.invoke(inputs, this).catch((e) => {\n                        return {\n                            $error: {\n                                type: \"error\",\n                                error: e,\n                            },\n                        };\n                    }));\n                // Distribute data to outgoing edges, queue up nodes that are ready to\n                const distribution = state.processResult(node, result);\n                // Call after callback\n                for (const callback of callbacks) {\n                    await callback.after?.(this, node, inputs, result, distribution);\n                }\n                // Abort graph on uncaught errors.\n                if (distribution.unused.includes(\"$error\")) {\n                    throw result[\"$error\"].error;\n                }\n            }\n        }\n        finally {\n            // Call done callback\n            // Note: Only callbacks added to this scope specifically are called\n            for (const callback of this.#callbacks) {\n                await callback.done?.();\n            }\n        }\n    }\n    invokeOneRound(inputs = {}, node = undefined, state) {\n        if (\"$state\" in inputs) {\n            state = inputs[\"$state\"];\n            delete inputs[\"$state\"];\n        }\n        let resolver = undefined;\n        const promise = new Promise((resolve) => {\n            resolver = resolve;\n        });\n        const scope = new Scope({ dynamicScope: this });\n        scope.addHandlers({\n            input: async () => {\n                return inputs;\n            },\n            output: async (inputs) => {\n                resolver?.(await inputs);\n                resolver = undefined;\n                return inputs;\n            },\n        });\n        let lastNode = undefined;\n        const lastMissingInputs = new Map();\n        let stopState = undefined;\n        scope.addCallbacks({\n            stop: (_scope, state) => {\n                // Once output node was executed, stop execution.\n                if (!resolver)\n                    stopState = state;\n                return !resolver;\n            },\n            after: (_scope, node, _inputs, _outputs, distribution) => {\n                // Remember debug information to make the error below more useful.\n                lastNode = node;\n                for (const { node, missing } of distribution.nodes) {\n                    if (missing) {\n                        lastMissingInputs.set(node.id, missing.join(\", \"));\n                    }\n                    else {\n                        lastMissingInputs.delete(node.id);\n                    }\n                }\n            },\n            done: () => {\n                // Make sure we don't wait forever if execution terminates without\n                // reaching an output node.\n                resolver?.({\n                    $error: {\n                        type: \"error\",\n                        error: new Error(`Output node never reach. Last node was ${lastNode?.id}.\\n\\nThese nodes had inputs missing:\\n${Array.from(lastMissingInputs, ([id, missing]) => `  ${id}: ${missing}`).join(\"\\n\")}`),\n                    },\n                });\n            },\n        });\n        const runner = scope.invoke(node !== undefined ? node : this.#pinnedNodes, state);\n        // Wait for both, return output values, and last state if stopped.\n        return Promise.all([promise, runner]).then(([outputs]) => ({\n            ...outputs,\n            ...(stopState ? { $state: stopState } : {}),\n        }));\n    }\n    async serialize(metadata, node) {\n        const queue = (node ? [node] : this.#pinnedNodes).flatMap((node) => this.#findAllConnectedNodes(node));\n        const graphs = {};\n        const nodes = await Promise.all(queue.map(async (node) => {\n            const [nodeDescriptor, subGraph] = await node.serializeNode();\n            // Save subgraphs returned, typically for `invoke` nodes that call\n            // serialized graphs or functions.\n            if (subGraph)\n                graphs[nodeDescriptor.id] = subGraph;\n            // If `input` or `output` nodes don't have a schema, derive it from\n            // their wires, calling the respective nodes' describe method.\n            if ((nodeDescriptor.type === \"input\" ||\n                nodeDescriptor.type === \"output\") &&\n                !nodeDescriptor.configuration?.schema) {\n                const schema = await this.#addMissingSchemas(node);\n                if (Object.entries(schema.properties ?? {}).length > 0)\n                    nodeDescriptor.configuration = {\n                        ...nodeDescriptor.configuration,\n                        schema,\n                    };\n            }\n            return nodeDescriptor;\n        }));\n        const edges = queue.flatMap((node) => node.outgoing.map((edge) => ({\n            from: edge.from.id,\n            to: edge.to.id,\n            out: edge.out,\n            in: edge.in,\n            ...(edge.constant ? { constant: true } : {}),\n        })));\n        return { ...metadata, edges, nodes, graphs };\n    }\n    #findAllConnectedNodes(node) {\n        const nodes = new Set();\n        const queue = [node];\n        while (queue.length) {\n            const node = queue.shift();\n            if (nodes.has(node))\n                continue;\n            nodes.add(node);\n            node.incoming.forEach((edge) => queue.push(edge.from));\n            node.outgoing.forEach((edge) => queue.push(edge.to));\n        }\n        return [...nodes];\n    }\n    async #getSchemasForNode(node) {\n        const incomingPorts = Object.fromEntries(node.incoming\n            .filter((edge) => edge.out !== \"\" && edge.out !== \"*\")\n            .map((edge) => [edge.out, edge.schema ?? {}]));\n        const outgoingPorts = Object.fromEntries(node.outgoing\n            .filter((edge) => edge.out !== \"\" && edge.out !== \"*\")\n            .map((edge) => [edge.out, edge.schema ?? {}]));\n        return await node.describe(this, node.configuration, { properties: incomingPorts }, { properties: outgoingPorts });\n    }\n    async #addMissingSchemas(node) {\n        const properties = {};\n        const ports = new Set();\n        if (node.type === \"input\") {\n            const nodes = new Set();\n            // Find all nodes downstream of this input node, note all ports\n            for (const edge of node.outgoing)\n                if (edge.out !== \"*\" && edge.out !== \"\") {\n                    nodes.add(edge.to);\n                    ports.add(edge.out);\n                    if (edge.schema)\n                        properties[edge.out] = edge.schema;\n                }\n            // For each node, get the schema and copy over the ports we care about\n            for (const toNode of nodes) {\n                const schema = await this.#getSchemasForNode(toNode);\n                const schemaPorts = schema?.inputSchema?.properties;\n                if (schemaPorts)\n                    for (const edge of toNode.incoming)\n                        if (edge.from === node && schemaPorts[edge.in])\n                            properties[edge.out] = {\n                                ...schemaPorts[edge.in],\n                                ...properties[edge.out],\n                            };\n            }\n        }\n        else if (node.type === \"output\") {\n            const nodes = new Set();\n            // Find all nodes upstream of this output node, note all ports\n            for (const edge of node.incoming)\n                if (edge.out !== \"*\" && edge.out !== \"\") {\n                    nodes.add(edge.from);\n                    ports.add(edge.in);\n                    if (edge.schema)\n                        properties[edge.in] = edge.schema;\n                }\n            // For each node, get the schema and copy over the ports we care about\n            for (const fromNode of nodes) {\n                const schema = await this.#getSchemasForNode(fromNode);\n                const schemaPorts = schema?.outputSchema?.properties;\n                if (schemaPorts)\n                    for (const edge of fromNode.outgoing)\n                        if (edge.to === node && schemaPorts[edge.out])\n                            properties[edge.in] = {\n                                ...schemaPorts[edge.out],\n                                ...properties[edge.in],\n                            };\n            }\n        }\n        else {\n            throw new Error(\"Can't yet derive schema for non-input/output nodes\");\n        }\n        for (const port of ports) {\n            if (!properties[port]) {\n                properties[port] = { type: \"string\", title: port };\n            }\n            else {\n                properties[port].type ||= \"string\";\n                properties[port].title ||= port;\n            }\n        }\n        const required = buildRequiredPropertyList(properties);\n        return { type: \"object\", properties, required };\n    }\n}\n//# sourceMappingURL=scope.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BoardRunner as OriginalBoardRunner } from \"../../runner.js\";\nimport { handlersFromKit } from \"./kits.js\";\nimport { BaseNode } from \"./node.js\";\nimport { Scope } from \"./scope.js\";\nfunction createProbeCallbacks(probe) {\n    const lastNodeDetails = new Map();\n    let lastNode = undefined;\n    return {\n        before: async (_, node, inputs) => {\n            const detail = {\n                descriptor: {\n                    id: node.id,\n                    type: node.type,\n                    configuration: node.configuration,\n                },\n                inputs,\n                outputs: Promise.resolve({}),\n            };\n            const shouldInvokeHandler = probe.dispatchEvent(new CustomEvent(\"nodestart\", {\n                detail,\n                cancelable: true,\n            }));\n            return shouldInvokeHandler ? undefined : detail.outputs;\n        },\n        after: (_, node, inputs, outputs, distribution) => {\n            const detail = {\n                descriptor: {\n                    id: node.id,\n                    type: node.type,\n                    configuration: node.configuration,\n                },\n                inputs,\n                outputs,\n                receivingNodes: Object.fromEntries(distribution.nodes\n                    .filter((node) => node.received.length > 0)\n                    .map((node) => [node.node.id, node.received])),\n                incompleteNodes: Object.fromEntries(distribution.nodes\n                    .filter((node) => node.missing !== false)\n                    .map((node) => [node.node.id, node.missing])),\n                unusedKeys: distribution.unused,\n            };\n            probe.dispatchEvent(new CustomEvent(\"node\", { detail }));\n            // Keep track of the last run of any node with incomplete next nodes\n            if (Object.entries(detail.incompleteNodes).length > 0)\n                lastNodeDetails.set(node.id, detail);\n            else\n                lastNodeDetails.delete(node.id);\n            lastNode = detail;\n        },\n        done: () => {\n            // For convenience, send a done event with the last node's details. In a\n            // developer tool, this could be highlighted if the last node wasn't\n            // expected, e.g. not an output node, and it might point out where the graph\n            // got stuck.\n            probe.dispatchEvent(new CustomEvent(\"done\", {\n                detail: {\n                    last: lastNode,\n                    incompleteNextNodes: [...lastNodeDetails.values()],\n                },\n            }));\n        },\n    };\n}\n/**\n * Implements the current API, so that we can run in existing Breadboard\n * environments.\n */\nexport class Runner {\n    kits = []; // No-op for now\n    edges = [];\n    nodes = [];\n    args;\n    #scope;\n    #anyNode;\n    constructor() {\n        this.#scope = new Scope();\n    }\n    async *run({ probe, kits, }) {\n        if (!this.#anyNode)\n            throw new Error(\"Can't run board without any nodes in it\");\n        const scope = new Scope({ lexicalScope: this.#scope });\n        let streamController;\n        const stream = new ReadableStream({\n            start(controller) {\n                streamController = controller;\n            },\n        });\n        scope.addHandlers({\n            input: async (inputs, node) => {\n                let resolver;\n                const outputsPromise = new Promise((resolve) => {\n                    resolver = resolve;\n                });\n                const descriptor = { type: node.type, id: node.id };\n                const awaitedInputs = await inputs;\n                const result = {\n                    type: \"input\",\n                    node: descriptor,\n                    inputArguments: awaitedInputs,\n                    set inputs(inputs) {\n                        resolver(inputs);\n                    },\n                    state: { skip: false },\n                };\n                streamController.enqueue(result);\n                outputsPromise.then((result) => probe?.dispatchEvent(new CustomEvent(\"input\", {\n                    detail: { descriptor, inputs: awaitedInputs, outputs: result },\n                })));\n                return outputsPromise;\n            },\n            output: async (inputs, node) => {\n                const descriptor = { type: node.type, id: node.id };\n                const result = {\n                    type: \"output\",\n                    node: descriptor,\n                    outputs: (await inputs),\n                    state: { skip: false },\n                };\n                probe?.dispatchEvent(new CustomEvent(\"output\", {\n                    detail: { descriptor, inputs: await inputs },\n                    cancelable: true,\n                }));\n                streamController.enqueue(result);\n                return {};\n            },\n        });\n        kits?.forEach((kit) => scope.addHandlers(handlersFromKit(kit)));\n        if (probe)\n            scope.addCallbacks(createProbeCallbacks(probe));\n        scope.invoke(this.#anyNode).finally(() => streamController.close());\n        const reader = stream.getReader();\n        while (true) {\n            const { done, value } = await reader.read();\n            if (done)\n                break;\n            yield value;\n        }\n    }\n    // To discuss: This is the same as runOnce() above, but implemented in\n    // parallel to run(), using different (and very simple) proxied input and\n    // output nodes.\n    async runOnce(inputs, context) {\n        if (!this.#anyNode)\n            throw new Error(\"Can't run board without any nodes in it\");\n        const args = { ...inputs, ...this.args };\n        const scope = new Scope({ lexicalScope: this.#scope });\n        context?.kits?.forEach((kit) => scope.addHandlers(handlersFromKit(kit)));\n        if (context?.probe)\n            scope.addCallbacks(createProbeCallbacks(context.probe));\n        // TODO: One big difference to before: This will keep running forever, even\n        // after the first output is encountered. We need to add a way to abort the\n        // run.\n        return scope.invokeOneRound(args, this.#anyNode);\n    }\n    addValidator(_) {\n        // TODO: Implement\n    }\n    static async fromGraphDescriptor(graph) {\n        const board = new Runner();\n        board.nodes = graph.nodes;\n        board.edges = graph.edges;\n        board.args = graph.args;\n        const nodes = new Map();\n        graph.nodes.forEach((node) => {\n            const newNode = new BaseNode(node.type, board.#scope, node.configuration);\n            nodes.set(node.id, newNode);\n            if (!board.#anyNode)\n                board.#anyNode = newNode;\n        });\n        graph.edges.forEach((edge) => {\n            const newEdge = {\n                from: nodes.get(edge.from),\n                to: nodes.get(edge.to),\n                out: edge.out,\n                in: edge.in,\n                constant: edge.constant,\n            };\n            newEdge.from.outgoing.push(newEdge);\n            newEdge.to.incoming.push(newEdge);\n        });\n        return board;\n    }\n    static async load(url, options) {\n        const graph = await OriginalBoardRunner.load(url, options);\n        const board = await Runner.fromGraphDescriptor(graph);\n        return board;\n    }\n}\n//# sourceMappingURL=runner.js.map","var util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * @deprecated Use z.string().min(1) instead.\n     * @see {@link ZodString.min}\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.issues.length) {\n                return {\n                    status: \"dirty\",\n                    value: ctx.data,\n                };\n            }\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        if (isValid(result)) {\n            result.value = Object.freeze(result.value);\n        }\n        return result;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\nconst custom = (check, params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\nexport { BRAND, DIRTY, EMPTY_PATH, INVALID, NEVER, OK, ParseStatus, ZodType as Schema, ZodAny, ZodArray, ZodBigInt, ZodBoolean, ZodBranded, ZodCatch, ZodDate, ZodDefault, ZodDiscriminatedUnion, ZodEffects, ZodEnum, ZodError, ZodFirstPartyTypeKind, ZodFunction, ZodIntersection, ZodIssueCode, ZodLazy, ZodLiteral, ZodMap, ZodNaN, ZodNativeEnum, ZodNever, ZodNull, ZodNullable, ZodNumber, ZodObject, ZodOptional, ZodParsedType, ZodPipeline, ZodPromise, ZodReadonly, ZodRecord, ZodType as ZodSchema, ZodSet, ZodString, ZodSymbol, ZodEffects as ZodTransformer, ZodTuple, ZodType, ZodUndefined, ZodUnion, ZodUnknown, ZodVoid, addIssueToContext, anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, coerce, custom, dateType as date, z as default, errorMap as defaultErrorMap, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, getErrorMap, getParsedType, instanceOfType as instanceof, intersectionType as intersection, isAborted, isAsync, isDirty, isValid, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, objectUtil, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, quotelessJson, recordType as record, setType as set, setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, util, voidType as void, z };\n","export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n","export const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"string\",\n    mapStrategy: \"entries\",\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    emailStrategy: \"format:email\",\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs) {\n    if (refs.dateStrategy == \"integer\") {\n        return integerDateParser(def, refs);\n    }\n    else {\n        return {\n            type: \"string\",\n            format: \"date-time\",\n        };\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                    check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                    check.message, refs);\n                }\n                break;\n        }\n    }\n    return res;\n};\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\n/**\n * Generated from the .source property of regular expressins found here:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Escapes have been doubled, and expressions with /i flag have been changed accordingly\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: \"^[cC][^\\\\s-]{8,}$\",\n    cuid2: \"^[a-z][a-z0-9]*$\",\n    ulid: \"^[0-9A-HJKMNP-TV-Z]{26}$\",\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: \"^(?!\\\\.)(?!.*\\\\.\\\\.)([a-zA-Z0-9_+-\\\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\\\-]*\\\\.)+[a-zA-Z]{2,}$\",\n    emoji: \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n    /**\n     * Unused\n     */\n    uuid: \"^[0-9a-fA-F]{8}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{12}$\",\n    /**\n     * Unused\n     */\n    ipv4: \"^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$\",\n    /**\n     * Unused\n     */\n    ipv6: \"^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$\",\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    function processPattern(value) {\n        return refs.patternStrategy === \"escape\"\n            ? escapeNonAlphaNumeric(value)\n            : value;\n    }\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex.source, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, \"^\" + processPattern(check.value), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, processPattern(check.value) + \"$\", check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, processPattern(check.value), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji, check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    // I have no idea why these are checks in Zod \n                    break;\n                default:\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nconst escapeNonAlphaNumeric = (value) => Array.from(value)\n    .map((c) => (/[a-zA-Z0-9]/.test(c) ? c : `\\\\${c}`))\n    .join(\"\");\nconst addFormat = (schema, value, message, refs) => {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n};\nconst addPattern = (schema, value, message, refs) => {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", value, message, refs);\n    }\n};\n","import { ZodFirstPartyTypeKind, } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? {},\n            }), {}),\n            additionalProperties: false,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? {},\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => (key === \"type\" ? acc : { ...acc, [key]: value }), {});\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    return schema;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef, } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef, } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef, } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef, } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchema = selectParser(def, def.typeName, refs);\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return {};\n            }\n            return refs.$refStrategy === \"seen\" ? {} : undefined;\n        }\n    }\n};\nconst getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nconst selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef();\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return parseDef(def.getter()._def, refs);\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef();\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef();\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef();\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            return ((_) => undefined)(typeName);\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n","import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseObjectDefX(def, refs) {\n    Object.keys(def.shape()).reduce((schema, key) => {\n        let prop = def.shape()[key];\n        const isOptional = prop.isOptional();\n        if (!isOptional) {\n            prop = { ...prop._def.innerSchema };\n        }\n        const propSchema = parseDef(prop._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", key],\n            propertyPath: [...refs.currentPath, \"properties\", key],\n        });\n        if (propSchema !== undefined) {\n            schema.properties[key] = propSchema;\n            if (!isOptional) {\n                if (!schema.required) {\n                    schema.required = [];\n                }\n                schema.required.push(key);\n            }\n        }\n        return schema;\n    }, {\n        type: \"object\",\n        properties: {},\n        additionalProperties: def.catchall._def.typeName === \"ZodNever\"\n            ? def.unknownKeys === \"passthrough\"\n            : parseDef(def.catchall._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalProperties\"],\n            }) ?? true,\n    });\n    const result = {\n        type: \"object\",\n        ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {\n            if (propDef === undefined || propDef._def === undefined)\n                return acc;\n            const parsedDef = parseDef(propDef._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"properties\", propName],\n                propertyPath: [...refs.currentPath, \"properties\", propName],\n            });\n            if (parsedDef === undefined)\n                return acc;\n            return {\n                properties: { ...acc.properties, [propName]: parsedDef },\n                required: propDef.isOptional()\n                    ? acc.required\n                    : [...acc.required, propName],\n            };\n        }, { properties: {}, required: [] }),\n        additionalProperties: def.catchall._def.typeName === \"ZodNever\"\n            ? def.unknownKeys === \"passthrough\"\n            : parseDef(def.catchall._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalProperties\"],\n            }) ?? true,\n    };\n    if (!result.required.length)\n        delete result.required;\n    return result;\n}\nexport function parseObjectDef(def, refs) {\n    const result = {\n        type: \"object\",\n        ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {\n            if (propDef === undefined || propDef._def === undefined)\n                return acc;\n            const parsedDef = parseDef(propDef._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"properties\", propName],\n                propertyPath: [...refs.currentPath, \"properties\", propName],\n            });\n            if (parsedDef === undefined)\n                return acc;\n            return {\n                properties: { ...acc.properties, [propName]: parsedDef },\n                required: propDef.isOptional()\n                    ? acc.required\n                    : [...acc.required, propName],\n            };\n        }, { properties: {}, required: [] }),\n        additionalProperties: def.catchall._def.typeName === \"ZodNever\"\n            ? def.unknownKeys === \"passthrough\"\n            : parseDef(def.catchall._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalProperties\"],\n            }) ?? true,\n    };\n    if (!result.required.length)\n        delete result.required;\n    return result;\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n","export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n","export function parseUndefinedDef() {\n    return {\n        not: {},\n    };\n}\n","export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n","import { ZodFirstPartyTypeKind } from \"zod\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n","import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n","export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n","export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: def.values,\n    };\n}\n","export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && '$ref' in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: {},\n                },\n                innerSchema,\n            ],\n        }\n        : {};\n};\n","import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || {};\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || {};\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n","import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n","export function parseNeverDef() {\n    return {\n        not: {},\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : {};\n}\n","export function parseUnknownDef() {\n    return {};\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n","import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n","import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n","import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n","import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n","import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    const definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? {},\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\" ? options : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? {};\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { z } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\n/**\n * This post processed JSON schema generated from Zod:\n *  - adds a title to the schema or any field by parsing the description as\n *    `${title}: ${description}`\n *  - removes $schema field\n *\n * @param zod Zod schema\n * @returns Post processed `Schema` object\n */\nexport function zodToSchema(zod) {\n    if (!isZodSchema(zod))\n        return zod;\n    const schema = zodToJsonSchema(zod);\n    delete schema.$schema;\n    // Recursively visit all fields and add titles from descriptions\n    const addTitles = (schema) => {\n        if (schema.description) {\n            const [title, description] = schema.description.split(\":\", 2);\n            schema.title = title.trim();\n            schema.description = description.trim();\n        }\n        if (schema.properties)\n            Object.values(schema.properties).forEach((property) => addTitles(property));\n    };\n    addTitles(schema);\n    return schema;\n}\nexport function convertZodToSchemaInConfig(config, factory) {\n    if (config.schema && config.schema instanceof z.ZodType) {\n        config.schema = zodToSchema(config.schema);\n    }\n    return factory(config);\n}\nfunction isZodSchema(object) {\n    return typeof object?.parse === \"function\";\n}\n//# sourceMappingURL=zod-utils.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BuilderScope } from \"./scope.js\";\n/**\n * The following is inspired by zone.js, but much simpler, and crucially doesn't\n * require monkey patching.\n *\n * Instead, we use a global variable to store the current scope, and swap it\n * out when we need to run a function in a different context.\n *\n * Scope.asScopeFor() wraps a function that runs with that Scope as context.\n *\n * action and any nodeFactory will run with the current Scope as context. That\n * is, they remember the Scope that was active when they were created.\n *\n * Crucially (and that's all we need from zone.js), {NodeImpl,Value}.then() call\n * onsuccessful and onrejected with the Scope as context. So even if the\n * context changed in the meantime, due to async calls, the rest of a flow\n * defining function will run with the current Scope as context.\n *\n * This works because NodeImpl and Value are PromiseLike, and so their then() is\n * called when they are awaited. Importantly, there is no context switch between\n * then() and the onsuccessful or onrejected call, if called from a Promise\n * then(), including a Promise.resolve().then (This makes it robust in case the\n * containing function isn't immediately awaited and so possibly Promises are\n * being scheduled). However, there is a context switch between the await and\n * the then() call, and so the context might have changed. That's why we\n * remember the scope on the node object.\n *\n * One requirement from this that there can't be any await in the body of a flow\n * or action function, if they are followed by either node creation or flow\n * calls. This is also a requirement for restoring state after interrupting a\n * flow.\n */\nlet currentContextScope = undefined;\nexport function getCurrentContextScope() {\n    // Initialize on first use.\n    if (!currentContextScope)\n        currentContextScope = new BuilderScope();\n    return currentContextScope;\n}\nexport function swapCurrentContextScope(scope) {\n    const oldScope = getCurrentContextScope();\n    currentContextScope = scope;\n    return oldScope;\n}\n//# sourceMappingURL=default-scope.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Scope } from \"../runner/scope.js\";\nimport { swapCurrentContextScope } from \"./default-scope.js\";\n/**\n * Adds syntactic sugar to support unproxying and serialization of nodes/graphs.\n */\nexport class BuilderScope extends Scope {\n    #isSerializing;\n    #closureEdges = [];\n    parentLambdaNode;\n    // TODO:BASE, config of subclasses can have more fields\n    constructor(config = {}) {\n        super(config);\n        this.#isSerializing = config.serialize ?? false;\n        this.parentLambdaNode = config.parentLambda;\n    }\n    async serialize(metadata, node) {\n        return super.serialize(metadata, node && typeof node.unProxy === \"function\"\n            ? node.unProxy()\n            : node);\n    }\n    serializing() {\n        return this.#isSerializing;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    asScopeFor(fn) {\n        return ((...args) => {\n            const oldScope = swapCurrentContextScope(this);\n            try {\n                return fn(...args);\n            }\n            finally {\n                swapCurrentContextScope(oldScope);\n            }\n        });\n    }\n    addClosureEdge(edge) {\n        this.#closureEdges.push(edge);\n    }\n    getClosureEdges() {\n        return this.#closureEdges;\n    }\n}\n//# sourceMappingURL=scope.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class AbstractValue {\n}\n//# sourceMappingURL=types.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AbstractValue, } from \"./types.js\";\nimport { BuilderNode, isBuilderNodeProxy } from \"./node.js\";\n// Because Value is sometimes behind a function Proxy (see NodeImpl's methods),\n// we need to use this approach to identify Value instead instanceof.\nexport const IsValueSymbol = Symbol(\"IsValue\");\nexport function isValue(obj) {\n    return ((typeof obj === \"object\" || typeof obj === \"function\") &&\n        obj[IsValueSymbol] !== undefined);\n}\nexport class Value extends AbstractValue {\n    #node;\n    #scope;\n    #keymap;\n    #constant;\n    #schema;\n    constructor(node, scope, keymap, constant = false, schema = {}) {\n        super();\n        this.#node = node;\n        this.#scope = scope;\n        this.#keymap = typeof keymap === \"string\" ? { [keymap]: keymap } : keymap;\n        this[IsValueSymbol] = this;\n        this.#constant = constant;\n        this.#schema = schema;\n    }\n    then(onfulfilled, onrejected) {\n        if (Object.keys(this.#keymap).length !== 1)\n            throw Error(\"Can't `await` for multiple values\");\n        return this.#node.then((o) => o &&\n            onfulfilled &&\n            this.#scope.asScopeFor(onfulfilled)(o[Object.keys(this.#keymap)[0]]), onrejected && this.#scope.asScopeFor(onrejected));\n    }\n    asNodeInput() {\n        return [this.#node.unProxy(), this.#keymap, this.#constant, this.#schema];\n    }\n    to(to, config) {\n        const toNode = isBuilderNodeProxy(to)\n            ? to.unProxy()\n            : new BuilderNode(to, this.#scope, config);\n        toNode.addInputsFromNode(this.#node, this.#keymap, this.#constant, this.#schema);\n        return toNode.asProxy();\n    }\n    // This doesn't do any type checking on the inputs.\n    //\n    // TODO: See whether that's somehow possible. The main problem is that\n    // node.<field> is typed for the outputs. We could add a new InputValue type\n    // and generate those from node.in().field so that the final syntax could be\n    // `toNode.toField.in(fromNode.in().fromField)`.\n    //\n    // That is, today .in() on a value returns void and in the future it would\n    // return that new InputValue type, typed with the right input value from the\n    // original node. To accomplish this, we'll have to keep passing the\n    // node input values type through the chain of values and .as() statements.\n    in(inputs) {\n        let invertedMap = Object.fromEntries(Object.entries(this.#keymap).map(([fromKey, toKey]) => [toKey, fromKey]));\n        if (isValue(inputs)) {\n            invertedMap = inputs.#remapKeys(invertedMap);\n            this.#node.addInputsFromNode(inputs.#node, invertedMap, inputs.#constant, inputs.#schema);\n        }\n        else if (isBuilderNodeProxy(inputs)) {\n            this.#node.addInputsFromNode(inputs.unProxy(), invertedMap);\n        }\n        else {\n            this.#node.addInputsAsValues(inputs);\n        }\n    }\n    as(newKey) {\n        let newMap;\n        if (typeof newKey === \"string\") {\n            if (Object.keys(this.#keymap).length !== 1)\n                throw new Error(\"Can't rename multiple values with a single string\");\n            newMap = { [Object.keys(this.#keymap)[0]]: newKey };\n        }\n        else {\n            newMap = this.#remapKeys(newKey);\n        }\n        return new Value(this.#node, this.#scope, newMap, this.#constant, this.#schema);\n    }\n    memoize() {\n        return new Value(this.#node, this.#scope, this.#keymap, true, this.#schema);\n    }\n    // Create a node for the lambda that is being sent as this value. At this\n    // point we can't verify that this actually is a BoardCapability, so we just\n    // do it and let the runtime throw an error if this wasn't one.\n    invoke(config) {\n        return new BuilderNode(\"invoke\", this.#scope, {\n            ...config,\n            $board: this,\n        }).asProxy();\n    }\n    /**\n     * The following are type-casting methods that are useful when a node type\n     * returns generic types but we want to narrow the types to what we know they\n     * are, e.g. a parser node returning the result as raw wires.\n     *\n     * This is also a way to define the schema of a board, e.g. by casting input\n     * wires and what is returned.\n     *\n     * Use as `foo.asString()` or `foo.asNumber()`. `isArray` and `isObject` cast\n     * to generic arrays and objects.\n     */\n    isUnknown() {\n        delete this.#schema.type;\n        return this;\n    }\n    isString() {\n        this.#schema.type = \"string\";\n        return this;\n    }\n    isNumber() {\n        this.#schema.type = \"number\";\n        return this;\n    }\n    isBoolean() {\n        this.#schema.type = \"boolean\";\n        return this;\n    }\n    isArray() {\n        this.#schema.type = \"array\";\n        return this;\n    }\n    isImage(mimeType = \"image/png\") {\n        this.#schema.type = mimeType;\n        return this;\n    }\n    isObject() {\n        this.#schema.type = \"object\";\n        return this;\n    }\n    title(title) {\n        this.#schema.title = title;\n        return this;\n    }\n    description(description) {\n        this.#schema.description = description;\n        return this;\n    }\n    format(format) {\n        this.#schema.format = format;\n        return this;\n    }\n    examples(...examples) {\n        this.#schema.examples = examples;\n        return this;\n    }\n    default(value) {\n        this.#schema.default = value;\n        return this;\n    }\n    optional() {\n        this.#schema.$optional = true;\n        return this;\n    }\n    transient() {\n        this.#schema.$optional = true;\n        return this;\n    }\n    #remapKeys(newKeys) {\n        const newMap = { ...this.#keymap };\n        Object.entries(newKeys).forEach(([fromKey, toKey]) => {\n            if (this.#keymap[toKey]) {\n                newMap[fromKey] = this.#keymap[toKey];\n                delete this.#keymap[toKey];\n            }\n            else {\n                newMap[fromKey] = toKey;\n            }\n        });\n        return newMap;\n    }\n}\n//# sourceMappingURL=value.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { AbstractNode, } from \"../runner/types.js\";\nimport { BaseNode } from \"../runner/node.js\";\nimport { BuilderScope } from \"./scope.js\";\nimport { Value, isValue } from \"./value.js\";\nimport { isLambda } from \"./board.js\";\nexport class BuilderNode extends BaseNode {\n    #promise;\n    #resolve;\n    #reject;\n    #scope;\n    #handler;\n    constructor(handler, scope, config = {}) {\n        const $id = !isBuilderNodeProxy(config) &&\n            !(config instanceof AbstractNode) &&\n            !isLambda(config) &&\n            !isValue(config) &&\n            config.$id;\n        super(handler, scope, $id ? { $id } : {});\n        this.#scope = scope;\n        if (typeof handler !== \"string\")\n            this.#handler = handler;\n        if (isBuilderNodeProxy(config)) {\n            this.addInputsFromNode(config.unProxy());\n        }\n        else if (config instanceof AbstractNode) {\n            this.addInputsFromNode(config);\n        }\n        else if (isLambda(config)) {\n            this.addInputsAsValues({\n                $board: config.getBoardCapabilityAsValue(),\n            });\n        }\n        else if (isValue(config)) {\n            this.addInputsFromNode(...config.asNodeInput());\n        }\n        else {\n            if (config.$id !== undefined)\n                delete config[\"$id\"];\n            this.addInputsAsValues(config);\n        }\n        // Set up spread value, so that { ...node } as input works.\n        this[this.#spreadKey()] =\n            this;\n        this.#promise = new Promise((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n    }\n    addInputsAsValues(values) {\n        // Split into constants and nodes\n        const constants = {};\n        const nodes = [];\n        Object.entries(values).forEach(([key, value]) => {\n            // This turns something returned by board() into a BoardCapability, which\n            // is going to be either a Promise for a BoardCapability (assigned to\n            // constants below) or an AbstractValue to one.\n            if (isLambda(value))\n                value = value.getBoardCapabilityAsValue();\n            if (isValue(value)) {\n                nodes.push(value.as(key).asNodeInput());\n            }\n            else if (value instanceof AbstractNode || isBuilderNodeProxy(value)) {\n                nodes.push([\n                    isBuilderNodeProxy(value) ? value.unProxy() : value,\n                    { [key]: key },\n                    false,\n                    undefined, // Defers inference of schema from node to serialization\n                ]);\n            }\n            else {\n                constants[key] = value;\n            }\n        });\n        this.configuration = { ...this.configuration, ...constants };\n        nodes.forEach((node) => this.unProxy().addInputsFromNode(...node));\n    }\n    // Add inputs from another node as edges\n    addInputsFromNode(from, keymap = { \"*\": \"\" }, constant, schema) {\n        const keyPairs = Object.entries(keymap);\n        if (keyPairs.length === 0) {\n            // Add an empty edge: Just control flow, no data moving.\n            this.addIncomingEdge(from, \"\", \"\", constant);\n        }\n        else {\n            keyPairs.forEach(([fromKey, toKey]) => {\n                // \"*-<id>\" means \"all outputs from <id>\" and comes from using a node in\n                // a spread, e.g. newNode({ ...node, $id: \"id\" }\n                if (fromKey.startsWith(\"*-\")) {\n                    fromKey = \"*\";\n                    toKey = \"\";\n                }\n                this.unProxy().addIncomingEdge(isBuilderNodeProxy(from) ? from.unProxy() : from, fromKey, toKey, constant, schema);\n            });\n        }\n    }\n    addIncomingEdge(from, out, in_, constant, schema) {\n        const fromScope = from.#scope;\n        // If this is a reguar wire, call super method to add it\n        if (fromScope === this.#scope) {\n            super.addIncomingEdge(from, out, in_, constant, schema);\n            return;\n        }\n        // Validate that this is a wire from a parent scope\n        for (let scope = this.#scope; scope !== fromScope; scope = scope.parentLexicalScope)\n            if (!scope)\n                throw new Error(\"Only wires from parent scopes allowed\");\n        // Don't allow * or empty wires from parent scopes\n        if (out === \"*\" || out === \"\")\n            throw new Error(\"Can't use * or empty wires from parent scopes\");\n        // Save for board() to add to the graph later\n        this.#scope.addClosureEdge({\n            scope: fromScope,\n            from: from,\n            to: this,\n            out,\n            in: in_,\n        });\n    }\n    async invoke(inputs, dynamicScope) {\n        const scope = new BuilderScope({\n            dynamicScope,\n            lexicalScope: this.#scope,\n        });\n        return scope.asScopeFor(async () => {\n            try {\n                const handler = this.#handler ?? scope.getHandler(this.type);\n                let result;\n                // Note: The handler might actually return a graph (as a NodeProxy), and\n                // so the await might triggers its execution. This is what we want.\n                //\n                // Awaiting here means that parallel execution isn't possible.\n                // TODO: Return a promise that knows how to do the rest. Make sure to\n                // never invoke the handler twice while it is running, though.\n                //\n                // TODO: What this should do instead is much closer to what the\n                // serialization code below does. It should:\n                //  - add an input node, assign the inputs to it\n                //  - call the handler with that input node's proxy (this gives it all\n                //    the values, but as promises) if it supports promises, otherwise\n                //    call it with the values directly.\n                //  - if the handler returns a node (i.e. a graph), and\n                //    - it isn't an output node, add an output node and wire it up\n                //    - execute the graph, and return the output node's outputs\n                //  - otherwise return the handler's return value as result.\n                const handlerFn = typeof handler === \"function\" ? handler : handler?.invoke;\n                if (handlerFn) {\n                    result = (await handlerFn(inputs, this));\n                }\n                else if (handler && typeof handler !== \"function\" && handler.graph) {\n                    // TODO: This isn't quite right, but good enough for now. Instead what\n                    // this should be in invoking a graph from a lexical scope in a dynamic\n                    // scope. This requires moving state management into the dyanmic scope.\n                    const graphs = handler.graph.getPinnedNodes();\n                    if (graphs.length !== 1)\n                        throw new Error(\"Expected exactly one graph\");\n                    result = (await scope.invokeOneRound(inputs, graphs[0]));\n                }\n                else {\n                    throw new Error(`Can't find handler for ${this.id}`);\n                }\n                // Execute graphs returned by the handler as individual results (A full\n                // graph returned would have already been executed above)\n                //\n                // TODO: As a future feature, it would be nice to do this as deep\n                // traversal, so that developers can return complex structures composed\n                // of different responses. But only if we support this for regular nodes\n                // as well.\n                for (const [key, value] of Object.entries(result)) {\n                    if (value instanceof BuilderNode)\n                        result[key] = (await value)[key];\n                    else if (isValue(value))\n                        result[key] = (await value);\n                    else if (isLambda(value))\n                        result[key] =\n                            (await value.getBoardCapabilityAsValue());\n                }\n                // Resolve promise, but only on first run\n                if (this.#resolve) {\n                    this.#resolve(result);\n                    this.#resolve = this.#reject = undefined;\n                }\n                return result;\n            }\n            catch (e) {\n                // Reject promise, but only on first run\n                if (this.#reject) {\n                    this.#reject(e);\n                    this.#resolve = this.#reject = undefined;\n                }\n                throw e;\n            }\n        })();\n    }\n    // TODO:BASE Special casing the function case (which is most of the code\n    // here), everything else is the same, but really just the first few lines\n    // here.\n    async serializeNode() {\n        // HACK: See board.getClosureNode() and\n        // board.getBoardCapabilityAsValue() for why this is needed. There we\n        // create a node that has a board capability as input, but serializing the\n        // graph is async, while node creation isn't. So we wait until here to\n        // await the serialized BoardCapability. To fix: Make node factories a\n        // first class object, which should inherently move serializing the\n        // subgraph to here (and never serialize subgraphs if their parent graphs\n        // aren't serialized either).\n        for (const [key, value] of Object.entries(this.configuration))\n            if (value instanceof Promise)\n                this.configuration[key] =\n                    await value;\n        if (this.type !== \"fn\") {\n            return super.serializeNode();\n        }\n        const scope = new BuilderScope({\n            lexicalScope: this.#scope,\n            serialize: true,\n        });\n        const handler = this.#handler ?? scope.getHandler(this.type);\n        // If this is a graph node, save it as a subgraph (returned as second value)\n        // and turns this into an invoke node.\n        if (handler && typeof handler !== \"function\" && handler.graph) {\n            const node = {\n                id: this.id,\n                type: \"invoke\",\n                configuration: {\n                    ...this.configuration,\n                    path: \"#\" + this.id,\n                },\n            };\n            const graphs = handler.graph.getPinnedNodes();\n            if (graphs.length !== 1)\n                throw new Error(\"Expected exactly one graph\");\n            return [node, await scope.serialize({}, graphs[0])];\n        }\n        // Else, serialize the handler itself and return a runJavascript node.\n        const handlerFn = typeof handler === \"function\" ? handler : handler?.invoke;\n        if (!handlerFn)\n            throw new Error(`Handler for ${this.type} in ${this.id} not found`);\n        let code = handlerFn.toString();\n        let name = this.id.replace(/-/g, \"_\");\n        const arrowFunctionRegex = /(?:async\\s*)?(\\w+|\\([^)]*\\))\\s*=>\\s*/;\n        const traditionalFunctionRegex = /(?:async\\s+)?function\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*\\{/;\n        if (arrowFunctionRegex.test(code)) {\n            // It's an arrow function, convert to traditional\n            code = code.replace(arrowFunctionRegex, (_, params) => {\n                const async = code.trim().startsWith(\"async\") ? \"async \" : \"\";\n                const paramsWithParens = params.startsWith(\"(\")\n                    ? params\n                    : `(${params})`;\n                return `${async}function ${name}${paramsWithParens} `;\n            });\n        }\n        else {\n            const match = traditionalFunctionRegex.exec(code);\n            if (match === null)\n                throw new Error(\"Unexpected seralization: \" + code);\n            else\n                name = match[1] || name;\n        }\n        const schemas = await this.describe(scope);\n        const invokeGraph = {\n            edges: [\n                { from: `${this.id}-input`, to: `${this.id}-run`, out: \"*\" },\n                { from: `${this.id}-run`, to: `${this.id}-output`, out: \"*\" },\n            ],\n            nodes: [\n                {\n                    id: `${this.id}-input`,\n                    type: \"input\",\n                    configuration: schemas?.inputSchema\n                        ? { schema: schemas.inputSchema }\n                        : {},\n                },\n                {\n                    id: `${this.id}-run`,\n                    type: \"runJavascript\",\n                    configuration: {\n                        ...this.configuration,\n                        code,\n                        name,\n                        raw: true,\n                    },\n                },\n                {\n                    id: `${this.id}-output`,\n                    type: \"output\",\n                    configuration: schemas?.outputSchema\n                        ? { schema: schemas.outputSchema }\n                        : {},\n                },\n            ],\n        };\n        const node = {\n            id: this.id,\n            type: \"invoke\",\n            configuration: { path: \"#\" + this.id },\n        };\n        return [node, invokeGraph];\n    }\n    /**\n     * Creates a proxy for a Node that is used when constructing a graph.\n     *\n     *   const node = originalNode.asProxy();\n     *\n     * It acts as a Promise for the Node's output by implementing a `then` method:\n     *   const output = await node;\n     *\n     * It acts a proxy for Promises for the Node's output's members.\n     *   const field = await node.field;\n     *\n     * You can still call methods on the Node:\n     *   node.to(nextNode);\n     *\n     * You can do that on output members too:\n     *   node.field.to(nextNode);\n     *\n     * This even works for its methods and `then` and other reserved words:\n     *   const to = await node.to;\n     *   const thenValue = await node.then; // note: not then()\n     *   node.then.to(nextNode); // send the value of `then` to nextNode\n     *   node.to.to(nextNode);   // same for the value of `to`.\n     *\n     *\n     * To achieve this, we use a Proxy that creates instances of Value for each\n     * requested key, as if it was an output of the node. If there is a method on\n     * node with the same name, we return a proxy for that method instead, that\n     * forwards all gets to the Value instance. As this includes the `then` method\n     * defined on the value, `await node.foo` works, even though `node.foo` is a a\n     * function. That it is a function is important for `node.then`, so that the\n     * node acts like a Promise as well.\n     *\n     */\n    // TODO: Hack keys() to make spread work\n    asProxy() {\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                if (typeof prop === \"string\") {\n                    const value = new Value(target, target.#scope, prop);\n                    let method = target[prop];\n                    // .to(), .in(), etc. call the original method:\n                    if (method && typeof method === \"function\")\n                        method = method.bind(target);\n                    // Otherwise, default \"method\" is to invoke the lambda represented by the value\n                    else\n                        method = ((config) => value.invoke(config)).bind(value);\n                    return new Proxy(method, {\n                        get(_, key, __) {\n                            const maybeMethod = Reflect.get(value, key, value);\n                            return typeof maybeMethod === \"function\"\n                                ? maybeMethod.bind(value)\n                                : maybeMethod;\n                        },\n                        ownKeys(_) {\n                            return Reflect.ownKeys(value).filter((key) => typeof key === \"string\");\n                        },\n                    });\n                }\n                else {\n                    return Reflect.get(target, prop, receiver);\n                }\n            },\n            ownKeys(target) {\n                return [target.#spreadKey()];\n            },\n        });\n    }\n    /**\n     * Retrieve underlying node from a NodeProxy. Use like this:\n     *\n     * if (thing instanceof BuilderNode) { const node = thing.unProxy(); }\n     *\n     * @returns A BuilderNoder that is not a proxy, but the original BuilderNode.\n     */\n    unProxy() {\n        return this;\n    }\n    /****\n     * Implementations of NodeProxyInterface, used for constructing Graphs,\n     * typically invoked on this.asProxy().\n     */\n    /**\n     * Makes the node (and its proxy) act as a Promise, which returns the output\n     * of the node. This trigger the execution of the graph built up so far.\n     *\n     * this.#promise is a Promise that gets resolved with the (first and only the\n     * first) invoke() call of the node. It is resolved with the outputs.\n     */\n    then(onfulfilled, onrejected) {\n        if (this.#scope.serializing())\n            throw new Error(`Can't \\`await\\` on ${this.id} in board declaration. ` +\n                `Did you mean to use \\`code\\` instead of \\`board\\`?`);\n        try {\n            // It's ok to call this multiple times: If it already run it'll only do\n            // something if new nodes or inputs were added (e.g. between await calls)\n            this.#scope.invoke(this).catch((e) => {\n                if (onrejected)\n                    return Promise.reject(e).catch(this.#scope.asScopeFor(onrejected));\n                else\n                    throw e;\n            });\n            return this.#promise.then(onfulfilled && this.#scope.asScopeFor(onfulfilled), onrejected && this.#scope.asScopeFor(onrejected));\n        }\n        catch (e) {\n            if (onrejected)\n                return Promise.reject(e).catch(this.#scope.asScopeFor(onrejected));\n            else\n                throw e;\n        }\n    }\n    to(to, config) {\n        const toNode = isBuilderNodeProxy(to)\n            ? to.unProxy()\n            : new BuilderNode(to, this.#scope, config);\n        // TODO: Ideally we would look at the schema here and use * only if\n        // the output is open ended and/or not all fields are present all the time.\n        toNode.addInputsFromNode(this, { \"*\": \"\" });\n        return toNode.asProxy();\n    }\n    // This doesn't do any type checking on the inputs.\n    //\n    // TODO: See whether that's somehow possible. The main problem is that\n    // node.<field> is typed for the outputs. We could add a new InputValue type\n    // and generate those from node.in().field so that the final syntax could be\n    // - `toNode.in({ toField: fromNode.in().fromField) }` or\n    // - `toNode.in({ field: fromNode.in() })`\n    //\n    // That is, today .in() returns itself, and in with this change, it would\n    // return a proxy object typed with the input types.\n    in(inputs) {\n        if (inputs instanceof BaseNode) {\n            this.addInputsFromNode(inputs);\n        }\n        else if (isValue(inputs)) {\n            this.addInputsFromNode(...inputs.asNodeInput());\n        }\n        else {\n            this.addInputsAsValues(inputs);\n        }\n        return this.asProxy();\n    }\n    as(keymap) {\n        return new Value(this, this.#scope, keymap);\n    }\n    keys() {\n        return [this.#spreadKey()];\n    }\n    #spreadKey() {\n        return \"*-\" + this.id;\n    }\n}\n// This will also match Lambdas, since they behave like a subset of\n// BuilderNodeProxy.\n//\n// TODO: Identify where they don't and possibly use a different is* there.\nexport function isBuilderNodeProxy(node) {\n    return typeof node.unProxy === \"function\";\n}\n//# sourceMappingURL=node.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BuilderNode } from \"./node.js\";\nimport { getCurrentContextScope } from \"./default-scope.js\";\nimport { handlersFromKit } from \"../runner/kits.js\";\nexport function addNodeType(name, handler) {\n    if (name)\n        registerNodeType(name, handler);\n    return ((config) => {\n        return new BuilderNode(name ?? handler, getCurrentContextScope(), config).asProxy();\n    });\n}\nexport function registerNodeType(name, handler) {\n    getCurrentContextScope().addHandlers({ [name]: handler });\n}\n// Extracts handlers from kits and creates node factories for them.\nexport function addKit(ctr, namespacePrefix = \"\") {\n    const kit = new ctr({});\n    const handlers = handlersFromKit(kit);\n    const removeNamespacePrefix = namespacePrefix\n        ? (name) => {\n            return name.startsWith(namespacePrefix)\n                ? name.slice(namespacePrefix.length)\n                : name;\n        }\n        : (name) => name;\n    return Object.fromEntries(Object.entries(handlers).map(([name, handler]) => [\n        removeNamespacePrefix(name),\n        addNodeType(name, handler),\n    ]));\n}\n//# sourceMappingURL=kits.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { zodToSchema } from \"./zod-utils.js\";\nimport { registerNodeType } from \"./kits.js\";\nimport { getCurrentContextScope } from \"./default-scope.js\";\nimport { BuilderNode } from \"./node.js\";\nimport { BuilderScope } from \"./scope.js\";\n/**\n * Implementation of the overloaded board function.\n */\nexport const board = (optionsOrFn, maybeFn) => {\n    const options = typeof optionsOrFn === \"object\" ? optionsOrFn : {};\n    options.graph ??= typeof optionsOrFn === \"function\" ? optionsOrFn : maybeFn;\n    return lambdaFactory(options);\n};\n/**\n * Explicit implementations of the overloaded variants, also splitting\n * graph generation and code boards.\n */\nexport const code = (fn) => {\n    return lambdaFactory({\n        invoke: fn,\n    });\n};\n/**\n * Actual implementation of all the above\n */\nfunction lambdaFactory(options) {\n    if (!options.invoke && !options.graph)\n        throw new Error(\"Missing invoke or graph definition function\");\n    const lexicalScope = getCurrentContextScope();\n    const closureEdgesToWire = [];\n    // Extract board metadata from config. Used in serialize().\n    const { url, title, description, version } = options ?? {};\n    const configMetadata = {\n        ...(url ? { url } : {}),\n        ...(title ? { title } : {}),\n        ...(description ? { description } : {}),\n        ...(version ? { version } : {}),\n    };\n    const inputSchema = options.input && zodToSchema(options.input);\n    const outputSchema = options.output && zodToSchema(options.output);\n    const handler = {};\n    if (options.describe)\n        handler.describe = options.describe;\n    else if (inputSchema && outputSchema)\n        handler.describe = async () => ({ inputSchema, outputSchema });\n    if (options.invoke)\n        handler.invoke = options.invoke;\n    if (options.graph) {\n        const scope = new BuilderScope({ lexicalScope, serialize: true });\n        scope.asScopeFor(() => {\n            const inputNode = new BuilderNode(\"input\", scope, inputSchema ? { schema: inputSchema } : {});\n            const outputNode = new BuilderNode(\"output\", scope, outputSchema ? { schema: outputSchema } : {});\n            const createAndPinNode = (type, config) => {\n                const node = new BuilderNode(type, scope, config);\n                scope.pin(node);\n                return node.asProxy();\n            };\n            // Create base kit that auto-pins to the scope.\n            const base = {\n                input: createAndPinNode.bind(null, \"input\"),\n                output: createAndPinNode.bind(null, \"output\"),\n            };\n            const result = options.graph?.(inputNode.asProxy(), base);\n            // Nothing returned means that the function must have pinned nodes itself\n            // using the `base` kit supplied above.\n            if (result === undefined)\n                return;\n            if (result instanceof Promise)\n                throw new Error(\"Graph generation function can't be async\");\n            let actualOutput = outputNode;\n            if (result instanceof BuilderNode) {\n                // If the handler returned an output node, serialize it directly,\n                // otherwise connect the returned node's outputs to the output node.\n                const node = result.unProxy();\n                if (node.type === \"output\")\n                    actualOutput = node;\n                else\n                    outputNode.addInputsFromNode(node);\n            }\n            else if (typeof result === \"object\") {\n                // Otherwise wire up all keys of the returned object to the output.\n                outputNode.addInputsAsValues(result);\n            }\n            else {\n                throw new Error(`Unexpected return ${typeof result} value from graph declaration`);\n            }\n            // Pin the resulting graph. Note: This might not contain either of the\n            // input or output nodes created above, if e.g. a new input node was\n            // created and an output node was returned.\n            scope.pin(actualOutput);\n        })();\n        // Add closure wires from parent scopes, if any\n        if (scope.getClosureEdges().length > 0) {\n            // This input node will receive all closure wires into the new graph.\n            const closureInput = new BuilderNode(\"input\", scope, {\n                $id: \"closure-input\",\n            });\n            scope.pin(closureInput);\n            for (const edge of scope.getClosureEdges()) {\n                // Connect closure input to destination node\n                const { to, out, in: in_ } = edge;\n                const wire = `$l-${out}-${to.id}`;\n                to.addIncomingEdge(closureInput, wire, in_, true);\n                // Wire upwards. This has to wait until the end of this function because\n                // we first need the lambda node, and that in turn needs to serialize\n                // this graph first.\n                closureEdgesToWire.push({ ...edge, to: closureInput, in: wire });\n            }\n        }\n        scope.compactPins();\n        const numGraphs = scope.getPinnedNodes().length;\n        if (numGraphs !== 1)\n            if (numGraphs === 0)\n                throw new Error(\"If not returning a graph, use `base.input` and `base.output`.\");\n            else\n                throw new Error(`Expected exactly one graph, but got ${numGraphs}. Are ${scope\n                    .getPinnedNodes()\n                    .map((node) => node.id)\n                    .join(\", \")} maybe disjoint?`);\n        handler.graph = scope;\n    }\n    let lambdaNode = undefined;\n    // TODO: Fix for closures, probably create a graph with an invoke node and\n    // re-register name with that as handler. But first we need to get cross-scope\n    // wiring right.\n    if (options.name)\n        registerNodeType(options.name, handler);\n    // When this factory is called, create node with handler and return as proxy.\n    // But if this is a closure, i.e. there are incoming wires to the lambda node\n    // (= like a closure, it reads from other nodes in its parent lexical scope),\n    // then invoke said lambda by reading the board capability it creates.\n    const factory = ((config) => {\n        if (!lambdaNode ||\n            (lambdaNode.incoming.length === 0 && closureEdgesToWire.length == 0))\n            return new BuilderNode(handler, getCurrentContextScope(), config).asProxy();\n        else\n            return new BuilderNode(\"invoke\", getCurrentContextScope(), {\n                ...config,\n                $board: lambdaNode.asProxy().board,\n            });\n    });\n    // Serializable:\n    // (Will be called and then overwritten by `createLambda` below\n    // once this turns into a closure)\n    factory.serialize = async (metadata) => {\n        const node = new BuilderNode(handler, lexicalScope);\n        const [singleNode, graph] = await node.serializeNode();\n        // If there is a subgraph that is invoked, just return that.\n        if (graph) {\n            if (singleNode.type !== \"invoke\")\n                throw new Error(\"Unexpected node with graph\");\n            return { ...configMetadata, ...metadata, ...graph };\n        }\n        // Otherwise build a graph around the node:\n        else\n            return {\n                ...configMetadata,\n                ...metadata,\n                edges: [\n                    { from: `${singleNode.id}-input`, to: singleNode.id, out: \"*\" },\n                    { from: singleNode.id, to: `${singleNode.id}-output`, out: \"*\" },\n                ],\n                nodes: [\n                    {\n                        id: `${singleNode.id}-input`,\n                        type: \"input\",\n                        configuration: inputSchema ? { schema: inputSchema } : {},\n                    },\n                    singleNode,\n                    {\n                        id: `${singleNode.id}-output`,\n                        type: \"output\",\n                        configuration: outputSchema ? { schema: outputSchema } : {},\n                    },\n                ],\n            };\n    };\n    // ClosureNodeInterface:\n    // Creates a lambda node if this lambda is used as a closure, i.e. it accesses\n    // wires from nodes in it's lexical scope, or it's passed as a value, i.e. a\n    // BoardCapability needs to be created. Those wires will be wired to this\n    // node, which then passes the values to the lambda when invoked. For now it\n    // does that by adding those values to the `args` field in the serialized\n    // graph. And it outputs a `BoardCapability` that can be invoked. In the\n    // future we'll replace the latter with first class support of factories.\n    function getLambdaNode() {\n        if (lambdaNode)\n            return lambdaNode;\n        const serialized = factory.serialize();\n        // HACK: Since node creation is synchronous, we put a promise for the board\n        // capability here. BuilderNode.serializeNode() awaits that then.\n        lambdaNode = new BuilderNode(\"lambda\", lexicalScope, {\n            board: (async () => ({\n                kind: \"board\",\n                board: { kits: [], ...(await serialized) },\n                // kits: because Runner.fromBoardCapability checks for that.\n            }))(),\n        });\n        // Replace the serialize function with one that returns a graph with that\n        // lambda node and an invoke node, not the original graph.\n        factory.serialize = async (metadata) => {\n            // If there are no incoming wires to the lambda node, it's not a closure\n            // and we can just return the original board.\n            if (lambdaNode?.incoming.length === 0 && closureEdgesToWire.length === 0)\n                return await serialized;\n            const invoke = new BuilderNode(\"invoke\", getCurrentContextScope(), {\n                $board: lambdaNode?.asProxy().board,\n            });\n            return invoke.serialize({ ...configMetadata, ...metadata });\n        };\n        return lambdaNode;\n    }\n    // Return wire from lambdaNode that will generate a BoardCapability\n    factory.getBoardCapabilityAsValue = () => lambdaNode !== undefined &&\n        (lambdaNode.incoming.length > 0 || closureEdgesToWire.length > 0)\n        ? lambdaNode.asProxy().board\n        : (async () => ({\n            kind: \"board\",\n            board: { kits: [], ...(await factory.serialize()) },\n        }))();\n    // Access to factory as if it was a node means accessing the closure node.\n    // This makes otherNode.to(factory) work.\n    factory.unProxy = () => getLambdaNode().unProxy();\n    // Allow factory.in(...incoming wires...).\n    //\n    // Note: factory.to() is not supported as there are no outgoing wires. To\n    // access to `board` output, wire the factory directly. In the future we'll\n    // get rid of BoardCapability and treat node factories as first class entities.\n    //\n    factory.in = (inputs) => {\n        getLambdaNode().in(inputs);\n        return factory;\n    };\n    for (const { scope: fromScope, from, out, in: in_ } of closureEdgesToWire) {\n        // If we reached the source scope, connect source node to lambda\n        if (fromScope === lexicalScope)\n            getLambdaNode().addIncomingEdge(from, out, in_, true);\n        // Otherwise add closure edge to the lambda node's scope\n        else\n            lexicalScope.addClosureEdge({\n                scope: fromScope,\n                from,\n                to: getLambdaNode(),\n                out,\n                in: in_,\n            });\n    }\n    return factory;\n}\nexport function isLambda(factory) {\n    return (typeof factory === \"function\" &&\n        typeof factory.getBoardCapabilityAsValue === \"function\");\n}\n//# sourceMappingURL=board.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { addNodeType } from \"./kits.js\";\nimport { convertZodToSchemaInConfig } from \"./zod-utils.js\";\nconst reservedWord = async () => {\n    throw new Error(\"Reserved word handler should never be invoked\");\n};\n// These get added to the default scope\nconst inputFactory = addNodeType(\"input\", reservedWord);\nconst outputFactory = addNodeType(\"output\", reservedWord);\nexport const base = {\n    input: (config) => convertZodToSchemaInConfig(config, inputFactory),\n    output: (config) => convertZodToSchemaInConfig(config, outputFactory),\n};\n//# sourceMappingURL=base.js.map"],"names":["Traversal","computeMissingInputs","heads","inputs","current","requiredInputs","Set","filter","edge","in","optional","map","inputsWithConfiguration","Object","keys","forEach","key","add","configuration","input","has","MachineEdgeState","state","Map","constants","queueOutput","node","value","queuesMap","get","set","queue","push","wireOutputs","opportunites","outputs","opportunity","from","length","Error","to","out","constant","this","output","undefined","getAvailableInputs","nodeId","result","entries","useInputs","shift","MachineResult","descriptor","missingInputs","opportunities","newOpportunities","outputsPromise","pendingOutputs","constructor","skip","fromObject","o","edgeState","TraversalMachineIterator","graph","noParallelExecution","processCompletedNode","completedNodeOutput","promiseId","delete","$error","e","cause","globalThis","console","warn","processAllPendingNodes","Promise","all","values","next","id","Symbol","promise","resolve","then","catch","error","kind","size","race","done","nodes","tails","toNode","currentDescriptor","incomingEdges","GraphRepresentation","edges","reduce","acc","Array","TraversalMachine","previousResult","asyncIterator","start","entry","entryResult","type","prepareToSave","replacer","$type","reviver","saveRunnerState","async","JSON","stringify","loadRunnerState","s","parse","timestamp","performance","now","RunResult","runState","invocationId","inputArguments","save","isAtExitNode","load","stringifiedResult","InputStageResult","super","OutputStageResult","resolveURL","base","urlString","results","url","URL","hash","href","path","protocol","decodeURIComponent","pathname","baseWithoutHash","replace","hrefWithoutHash","location","substring","loadFromFile","process","readFileFn","require","readFile","import","loadWithFetch","response","fetch","json","BoardLoadingStep","loaders","graphs","file","unknown","BoardLoader","subgraphs","isSubgraph","step","ReadableStream","prototype","reader","getReader","read","releaseLock","BoardStreamer","writable","readable","controller","WritableStream","write","chunk","TextDecoder","decode","split","line","trim","close","data","enqueue","post","method","headers","body","pipeThrough","runRemote","stream","callHandler","handler","context","handlerFunction","Function","invoke","getHandlerFunction","properNodeId","shape","idPrefix","nodeType","text","MermaidGenerator","nodeMap","handleSlotted","fromNode","prefix","slotted","name","subgraph","describeSubgraph","join","handleLambda","board","capability","describeSubgraphs","lamdba","edgeName","describeGraph","subgraphEdge","ignoreSubgraphs","mermEdge","describeEdge","toMermaid","direction","unstyled","unstyledTemplate","template","getSchemaType","isArray","SchemaBuilder","additionalProperties","required","properties","build","setAdditionalProperties","addInputs","addProperty","schema","addProperties","addRequired","empty","createErrorMessage","inputName","metadata","boardTitle","title","bubbleUpInputsIfNeeded","requestInput","InputSchemaReader","createBubbleHandler","default","currentOutputs","newOutputs","property","includes","RequestedInputsManager","cache","createHandler","cachedValue","requestInputResult","transient","noop","AsyncGenQueue","wroteIntoQueue","whenQueuedUp","lastReceipt","abort","setQueuePromise","reject","addToQueue","receipt","AsyncGenIterator","callback","firstTime","bind","err","asyncGen","StackManager","stack","structuredClone","onGraphStart","onNodeStart","onNodeEnd","onGraphEnd","traversalResultFromStack","BoardRunner","description","$schema","version","kits","args","slots","validators","outerGraph","breadboardSchema","assign","run","probe","handlers","handlersFromBoard","validator","addGraph","machine","requestedInputs","invocationPath","report","newContext","validatorMetadata","getValidatorMetadata","runOnce","addValidator","getSubgraphValidator","mermaid","fromGraphDescriptor","breadboard","options","loader","fromBreadboardCapability","boardish","runnableBoard","upstreamKits","kit","handlersFromKits","Core","static","lambda","describe","inputSchema","outputSchema","IdVendor","vendId","count","specRegex","nodeIdVendor","Node","currentBoardToAddTo","hasValues","incomingWiresToAdd","_","wire","indexOf","find","k","addNode","spec","ltr","match","a","b","dir","q","groups","parseSpec","addEdgeAcrossBoards","addEdge","asRuntimeKit","ctor","create","getConfigWithLambda","config","gotGraph","Board","closureStack","topClosure","acrossBoardsEdges","$id","rest","boardOrFunction","pop","label","outerEdge","addKit","ctr","asComposeTimeKit","STREAM_KIND","StreamCapability","clone","streamCapability","leave","take","tee","isStreamCapability","object","maybeStream","patchReadableStream","streamFromAsyncGen","iterator","pull","handlersFromKit","fromEntries","describeFunction","AbstractNode","BaseNode","outgoing","incoming","scope","addIncomingEdge","in_","getHandlerDescribe","getHandler","dynamicScope","handlerFn","getPinnedNodes","invokeOneRound","serialize","serializeNode","State","controlWires","haveRun","queueUp","requiredKeys","presentKeys","port","shiftInputs","queues","processResult","distribution","unused","unusedPorts","ports","distributeResults","missing","received","Scope","parentLexicalScope","parentDynamicScope","pinnedNodes","callbacks","lexicalScope","addHandlers","pin","compactPins","visited","disjointPins","findAllConnectedNodes","addCallbacks","getAllCallbacks","flatMap","stop","callbackResult","before","after","resolver","lastNode","lastMissingInputs","stopState","_scope","_inputs","_outputs","runner","$state","nodeDescriptor","subGraph","addMissingSchemas","getSchemasForNode","incomingPorts","outgoingPorts","schemaPorts","mayHaveOptional","$optional","Boolean","buildRequiredPropertyList","createProbeCallbacks","lastNodeDetails","detail","dispatchEvent","CustomEvent","cancelable","receivingNodes","incompleteNodes","unusedKeys","last","incompleteNextNodes","Runner","anyNode","streamController","awaitedInputs","finally","newNode","newEdge","OriginalBoardRunner","util","objectUtil","assertEqual","val","assertIs","_arg","assertNever","_x","arrayToEnum","items","obj","item","getValidEnumValues","validKeys","objectKeys","filtered","objectValues","hasOwnProperty","call","arr","checker","isInteger","Number","isFinite","Math","floor","joinValues","array","separator","jsonStringifyReplacer","toString","mergeShapes","first","second","ZodParsedType","getParsedType","string","isNaN","nan","number","boolean","function","bigint","symbol","null","Date","date","ZodIssueCode","ZodError","issues","addIssue","sub","addIssues","subs","actualProto","setPrototypeOf","__proto__","errors","format","_mapper","mapper","issue","message","fieldErrors","_errors","processError","code","unionErrors","returnTypeError","argumentsError","curr","i","el","isEmpty","flatten","formErrors","errorMap","_ctx","invalid_type","expected","invalid_literal","unrecognized_keys","invalid_union","invalid_union_discriminator","invalid_enum_value","invalid_arguments","invalid_return_type","invalid_date","invalid_string","validation","position","startsWith","endsWith","too_small","exact","inclusive","minimum","too_big","maximum","custom","invalid_intersection_types","not_multiple_of","multipleOf","not_finite","defaultError","overrideErrorMap","getErrorMap","makeIssue","params","errorMaps","issueData","fullPath","fullIssue","errorMessage","maps","m","slice","reverse","addIssueToContext","ctx","common","contextualErrorMap","schemaErrorMap","x","ParseStatus","dirty","mergeArray","status","arrayValue","INVALID","mergeObjectAsync","pairs","syncPairs","pair","mergeObjectSync","finalObject","alwaysSet","freeze","DIRTY","OK","isAborted","isDirty","isValid","isAsync","errorUtil","errToObj","ParseInputLazyPath","parent","_cachedPath","_path","_key","handleResult","success","_error","processCreateParams","invalid_type_error","required_error","iss","ZodType","def","spa","safeParseAsync","_def","safeParse","parseAsync","refine","refinement","superRefine","nullable","nullish","or","and","transform","brand","pipe","readonly","isNullable","isOptional","_getType","_getOrReturnCtx","parsedType","_processInputParams","_parseSync","_parse","_parseAsync","_a","maybeAsyncResult","check","getIssueProperties","_refinement","setError","refinementData","ZodEffects","typeName","ZodFirstPartyTypeKind","effect","ZodOptional","ZodNullable","ZodArray","ZodPromise","option","ZodUnion","ZodIntersection","defaultValueFunc","ZodDefault","innerType","defaultValue","ZodBranded","catchValueFunc","ZodCatch","catchValue","This","target","ZodPipeline","ZodReadonly","cuidRegex","cuid2Regex","ulidRegex","uuidRegex","emailRegex","emojiRegex","ipv4Regex","ipv6Regex","ZodString","coerce","String","checks","tooBig","tooSmall","test","RegExp","regex","lastIndex","toLowerCase","toUpperCase","precision","offset","ip","_regex","_addCheck","email","emoji","uuid","cuid","cuid2","ulid","datetime","min","minLength","max","maxLength","len","nonempty","isDatetime","ch","isEmail","isURL","isEmoji","isUUID","isCUID","isCUID2","isULID","isIP","floatSafeRemainder","valDecCount","stepDecCount","decCount","parseInt","toFixed","pow","ZodNumber","arguments","gte","lte","setLimit","gt","lt","int","positive","negative","nonpositive","nonnegative","finite","safe","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","minValue","maxValue","isInt","ZodBigInt","BigInt","ZodBoolean","ZodDate","getTime","minDate","maxDate","ZodSymbol","ZodUndefined","ZodNull","ZodAny","_any","ZodUnknown","_unknown","ZodNever","never","ZodVoid","void","exactLength","element","deepPartialify","ZodObject","newShape","fieldSchema","unwrap","ZodTuple","_cached","nonstrict","passthrough","augment","extend","_getCached","shapeKeys","extraKeys","catchall","unknownKeys","keyValidator","strict","_b","_c","_d","strip","augmentation","merge","merging","setKey","index","pick","mask","omit","deepPartial","partial","newField","keyof","createZodEnum","strictCreate","lazycreate","childCtx","types","getDiscriminator","ZodLazy","ZodLiteral","ZodEnum","ZodNativeEnum","enum","ZodDiscriminatedUnion","discriminator","discriminatorValue","optionsMap","discriminatorValues","mergeValues","aType","bType","valid","bKeys","sharedKeys","newObj","sharedValue","newArray","handleParsed","parsedLeft","parsedRight","merged","left","right","itemIndex","schemas","ZodRecord","keySchema","keyType","valueSchema","valueType","third","ZodMap","finalMap","ZodSet","minSize","maxSize","finalizeSet","elements","parsedSet","ZodFunction","validate","implement","makeArgsIssue","makeReturnsIssue","returns","fn","me","parsedArgs","Reflect","apply","parsedReturns","parameters","returnType","func","strictImplement","getter","expectedValues","enumValues","Values","Enum","extract","exclude","opt","nativeEnumValues","promisified","sourceType","checkCtx","arg","fatal","processed","executeRefinement","inner","createWithPreprocess","preprocess","removeDefault","newCtx","removeCatch","ZodNaN","BRAND","inResult","handleAsync","p","_fatal","p2","late","stringType","numberType","nanType","bigIntType","booleanType","dateType","symbolType","undefinedType","nullType","anyType","unknownType","neverType","voidType","arrayType","objectType","strictObjectType","unionType","discriminatedUnionType","intersectionType","tupleType","recordType","mapType","setType","functionType","lazyType","literalType","enumType","nativeEnumType","promiseType","effectsType","optionalType","nullableType","preprocessType","pipelineType","NEVER","z","defaultErrorMap","setErrorMap","EMPTY_PATH","ZodTransformer","Schema","ZodSchema","any","discriminatedUnion","instanceof","cls","intersection","lazy","literal","nativeEnum","oboolean","onumber","ostring","pipeline","record","strictObject","transformer","tuple","union","quotelessJson","addErrorMessage","res","refs","errorMessages","setResponseValueAndErrors","defaultOptions","$refStrategy","basePath","effectStrategy","pipeStrategy","dateStrategy","mapStrategy","definitionPath","strictUnions","definitions","markdownDescription","patternStrategy","emailStrategy","integerDateParser","zodPatterns","ipv4","ipv6","parseStringDef","processPattern","escapeNonAlphaNumeric","addFormat","addPattern","source","c","anyOf","some","pattern","allOf","parseRecordDef","parseDef","currentPath","propertyNames","primitiveMappings","asAnyOf","forceResolution","seenItem","seen","seenSchema","get$ref","newItem","jsonSchema","selectParser","addMeta","$ref","getRelativePath","every","pathA","pathB","exclusiveMinimum","exclusiveMaximum","parseNumberDef","propName","propDef","parsedDef","propertyPath","parseObjectDef","parseBigintDef","parseDateDef","not","parseNullDef","parseArrayDef","uniqueTypes","parseUnionDef","unevaluatedProperties","mergedAllOf","isJsonSchema7AllOfType","nestedSchema","parseIntersectionDef","minItems","additionalItems","maxItems","parseTupleDef","const","parseLiteralDef","parseEnumDef","actualValues","parsedTypes","parseNativeEnumDef","parseNullableDef","innerSchema","parseOptionalDef","parseMapDef","uniqueItems","parseSetDef","parsePromiseDef","parseEffectsDef","parseDefaultDef","parseBrandedDef","parseCatchDef","parsePipelineDef","getRefs","_options","getDefaultOptions","zodToJsonSchema","main","combined","zodToSchema","zod","addTitles","convertZodToSchemaInConfig","factory","currentContextScope","getCurrentContextScope","BuilderScope","swapCurrentContextScope","oldScope","isSerializing","closureEdges","parentLambdaNode","parentLambda","unProxy","serializing","asScopeFor","addClosureEdge","getClosureEdges","AbstractValue","IsValueSymbol","isValue","Value","keymap","onfulfilled","onrejected","asNodeInput","isBuilderNodeProxy","BuilderNode","addInputsFromNode","asProxy","invertedMap","fromKey","toKey","remapKeys","addInputsAsValues","as","newKey","newMap","memoize","$board","isUnknown","isString","isNumber","isBoolean","isImage","mimeType","isObject","examples","newKeys","isLambda","getBoardCapabilityAsValue","spreadKey","keyPairs","fromScope","arrowFunctionRegex","traditionalFunctionRegex","paramsWithParens","exec","invokeGraph","raw","Proxy","prop","receiver","__","maybeMethod","ownKeys","addNodeType","registerNodeType","namespacePrefix","removeNamespacePrefix","optionsOrFn","maybeFn","lambdaFactory","closureEdgesToWire","configMetadata","inputNode","outputNode","createAndPinNode","actualOutput","closureInput","numGraphs","lambdaNode","getLambdaNode","serialized","singleNode","reservedWord","inputFactory","outputFactory"],"mappings":"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","x_google_ignoreList":[29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62]}