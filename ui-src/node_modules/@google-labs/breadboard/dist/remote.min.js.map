{"version":3,"file":"remote.min.js","sources":["src/stream.js","src/remote/http.js","src/remote/worker.js","src/handler.js","src/kits/builder.js","src/remote/tunnel.js","src/timestamp.js","src/remote/proxy.js","src/kits/ctors.js","src/harness/diagnostics.js","src/traversal/index.js","src/traversal/state.js","src/traversal/result.js","src/traversal/iterator.js","src/traversal/representation.js","src/traversal/machine.js","src/serialization.js","src/run.js","src/remote/run.js","src/remote/init.js","src/remote/config.js"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst STREAM_KIND = \"stream\";\nexport class StreamCapability {\n    kind = STREAM_KIND;\n    stream;\n    constructor(stream) {\n        this.stream = stream;\n    }\n}\nexport const clone = (streamCapability) => {\n    const [leave, take] = streamCapability.stream.tee();\n    streamCapability.stream = leave;\n    return take;\n};\nexport const isStreamCapability = (object) => {\n    const maybeStream = object;\n    return (maybeStream &&\n        maybeStream.kind &&\n        maybeStream.kind === STREAM_KIND &&\n        maybeStream.stream instanceof ReadableStream);\n};\n// TODO: Remove this once MessageController is gone.\nconst findStreams = (value, foundStreams) => {\n    if (Array.isArray(value)) {\n        value.forEach((item) => {\n            findStreams(item, foundStreams);\n        });\n    }\n    else if (typeof value === \"object\") {\n        if (value === null || value === undefined)\n            return;\n        const maybeCapability = value;\n        if (maybeCapability.kind && maybeCapability.kind === STREAM_KIND) {\n            foundStreams.push(maybeCapability.stream);\n        }\n        else {\n            Object.values(value).forEach((item) => {\n                findStreams(item, foundStreams);\n            });\n        }\n    }\n};\nexport const stringifyWithStreams = (value) => {\n    const foundStreams = [];\n    return {\n        value: JSON.stringify(value, (key, value) => {\n            if (isStreamCapability(value)) {\n                foundStreams.push(value.stream);\n                return { $type: \"Stream\", id: foundStreams.length - 1 };\n            }\n            return value;\n        }),\n        streams: foundStreams,\n    };\n};\nexport const parseWithStreams = (value, getStream) => {\n    const parsed = JSON.parse(value, (key, value) => {\n        if (typeof value === \"object\" && value !== null) {\n            if (value.$type === \"Stream\" && typeof value.id === \"number\") {\n                return new StreamCapability(getStream(value.id));\n            }\n        }\n        return value;\n    });\n    return parsed;\n};\nexport const getStreams = (value) => {\n    const foundStreams = [];\n    findStreams(value, foundStreams);\n    return foundStreams;\n};\n/**\n * Stubs out all streams in the input values with empty streams.\n * This is useful when we don't want the streams to be transferred.\n * @param data\n * @returns\n */\nexport const stubOutStreams = (data) => {\n    const stringified = stringifyWithStreams(data).value;\n    return parseWithStreams(stringified, () => new ReadableStream());\n};\nexport const portToStreams = (port) => {\n    const readable = new ReadableStream({\n        start(controller) {\n            port.onmessage = (ev) => {\n                if (ev.data === null) {\n                    controller.close();\n                    return;\n                }\n                controller.enqueue(ev.data);\n            };\n        },\n        cancel() {\n            port.onmessage = null;\n        },\n    });\n    const writable = new WritableStream({\n        write(chunk) {\n            const stringified = stringifyWithStreams(chunk);\n            port.postMessage(chunk, stringified.streams);\n        },\n        close() {\n            port.postMessage(null, []);\n        },\n    });\n    return {\n        readable,\n        writable,\n    };\n};\nexport const portFactoryToStreams = (portFactory) => {\n    let streams;\n    const streamsAvailable = new Promise((resolve) => {\n        portFactory().then((port) => {\n            streams = portToStreams(port);\n            resolve();\n        });\n    });\n    const readable = new ReadableStream({\n        async start() {\n            await streamsAvailable;\n        },\n        pull(controller) {\n            return streams.readable.pipeTo(new WritableStream({\n                write(chunk) {\n                    controller.enqueue(chunk);\n                },\n            }));\n        },\n        cancel() {\n            streams.readable.cancel();\n        },\n    });\n    const writable = new WritableStream({\n        async start() {\n            await streamsAvailable;\n        },\n        async write(chunk) {\n            const writer = streams.writable.getWriter();\n            await writer.write(chunk);\n            writer.releaseLock();\n        },\n        async close() {\n            await streams.writable.close();\n        },\n        async abort(reason) {\n            await streams.writable.abort(reason);\n        },\n    });\n    return {\n        readable,\n        writable,\n    };\n};\nexport class WritableResult {\n    #writer;\n    data;\n    constructor(value, writer) {\n        this.#writer = writer;\n        this.data = value;\n    }\n    async reply(chunk) {\n        await this.#writer.write(chunk);\n    }\n}\nclass StreamsAsyncIterator {\n    #reader;\n    #writer;\n    constructor(writable, readable) {\n        this.#reader = readable.getReader();\n        this.#writer = writable.getWriter();\n    }\n    async next() {\n        const { done, value } = await this.#reader.read();\n        if (done) {\n            this.#writer.close();\n            return { done, value: undefined };\n        }\n        return {\n            done: false,\n            value: new WritableResult(value, this.#writer),\n        };\n    }\n    async return() {\n        this.#writer.close();\n        return { done: true, value: undefined };\n    }\n    async throw(err) {\n        this.#writer.abort(err);\n        return { done: true, value: undefined };\n    }\n}\n/**\n * A helper to convert a pair of streams to an async iterable that follows\n * the following protocol:\n * - The async iterable yields a `WritableResult` object.\n * - The `WritableResult` object contains the data from the readable stream.\n * - The `WritableResult` object has a `reply` method that can be used to\n *   write a value as a reply to to data in the readable stream.\n *\n * This is particularly useful with bi-directional streams, when the two\n * streams are semantically connected to each other.\n *\n * @param writable The writable stream.\n * @param readable The readable stream.\n * @returns An async iterable.\n */\nexport const streamsToAsyncIterable = (writable, readable) => {\n    return {\n        async start(chunk) {\n            const writer = writable.getWriter();\n            await writer.write(chunk);\n            writer.releaseLock();\n        },\n        [Symbol.asyncIterator]() {\n            return new StreamsAsyncIterator(writable, readable);\n        },\n    };\n};\n// Polyfill to make ReadableStream async iterable\n// See https://bugs.chromium.org/p/chromium/issues/detail?id=929585\nexport const patchReadableStream = () => {\n    // eslint-disable-next-line\n    // @ts-ignore\n    ReadableStream.prototype[Symbol.asyncIterator] ||\n        // eslint-disable-next-line\n        // @ts-ignore\n        (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {\n            const reader = this.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done)\n                        return;\n                    yield value;\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        });\n};\n// A polyfill for ReadableStream.from:\n// See https://streams.spec.whatwg.org/#rs-from\n// TODO: Do a proper TypeScript types polyfill.\nexport const streamFromAsyncGen = (iterator) => {\n    return new ReadableStream({\n        async pull(controller) {\n            const { value, done } = await iterator.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(value);\n        },\n    });\n};\nexport const streamFromReader = (reader) => {\n    return new ReadableStream({\n        async pull(controller) {\n            const { value, done } = await reader.read();\n            if (done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(value);\n        },\n    }, { highWaterMark: 0 });\n};\nexport const streamFromWriter = (writer) => {\n    return new WritableStream({\n        async write(chunk) {\n            return writer.write(chunk);\n        },\n    }, { highWaterMark: 0 });\n};\n//# sourceMappingURL=stream.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { parseWithStreams, patchReadableStream, stringifyWithStreams, } from \"../stream.js\";\nconst isIterable = (o) => {\n    return typeof o === \"object\" && o !== null && Symbol.iterator in o;\n};\nconst serverStreamEventDecoder = () => {\n    return new TransformStream({\n        transform(chunk, controller) {\n            if (chunk.startsWith(\"data: \")) {\n                controller.enqueue(chunk.slice(6));\n            }\n        },\n    });\n};\nexport const parseWithStreamsTransform = () => {\n    const siphon = new TransformStream();\n    const writer = siphon.writable.getWriter();\n    return new TransformStream({\n        transform(chunk, controller) {\n            const parsed = parseWithStreams(chunk, (id) => {\n                if (id !== 0) {\n                    throw new Error(\"HTTPClientTransport does not support multiple streams at the moment.\");\n                }\n                return siphon.readable;\n            });\n            // Siphon away chunks into the stream.\n            const [type] = Array.isArray(parsed) ? parsed : [];\n            if (type === \"http-stream-chunk\") {\n                writer.write(parsed[1].chunk);\n            }\n            else if (type === \"http-stream-end\") {\n                writer.close();\n            }\n            else {\n                controller.enqueue(parsed);\n            }\n        },\n    });\n};\nexport class HTTPServerTransport {\n    #request;\n    #response;\n    constructor(request, response) {\n        this.#request = request;\n        this.#response = response;\n    }\n    createServerStream() {\n        const request = this.#request;\n        const response = this.#response;\n        patchReadableStream();\n        response.header(\"Content-Type\", \"text/event-stream\");\n        return {\n            readableRequests: new ReadableStream({\n                start(controller) {\n                    if (!isIterable(request.body)) {\n                        controller.error(new Error(\"Unexpected uniterable body. This is likely a result of processing a GET request. Only POST requests are supported.\"));\n                        return;\n                    }\n                    controller.enqueue(request.body);\n                    controller.close();\n                },\n            }),\n            writableResponses: new WritableStream({\n                async write(chunk) {\n                    const stringified = stringifyWithStreams(chunk);\n                    response.write(`data: ${stringified.value}\\n\\n`);\n                    if (stringified.streams.length) {\n                        if (stringified.streams.length > 1) {\n                            throw new Error(\"HTTPServerTransport does not support multiple streams at the moment.\");\n                        }\n                        // this chunk has streams, let's send the stream data\n                        // along with the chunk.\n                        const stream = stringified.streams[0];\n                        await stream.pipeTo(new WritableStream({\n                            write(chunk) {\n                                const data = [\"http-stream-chunk\", { chunk }];\n                                response.write(`data: ${JSON.stringify(data)}\\n\\n`);\n                            },\n                            close() {\n                                const data = [\"http-stream-end\", {}];\n                                response.write(`data: ${JSON.stringify(data)}\\n\\n`);\n                            },\n                        }));\n                    }\n                },\n                close() {\n                    response.end();\n                },\n            }),\n        };\n    }\n}\n/**\n * When processing HTTP responses, the server may send chunks that are\n * broken in two ways:\n * - Multiple chunks might be merged together\n * - A single chunk might be broken into multiple chunks.\n *\n * This transform stream repairs such chunks, merging broken chunks and\n * splitting merged chunks.\n *\n * @returns The transform stream that repaired chunks.\n */\nconst chunkRepairTransform = () => {\n    let queue = [];\n    return new TransformStream({\n        transform(chunk, controller) {\n            const brokenChunk = !chunk.endsWith(\"\\n\");\n            const chunks = chunk.split(\"\\n\").filter(Boolean);\n            // If there are items in the queue, prepend them to the first chunk\n            // and enqueue the result.\n            if (queue.length && !brokenChunk) {\n                controller.enqueue(`${queue.join(\"\")}${chunks.shift()}`);\n                queue = [];\n            }\n            // Queue all chunks except the last one.\n            while (chunks.length > 1) {\n                controller.enqueue(chunks.shift());\n            }\n            const lastChunk = chunks.shift();\n            if (!lastChunk)\n                return;\n            if (brokenChunk) {\n                queue.push(lastChunk);\n            }\n            else {\n                controller.enqueue(lastChunk);\n            }\n        },\n        flush() {\n            // The queue should be empty at the end of the stream.\n            // The presence of items in the queue is an indication that the\n            // stream was not formatted correctly.\n            if (queue.length) {\n                throw new Error(\"Unexpected end of stream.\");\n            }\n        },\n    });\n};\nexport class HTTPClientTransport {\n    #url;\n    #options;\n    #fetch;\n    constructor(url, options) {\n        this.#url = url;\n        this.#options = {\n            ...options,\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n        };\n        this.#fetch = this.#options.fetch ?? globalThis.fetch.bind(globalThis);\n    }\n    createClientStream() {\n        let responseResolve;\n        const responsePromise = new Promise((resolve) => {\n            responseResolve = resolve;\n        });\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const that = this;\n        return {\n            readableResponses: new ReadableStream({\n                async pull(controller) {\n                    const response = await responsePromise;\n                    const reader = response.getReader();\n                    for (;;) {\n                        const result = await reader.read();\n                        if (result.done) {\n                            break;\n                        }\n                        else {\n                            console.log(\"%cServer-Sent Event Chunk\", \"background: #009; color: #FFF\", result.value);\n                            controller.enqueue(result.value);\n                        }\n                    }\n                    controller.close();\n                },\n            }),\n            writableRequests: new WritableStream({\n                async write(chunk, controller) {\n                    if (!responseResolve) {\n                        throw new Error(\"HTTPClientTransport supports only one write per stream instance.\");\n                    }\n                    const response = await that.#fetch(that.#url, {\n                        ...that.#options,\n                        body: JSON.stringify(chunk),\n                    });\n                    if (!response.ok) {\n                        controller.error(new Error(`HTTP error: ${response.status}`));\n                    }\n                    responseResolve(response.body\n                        ?.pipeThrough(new TextDecoderStream())\n                        .pipeThrough(chunkRepairTransform())\n                        .pipeThrough(serverStreamEventDecoder())\n                        .pipeThrough(parseWithStreamsTransform()));\n                    responseResolve = undefined;\n                },\n            }),\n        };\n    }\n}\n//# sourceMappingURL=http.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { portFactoryToStreams, portToStreams, streamFromReader, streamFromWriter, } from \"../stream.js\";\nconst DISPATCHER_SEND = \"port-dispatcher-sendport\";\nexport class PortDispatcher {\n    #worker;\n    #waitForSender = new Map();\n    #pool = new Map();\n    constructor(worker) {\n        this.#worker = worker;\n        this.#worker.addEventListener(\"message\", (event) => {\n            const { type, id, port } = event.data;\n            if (type !== DISPATCHER_SEND)\n                return;\n            const waiting = this.#waitForSender.get(id);\n            if (waiting) {\n                waiting(port);\n                this.#waitForSender.delete(id);\n            }\n            else {\n                this.#pool.set(id, port);\n            }\n        });\n    }\n    receive(id) {\n        const pooledPort = this.#pool.get(id);\n        if (pooledPort) {\n            this.#pool.delete(id);\n            return portToStreams(pooledPort);\n        }\n        return portFactoryToStreams(() => {\n            return new Promise((resolve) => {\n                this.#waitForSender.set(id, resolve);\n            });\n        });\n    }\n    send(id) {\n        const { port1, port2 } = new MessageChannel();\n        this.#worker.postMessage({ type: DISPATCHER_SEND, id, port: port2 }, [\n            port2,\n        ]);\n        return portToStreams(port1);\n    }\n}\nexport class WorkerClientTransport {\n    #reader;\n    #writer;\n    constructor(streams) {\n        this.#reader = streams.readable.getReader();\n        this.#writer = streams.writable.getWriter();\n    }\n    createClientStream() {\n        return {\n            writableRequests: streamFromWriter(this.#writer),\n            readableResponses: streamFromReader(this.#reader),\n        };\n    }\n}\nexport class WorkerServerTransport {\n    #clientStreams;\n    constructor(streams) {\n        this.#clientStreams = streams;\n    }\n    createServerStream() {\n        return {\n            readableRequests: this.#clientStreams\n                .readable,\n            writableResponses: this.#clientStreams.writable,\n        };\n    }\n}\n//# sourceMappingURL=worker.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst getHandlerFunction = (handler) => {\n    if (handler instanceof Function)\n        return handler;\n    if (handler.invoke)\n        return handler.invoke;\n    throw new Error(\"Invalid handler\");\n};\nexport const callHandler = async (handler, inputs, context) => {\n    // if (handler instanceof Function) return handler(inputs, context);\n    // if (handler.invoke) return handler.invoke(inputs, context);\n    const handlerFunction = getHandlerFunction(handler);\n    return new Promise((resolve) => {\n        handlerFunction(inputs, context)\n            .then(resolve)\n            .catch((error) => {\n            resolve({ $error: { error } });\n        });\n    });\n};\nexport const handlersFromKits = (kits) => {\n    return kits.reduce((handlers, kit) => {\n        // If multiple kits have the same handler, the kit earlier in the list\n        // gets precedence, including upstream kits getting precedence over kits\n        // defined in the graph.\n        //\n        // TODO: This means kits are fallback, consider non-fallback as well.\n        return { ...kit.handlers, ...handlers };\n    }, {});\n};\n//# sourceMappingURL=handler.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class KitBuilder {\n    url;\n    title;\n    description;\n    version;\n    namespacePrefix;\n    constructor({ title, description, version, url, namespacePrefix = \"\", }) {\n        this.url = url;\n        this.title = title;\n        this.description = description;\n        this.version = version;\n        this.namespacePrefix = namespacePrefix;\n    }\n    #addPrefix(handlers) {\n        return Object.keys(handlers).reduce((acc, key) => {\n            acc[`${this.namespacePrefix}${key}`] = handlers[key];\n            return acc;\n        }, {});\n    }\n    build(handlers) {\n        if (!this.url)\n            throw new Error(`Builder was not yet initialized.`);\n        const url = this.url;\n        const prefix = this.namespacePrefix;\n        const { title, description, version } = this;\n        const prefixedHandlers = this.#addPrefix(handlers);\n        const nodes = Object.keys(handlers);\n        return class {\n            title = title;\n            description = description;\n            version = version;\n            url = url;\n            get handlers() {\n                return prefixedHandlers;\n            }\n            constructor(nodeFactory) {\n                const proxy = new Proxy(this, {\n                    get(target, prop) {\n                        if (prop === \"handlers\" || prop === \"url\") {\n                            return target[prop];\n                        }\n                        else if (nodes.includes(prop)) {\n                            return (configOrLambda = {}) => {\n                                const config = nodeFactory.getConfigWithLambda(configOrLambda);\n                                const { $id, ...rest } = config;\n                                return nodeFactory.create(proxy, `${prefix}${prop}`, { ...rest }, $id);\n                            };\n                        }\n                    },\n                });\n                return proxy;\n            }\n        };\n    }\n    static wrap(params, functions) {\n        const createHandler = (previous, current) => {\n            const [name, fn] = current;\n            previous[name] = {\n                invoke: async (inputs) => {\n                    // JS can have rest args, eg. \"...args\" as a parameter at the end of a function, but breadboard cannot accept \".\" so we use \"___\".\n                    let argNames = [];\n                    if (fn && fn.length > 0) {\n                        argNames = fn.toString().match(/\\((.+?)\\)/)?.[1].split(\",\") ?? [];\n                        /*\n                        If fn.length is greater than 1 and argNames.length = 0, then we likely have a system function that accepts a splat of arguments..\n            \n                        e.g Math.max([1,2,3,4])\n            \n                        We need to special case this and pass the arguments as an array and expect `inputs` to have a key of `args` that is an array.\n                        */\n                        if (fn.length > 1 && argNames.length === 0 && \"___args\" in inputs && Array.isArray(inputs[\"___args\"])) {\n                            argNames = [\"___args\"];\n                        }\n                    }\n                    // Validate the input names.\n                    for (const argName of argNames) {\n                        if (argName.trim() in inputs === false) {\n                            throw new Error(`Missing input: ${argName.trim()}. Valid inputs are: ${Object.keys(inputs).join(\", \")}`);\n                        }\n                    }\n                    const args = argNames\n                        .filter(argName => argName.startsWith(\"___\") == false)\n                        .map((argName) => inputs[argName.trim()]);\n                    const lastArgName = argNames[argNames.length - 1];\n                    if (lastArgName != undefined && lastArgName.startsWith(\"___\")) {\n                        // Splat the rest of the arguments.\n                        args.push(...inputs[lastArgName]);\n                    }\n                    const results = await fn(...args);\n                    if (typeof results !== \"object\" || Array.isArray(results)) {\n                        // Number, Boolean, Array, String, will output to `result`.\n                        return { result: results };\n                    }\n                    // Objects will destructured into the output.\n                    return { ...results };\n                }\n            };\n            return previous;\n        };\n        const handlers = Object.entries(functions).reduce(createHandler, {});\n        const builder = new KitBuilder(params);\n        return builder.build(handlers);\n    }\n}\n//# sourceMappingURL=builder.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { callHandler } from \"../handler.js\";\n/**\n * Polyfill for atob and btoa.\n */\nexport const atob = globalThis.process\n    ? (str) => Buffer.from(str, \"base64\").toString(\"binary\")\n    : globalThis.atob;\nexport const btoa = globalThis.process\n    ? (str) => Buffer.from(str, \"binary\").toString(\"base64\")\n    : globalThis.btoa;\nconst TUNNEL_VALUE_SEPARATOR = \"~\";\nexport class NodeTunnel {\n    outputName;\n    from;\n    to;\n    when;\n    constructor(outputName, from, to, when = {}) {\n        this.outputName = outputName;\n        this.from = from;\n        this.to = to;\n        this.when = when;\n    }\n    getInputNames() {\n        const inputNames = Object.keys(this.when);\n        return inputNames.length === 0 ? [this.outputName] : inputNames;\n    }\n    matches(inputs) {\n        return Object.entries(this.when).every(([inputName, value]) => {\n            const inputValue = inputs[inputName];\n            if (typeof value === \"string\") {\n                return inputValue === value;\n            }\n            else {\n                if (typeof inputValue !== \"string\")\n                    return false;\n                return value.test(inputValue);\n            }\n        });\n    }\n}\nexport const readConfig = (config) => {\n    if (!config.proxy)\n        return {};\n    return Object.fromEntries(config.proxy\n        .map((spec) => {\n        if (typeof spec === \"string\") {\n            return undefined;\n        }\n        if (!spec.tunnel)\n            return undefined;\n        return [spec.node, readNodeSpec(spec.node, spec.tunnel)];\n    })\n        .filter(Boolean));\n};\nexport const readNodeSpec = (node, spec) => {\n    return Object.fromEntries(Object.entries(spec).map(([outputName, value]) => {\n        if (typeof value === \"string\") {\n            return [outputName, [new NodeTunnel(outputName, node, value)]];\n        }\n        else if (Array.isArray(value)) {\n            return [\n                outputName,\n                value.map((v) => {\n                    if (typeof v === \"string\") {\n                        return new NodeTunnel(outputName, node, v);\n                    }\n                    return new NodeTunnel(outputName, node, v.to, v.when);\n                }),\n            ];\n        }\n        else {\n            return [\n                outputName,\n                [new NodeTunnel(outputName, node, value.to, value.when)],\n            ];\n        }\n    }));\n};\nexport const replaceOutputs = (outputs, tunnels, replacer) => {\n    if (!outputs)\n        return;\n    return Object.fromEntries(Object.entries(outputs).map(([outputName, value]) => {\n        return outputName in tunnels\n            ? [outputName, replacer(outputName, value)]\n            : [outputName, value];\n    }));\n};\nexport const replaceInputs = async (inputs, tunnels, replacer) => {\n    // Decide if we should allow or block values for this node.\n    const allow = tunnels.some((tunnel) => tunnel.matches(inputs));\n    return Object.fromEntries(await Promise.all(Object.entries(inputs).map(async ([inputName, value]) => {\n        return [inputName, await replacer(value, allow)];\n    })));\n};\n// Compute a simple hash that expires every 7 days.\n// The point of this hash is not protect anything, but rather to have\n// a simple way to identify a tunnelled value.\n// It is also rotating so that the users of the node proxy don't accidentally\n// adopt bad practices of hard-coding the values.\n// Note: the rotation will occasionaly cause errors at the break of the week.\n// TODO: Fix the rotation to be window-based or come up with an even better\n// solution.\nconst MILLISECONDS_IN_A_WEEK = 1000 * 60 * 60 * 24 * 7;\nconst TUNNEL_HASH = Math.round(Date.now() / MILLISECONDS_IN_A_WEEK).toString(36);\nconst TUNNEL_PREFIX = `T-${TUNNEL_HASH}-`;\nconst TUNNEL_SUFFIX = `-${TUNNEL_HASH}-T`;\nconst SPLIT_REGEX = new RegExp(`(${TUNNEL_PREFIX}.*?${TUNNEL_SUFFIX})`, \"gm\");\nconst TUNNEL_REGEX = new RegExp(`^${TUNNEL_PREFIX}(.+?)${TUNNEL_SUFFIX}$`);\nconst BLOCKED_TUNNEL_VALUE = \"VALUE_BLOCKED\";\nexport const getTunnelValue = (nodeType, outputName, inputs) => {\n    const memoize = btoa(JSON.stringify(inputs)).replace(\"=\", \"\");\n    return `${TUNNEL_PREFIX}${nodeType}${TUNNEL_VALUE_SEPARATOR}${outputName}${TUNNEL_VALUE_SEPARATOR}${memoize}${TUNNEL_SUFFIX}`;\n};\nexport const scanTunnelValue = (value) => {\n    const parts = value.split(SPLIT_REGEX).filter(Boolean);\n    return parts.map((part) => {\n        const match = part.match(TUNNEL_REGEX);\n        if (match) {\n            // This is a tunnel value, parse it into components and return\n            // a helper object that enables the caller to replace the value.\n            const value = match[1].split(TUNNEL_VALUE_SEPARATOR);\n            const [nodeType, outputName, encodedInputs] = value;\n            const inputs = atob(encodedInputs);\n            return {\n                nodeType,\n                outputName,\n                inputs,\n            };\n        }\n        else {\n            // This is a regular substring, return a helper object that handles\n            // joining it back together as a string.\n            return {\n                value: part,\n            };\n        }\n    });\n};\nexport const replaceTunnelledInputs = async (input, \n/**\n * If true, the tunneled inputs will be replaced with the original value.\n * If false, the tunneled inputs should be blocked. The tunnel value\n * is replaced with a BLOCKED_TUNNEL_VALUE.\n */\nallow, replacer) => {\n    const json = JSON.stringify(input);\n    const parts = scanTunnelValue(json);\n    const result = await Promise.all(parts.map(async (part) => {\n        if (\"inputs\" in part) {\n            const inputs = JSON.parse(part.inputs);\n            const { nodeType, outputName } = part;\n            const outputs = allow\n                ? await replacer(nodeType, inputs)\n                : { [outputName]: BLOCKED_TUNNEL_VALUE };\n            if (!outputs)\n                return \"\";\n            let jsonString = JSON.stringify(outputs[outputName]);\n            if (jsonString.startsWith('\"')) {\n                jsonString = jsonString.slice(1, -1);\n            }\n            jsonString = JSON.stringify(jsonString);\n            return jsonString.slice(1, -1);\n        }\n        return part.value;\n    }));\n    return JSON.parse(result.join(\"\"));\n};\nexport const createDestinationMap = (map) => {\n    // pivot the map of tunnel entries to create a map of tunnel destinations\n    const entries = Object.entries(map).flatMap(([_, nodeTunnels]) => {\n        return Object.entries(nodeTunnels).flatMap(([_, tunnels]) => {\n            return tunnels.map((tunnel) => {\n                return [tunnel.to, tunnel];\n            });\n        });\n    });\n    // collate entries by destination node\n    return entries.reduce((acc, [to, tunnel]) => {\n        if (!acc[to])\n            acc[to] = [];\n        acc[to].push(tunnel);\n        return acc;\n    }, {});\n};\n/**\n * A special kit that provides tunneling of outputs and inputs as specified\n * by the Tunnels spec.\n *\n * This kit is constructed from existing NodeHandlers and the Tunnels spec.\n * It reads the spec and wraps the node handlers to add the tunneling logic.\n *\n * The tunnel entries, or the outputs of nodes that are tunneled, are replaced\n * with a special value that is computed from the node type and the output name.\n *\n * The tunnel destinations, or the inputs of the nodes to which a tunnel leads, are\n * replaced with the original value of the tunnel entry.\n */\nexport const createTunnelKit = (map, handlers) => {\n    // wrap handlers to tunnel outputs (tunnel entries)\n    const outputWrappedHandlers = Object.fromEntries(Object.entries(handlers).map(([nodeType, handler]) => {\n        const nodeTunnels = map[nodeType];\n        if (!nodeTunnels)\n            return [nodeType, handler];\n        return [\n            nodeType,\n            async (inputs, context) => {\n                const outputs = await callHandler(handler, inputs, context);\n                return replaceOutputs(outputs, nodeTunnels, (name) => getTunnelValue(nodeType, name, inputs));\n            },\n        ];\n    }));\n    // wrap handlers to connect the tunnel to the inputs (tunnel destinations)\n    const destinations = createDestinationMap(map);\n    const inputWrappedHandlers = Object.fromEntries(Object.entries(outputWrappedHandlers).map(([nodeType, handler]) => {\n        const destinationTunnels = destinations[nodeType];\n        if (!destinationTunnels)\n            return [nodeType, handler];\n        return [\n            nodeType,\n            async (inputs, context) => {\n                return callHandler(handler, await replaceInputs(inputs, destinationTunnels, async (value, allow) => {\n                    // scan for tunneled values in `value`.\n                    // for each found `tunnel value`,\n                    // - extract the node type and output name of the tunnel entry.\n                    // - call the handler of the node type for the tunnel entry\n                    //   with the inputs that are decoded from the tunnel value\n                    // - from the outputs, extract the inputs that are tunneled\n                    //   and replace the `tunnel value` with them.\n                    return replaceTunnelledInputs(value, allow, async (nodeType, inputs) => {\n                        return callHandler(handlers[nodeType], inputs, context);\n                    });\n                }), context);\n            },\n        ];\n    }));\n    return {\n        url: \"tunnel-kit\",\n        handlers: inputWrappedHandlers,\n    };\n};\n//# sourceMappingURL=tunnel.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const timestamp = () => globalThis.performance.now();\n//# sourceMappingURL=timestamp.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { callHandler, handlersFromKits } from \"../handler.js\";\nimport { streamsToAsyncIterable } from \"../stream.js\";\nimport { asRuntimeKit } from \"../kits/ctors.js\";\nimport { KitBuilder } from \"../kits/builder.js\";\nimport { createTunnelKit, readConfig } from \"./tunnel.js\";\nimport { timestamp } from \"../timestamp.js\";\nconst getHandlerConfig = (type, config = []) => {\n    const handlerConfig = config.find((arg) => {\n        if (typeof arg === \"string\")\n            return arg === type;\n        else\n            return arg.node === type;\n    });\n    if (typeof handlerConfig === \"string\") {\n        return {\n            node: handlerConfig,\n        };\n    }\n    return handlerConfig;\n};\nexport class ProxyServer {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async serve(config) {\n        const { kits } = config;\n        const stream = this.#transport.createServerStream();\n        const tunnelKit = createTunnelKit(readConfig(config), handlersFromKits(kits));\n        const handlers = tunnelKit.handlers;\n        for await (const request of streamsToAsyncIterable(stream.writableResponses, stream.readableRequests)) {\n            const [type] = request.data;\n            if (type === \"end\") {\n                break;\n            }\n            if (type !== \"proxy\") {\n                request.reply([\n                    \"error\",\n                    { error: \"Expected proxy request.\", timestamp: timestamp() },\n                ]);\n                continue;\n            }\n            const [, { node, inputs }] = request.data;\n            const handlerConfig = getHandlerConfig(node.type, config.proxy);\n            const handler = handlerConfig ? handlers[node.type] : undefined;\n            if (!handler) {\n                request.reply([\n                    \"error\",\n                    {\n                        error: \"Can't proxy a node of this node type.\",\n                        timestamp: timestamp(),\n                    },\n                ]);\n                continue;\n            }\n            try {\n                const result = await callHandler(handler, inputs, {\n                    descriptor: node,\n                });\n                if (!result) {\n                    request.reply([\n                        \"error\",\n                        { error: \"Handler returned nothing.\", timestamp: timestamp() },\n                    ]);\n                    continue;\n                }\n                request.reply([\"proxy\", { outputs: result }]);\n            }\n            catch (e) {\n                request.reply([\n                    \"error\",\n                    { error: e.message, timestamp: timestamp() },\n                ]);\n            }\n        }\n    }\n}\nexport class ProxyClient {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    shutdownServer() {\n        const stream = this.#transport.createClientStream();\n        const writer = stream.writableRequests.getWriter();\n        writer.write([\"end\", { timestamp: timestamp() }]);\n        writer.close();\n    }\n    async proxy(node, inputs) {\n        const stream = this.#transport.createClientStream();\n        const writer = stream.writableRequests.getWriter();\n        const reader = stream.readableResponses.getReader();\n        writer.write([\"proxy\", { node, inputs }]);\n        writer.close();\n        const result = await reader.read();\n        if (result.done)\n            throw new Error(\"Unexpected proxy failure: empty response.\");\n        const [type] = result.value;\n        if (type === \"proxy\") {\n            const [, { outputs }] = result.value;\n            return outputs;\n        }\n        else if (type === \"error\") {\n            const [, { error }] = result.value;\n            throw new Error(JSON.stringify(error));\n        }\n        else {\n            throw new Error(`Unexpected proxy failure: unknown response type \"${type}\".`);\n        }\n    }\n    createProxyKit(args = []) {\n        const nodesToProxy = args.map((arg) => {\n            if (typeof arg === \"string\")\n                return arg;\n            else\n                return arg.node;\n        });\n        const proxiedNodes = Object.fromEntries(nodesToProxy.map((type) => {\n            return [\n                type,\n                {\n                    invoke: async (inputs, context) => {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        const descriptor = context.descriptor;\n                        const result = await this.proxy(descriptor, inputs);\n                        return result;\n                    },\n                },\n            ];\n        }));\n        return asRuntimeKit(new KitBuilder({ url: \"proxy\" }).build(proxiedNodes));\n    }\n}\n//# sourceMappingURL=proxy.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Node } from \"../node.js\";\n/**\n * Takes a kit constructor and creates a kit instance that can be used at\n * run-time.\n *\n * @param ctor Kit constructor\n * @returns A kit instance prepare for run-time use.\n */\nexport const asRuntimeKit = (ctor) => {\n    return new ctor({\n        create: () => {\n            throw Error(\"Node instantiation can't (yet) happen during runtime\");\n        },\n    });\n};\n/**\n * Takes a kit constructor and creates a kit instance that can be used at\n * compose-time (wiring the graph).\n * @param ctor Kit constructor\n * @param board The board with which the kit is associated.\n * @returns Kit instance prepared for compose-time use.\n */\nexport const asComposeTimeKit = (ctor, board) => {\n    return new ctor({\n        create: (...args) => {\n            return new Node(board, ...args);\n        },\n        getConfigWithLambda: (config) => {\n            return getConfigWithLambda(board, config);\n        },\n    });\n};\n/**\n * Synctactic sugar for node factories that accept lambdas. This allows passing\n * either\n *  - A JS function that is a lambda function defining the board\n *  - A board capability, i.e. the result of calling lambda()\n *  - A board node, which should be a node with a `board` output\n * or\n *  - A regular config, with a `board` property with any of the above.\n *\n * @param config {ConfigOrLambda} the overloaded config\n * @returns {NodeConfigurationConstructor} config with a board property\n */\nconst getConfigWithLambda = (board, config) => {\n    // Did we get a graph?\n    const gotGraph = config.nodes !== undefined &&\n        config.edges !== undefined &&\n        config.kits !== undefined;\n    // Look for functions, nodes and board capabilities.\n    const gotBoard = gotGraph ||\n        typeof config === \"function\" ||\n        config instanceof Node ||\n        (config.kind === \"board\" &&\n            config.board);\n    const result = (gotBoard\n        ? { board: gotGraph ? { kind: \"board\", board: config } : config }\n        : config);\n    // Convert passed JS function into a board node.\n    if (typeof result.board === \"function\")\n        result.board = board.lambda(result.board);\n    return result;\n};\n//# sourceMappingURL=ctors.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class Diagnostics extends EventTarget {\n    #callback;\n    constructor(callback) {\n        super();\n        this.#callback = callback;\n    }\n    async report(message) {\n        return this.#callback(message);\n    }\n}\n//# sourceMappingURL=diagnostics.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * This class holds important parts of the graph traversal algorithm.\n */\nexport class Traversal {\n    /**\n     * Computes the missing inputs for a node. A missing input is an input that is\n     * required by the node, but is not (yet) available in the current state.\n     * @param heads All the edges that point to the node.\n     * @param inputs The input values that will be passed to the node\n     * @param current The node that is being visited.\n     * @returns Array of missing input names.\n     */\n    static computeMissingInputs(heads, inputs, current) {\n        const requiredInputs = [\n            ...new Set(heads\n                .filter((edge) => !!edge.in && !edge.optional)\n                .map((edge) => edge.in || \"\")),\n        ];\n        const inputsWithConfiguration = new Set();\n        Object.keys(inputs).forEach((key) => inputsWithConfiguration.add(key));\n        if (current.configuration) {\n            Object.keys(current.configuration).forEach((key) => inputsWithConfiguration.add(key));\n        }\n        return requiredInputs.filter((input) => !inputsWithConfiguration.has(input));\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class MachineEdgeState {\n    state = new Map();\n    constants = new Map();\n    #queueOutput(map, node, key, value) {\n        let queuesMap = map.get(node);\n        if (!queuesMap) {\n            queuesMap = new Map();\n            map.set(node, queuesMap);\n        }\n        let queue = queuesMap.get(key);\n        if (!queue) {\n            queue = [];\n            queuesMap.set(key, queue);\n        }\n        queue.push(value);\n    }\n    /**\n     * Processes outputs by wiring them to the destinations according\n     * to the supplied edges. Assumes that the outputs were generated by\n     * the from node.\n     *\n     * @param opportunites {Edge[]} Edges to process\n     * @param outputs {OutputValues} Outputs to wire\n     */\n    wireOutputs(opportunites, outputs) {\n        // Verify that all edges are from the same node.\n        if (opportunites.filter((opportunity) => opportunity.from != opportunites[0].from).length !== 0)\n            throw new Error(\"All opportunities must be from the same node\");\n        opportunites.forEach((opportunity) => {\n            const to = opportunity.to;\n            const out = opportunity.out;\n            const queuesMap = opportunity.constant ? this.constants : this.state;\n            if (!out)\n                return;\n            if (out === \"*\") {\n                for (const key in outputs) {\n                    const output = outputs[key];\n                    if (output != null && output != undefined)\n                        this.#queueOutput(queuesMap, to, key, output);\n                }\n            }\n            else if (opportunity.in) {\n                const output = outputs[out];\n                // TODO: Check and document why we don't allow that\n                if (output != null && output != undefined)\n                    this.#queueOutput(queuesMap, to, opportunity.in, output);\n            }\n        });\n    }\n    /**\n     * Returns the available inputs for a given node.\n     *\n     * @param nodeId {NodeIdentifier} The node to get the inputs for.\n     * @returns {InputValues} The available inputs.\n     */\n    getAvailableInputs(nodeId) {\n        const result = {};\n        for (const queuesMap of [\n            this.constants.get(nodeId), // Constants are overwritten by state.\n            this.state.get(nodeId),\n        ]) {\n            if (!queuesMap)\n                continue;\n            for (const [key, queue] of queuesMap.entries()) {\n                if (queue.length === 0)\n                    continue;\n                result[key] = queue[0];\n            }\n        }\n        return result;\n    }\n    /**\n     * Shifts inputs from the queues. Leaves constants as is.\n     *\n     * @param nodeId {NodeIdentifier} The node to shift the inputs for.\n     * @param inputs {InputValues} The inputs that are used.\n     */\n    useInputs(nodeId, inputs) {\n        const queuesMap = this.state.get(nodeId);\n        if (!queuesMap)\n            return;\n        for (const key in inputs) {\n            const queue = queuesMap.get(key);\n            if (!queue)\n                continue;\n            queue.shift();\n        }\n    }\n}\n//# sourceMappingURL=state.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { MachineEdgeState } from \"./state.js\";\nexport class MachineResult {\n    descriptor;\n    inputs;\n    missingInputs;\n    opportunities;\n    newOpportunities;\n    state;\n    outputsPromise;\n    pendingOutputs;\n    constructor(descriptor, inputs, missingInputs, opportunities, newOpportunities, state, pendingOutputs) {\n        this.descriptor = descriptor;\n        this.inputs = inputs;\n        this.missingInputs = missingInputs;\n        this.opportunities = opportunities;\n        this.newOpportunities = newOpportunities;\n        this.state = state;\n        this.pendingOutputs = pendingOutputs;\n    }\n    /**\n     * `true` if the machine decided that the node should be skipped, rather than\n     * visited.\n     */\n    get skip() {\n        return this.missingInputs.length > 0;\n    }\n    static fromObject(o) {\n        const edgeState = new MachineEdgeState();\n        edgeState.constants = o.state.constants;\n        edgeState.state = o.state.state;\n        return new MachineResult(o.descriptor, o.inputs, o.missingInputs, o.opportunities, o.newOpportunities, edgeState, o.pendingOutputs);\n    }\n}\n//# sourceMappingURL=result.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Traversal } from \"./index.js\";\nimport { MachineResult } from \"./result.js\";\nexport class TraversalMachineIterator {\n    graph;\n    #current;\n    #noParallelExecution;\n    constructor(graph, result, noParallelExecution = true) {\n        this.graph = graph;\n        this.#current = result;\n        this.#noParallelExecution = noParallelExecution;\n    }\n    static #processCompletedNode(result, completedNodeOutput) {\n        const { promiseId, outputs, newOpportunities } = completedNodeOutput;\n        result.pendingOutputs.delete(promiseId);\n        // If there was an error, ignore all other outputs and hence opportunites.\n        const opportunities = outputs.$error\n            ? newOpportunities.filter((e) => e.out === \"$error\")\n            : newOpportunities;\n        // Process outputs.\n        result.opportunities.push(...opportunities);\n        result.state.wireOutputs(opportunities, outputs);\n        if (outputs.$error) {\n            if (opportunities.length === 0) {\n                // If the node threw an exception and it wasn't routed via $error,\n                // throw it again. This will cause the traversal to stop.\n                throw new Error(\"Uncaught exception in node handler. Catch by wiring up the $error output.\", {\n                    cause: outputs.$error,\n                });\n            }\n            else {\n                globalThis.console.warn(\"Error in node handler, passing to the wired $error output.\", outputs.$error, opportunities);\n            }\n        }\n    }\n    static async processAllPendingNodes(result) {\n        const completed = await Promise.all(result.pendingOutputs.values());\n        completed.forEach((completedNodeOutput) => {\n            TraversalMachineIterator.#processCompletedNode(result, completedNodeOutput);\n        });\n        return result;\n    }\n    async next() {\n        // If there are no missing inputs, let's consume the outputs\n        if (!this.#current.skip) {\n            const { inputs, outputsPromise, newOpportunities, descriptor } = this.#current;\n            // Mark inputs as used, i.e. shift inputs queues.\n            this.#current.state.useInputs(descriptor.id, this.#current.inputs);\n            const promiseId = Symbol();\n            const promise = new Promise((resolve) => {\n                (outputsPromise || Promise.resolve({}))\n                    .then((outputs) => {\n                    // If not already present, add inputs and descriptor along for\n                    // context and to support retries. If $error came from another node,\n                    // the descriptor will remain the original, but new inputs will be\n                    // added, though never overwriting prior ones.\n                    if (outputs.$error) {\n                        const $error = outputs.$error;\n                        outputs.$error = {\n                            descriptor,\n                            ...$error,\n                            inputs: { ...inputs, ...$error.inputs },\n                        };\n                    }\n                    resolve({ promiseId, outputs, newOpportunities });\n                })\n                    .catch((error) => {\n                    // If the handler threw an exception, turn it into a $error output.\n                    // Pass the inputs and descriptor along for context and to support\n                    // retries. This Promise will hence always resolve.\n                    resolve({\n                        promiseId,\n                        outputs: {\n                            $error: {\n                                kind: \"error\",\n                                error,\n                                inputs,\n                                descriptor,\n                            },\n                        },\n                        newOpportunities: newOpportunities.filter((edge) => edge.out === \"$error\"),\n                    });\n                });\n            });\n            this.#current.pendingOutputs.set(promiseId, promise);\n        }\n        // If there are no more opportunites or we've disabled parallel execution,\n        // let's wait for pending nodes to be done\n        while ((this.#current.opportunities.length === 0 || this.#noParallelExecution) &&\n            this.#current.pendingOutputs.size > 0) {\n            // Wait for the first pending node to be done.\n            TraversalMachineIterator.#processCompletedNode(this.#current, await Promise.race(this.#current.pendingOutputs.values()));\n        }\n        // If there are no more opportunities and none are pending, we're done.\n        if (this.#current.opportunities.length === 0)\n            return { done: true, value: null };\n        // Now, we're ready to start the next iteration.\n        // Otherwise, let's pop the next opportunity from the queue.\n        const opportunity = this.#current.opportunities.shift();\n        const { heads, nodes, tails } = this.graph;\n        const toNode = opportunity.to;\n        const currentDescriptor = nodes.get(toNode);\n        if (!currentDescriptor)\n            throw new Error(`No node found for id \"${toNode}\"`);\n        const incomingEdges = heads.get(toNode) || [];\n        const inputs = this.#current.state.getAvailableInputs(toNode);\n        const missingInputs = Traversal.computeMissingInputs(incomingEdges, inputs, currentDescriptor);\n        const newOpportunities = tails.get(toNode) || [];\n        // Pour configuration values into inputs. These are effectively like\n        // constants.\n        const inputsWithConfiguration = {\n            ...currentDescriptor.configuration,\n            ...inputs,\n        };\n        this.#current = new MachineResult(currentDescriptor, inputsWithConfiguration, missingInputs, this.#current.opportunities, newOpportunities, this.#current.state, this.#current.pendingOutputs);\n        return { done: false, value: this.#current };\n    }\n}\n//# sourceMappingURL=iterator.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class GraphRepresentation {\n    /**\n     * Tails: a map of all outgoing edges, keyed by node id.\n     */\n    tails = new Map();\n    /**\n     * Heads: a map of all incoming edges, keyed by node id.\n     */\n    heads = new Map();\n    /**\n     * Nodes: a map of all nodes, keyed by node id.\n     */\n    nodes = new Map();\n    /**\n     * Entries: a list of all nodes that have no incoming edges.\n     */\n    entries = [];\n    constructor(descriptor) {\n        this.tails = descriptor.edges.reduce((acc, edge) => {\n            const from = edge.from;\n            acc.has(from) ? acc.get(from)?.push(edge) : acc.set(from, [edge]);\n            return acc;\n        }, new Map());\n        this.heads = descriptor.edges.reduce((acc, edge) => {\n            const to = edge.to;\n            acc.has(to) ? acc.get(to)?.push(edge) : acc.set(to, [edge]);\n            return acc;\n        }, new Map());\n        this.nodes = descriptor.nodes.reduce((acc, node) => {\n            acc.set(node.id, node);\n            return acc;\n        }, new Map());\n        this.entries = Array.from(this.tails.keys()).filter((node) => !this.heads.has(node) || this.heads.get(node)?.length === 0);\n    }\n}\n//# sourceMappingURL=representation.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachineIterator } from \"./iterator.js\";\nimport { GraphRepresentation } from \"./representation.js\";\nimport { MachineResult } from \"./result.js\";\nimport { MachineEdgeState } from \"./state.js\";\nexport class TraversalMachine {\n    graph;\n    previousResult;\n    constructor(descriptor, result) {\n        this.graph = new GraphRepresentation(descriptor);\n        this.previousResult = result;\n    }\n    [Symbol.asyncIterator]() {\n        return this.start();\n    }\n    start() {\n        if (this.previousResult)\n            return new TraversalMachineIterator(this.graph, this.previousResult);\n        const { entries } = this.graph;\n        if (entries.length === 0)\n            throw new Error(\"No entry node found in graph.\");\n        // Create fake edges to represent entry points.\n        const opportunities = entries.map((entry) => ({\n            from: \"$entry\",\n            to: entry,\n        }));\n        const entryResult = new MachineResult({ id: \"$empty\", type: \"$empty\" }, {}, [], opportunities, [], new MachineEdgeState(), new Map());\n        return new TraversalMachineIterator(this.graph, entryResult);\n    }\n    static async prepareToSave(result) {\n        return await TraversalMachineIterator.processAllPendingNodes(result);\n    }\n}\n//# sourceMappingURL=machine.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TraversalMachine } from \"./traversal/machine.js\";\nimport { MachineResult } from \"./traversal/result.js\";\nexport const replacer = (key, value) => {\n    if (!(value instanceof Map))\n        return value;\n    return { $type: \"Map\", value: Array.from(value.entries()) };\n};\nexport const reviver = (key, value) => {\n    const { $type } = (value || {});\n    return $type == \"Map\" && value.value\n        ? new Map(value.value)\n        : value;\n};\nexport const saveRunnerState = async (type, result) => {\n    const state = await TraversalMachine.prepareToSave(result);\n    return JSON.stringify({ state, type }, replacer);\n};\nexport const loadRunnerState = (s) => {\n    const { state: o, type } = JSON.parse(s, reviver);\n    const state = MachineResult.fromObject(o);\n    return { state, type };\n};\n//# sourceMappingURL=serialization.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { loadRunnerState, saveRunnerState } from \"./serialization.js\";\nimport { timestamp } from \"./timestamp.js\";\nexport class RunResult {\n    #type;\n    #state;\n    // TODO: Remove #state and rename this to #state\n    #runState;\n    // TODO: Remove this once RunState machinery works\n    #invocationId;\n    constructor(state, type, runState, invocationId) {\n        this.#state = state;\n        this.#type = type;\n        this.#runState = runState;\n        this.#invocationId = invocationId;\n    }\n    get invocationId() {\n        return this.#invocationId;\n    }\n    get type() {\n        return this.#type;\n    }\n    get node() {\n        return this.#state.descriptor;\n    }\n    get inputArguments() {\n        return this.#state.inputs;\n    }\n    set inputs(inputs) {\n        this.#state.outputsPromise = Promise.resolve(inputs);\n    }\n    get outputs() {\n        return this.#state.inputs;\n    }\n    get state() {\n        return this.#state;\n    }\n    async save() {\n        return saveRunnerState(this.#type, this.#state);\n    }\n    get runState() {\n        return this.#runState;\n    }\n    get timestamp() {\n        return timestamp();\n    }\n    isAtExitNode() {\n        return (this.#state.newOpportunities.length === 0 &&\n            this.#state.opportunities.length === 0 &&\n            this.#state.pendingOutputs.size === 0);\n    }\n    static load(stringifiedResult) {\n        const { state, type } = loadRunnerState(stringifiedResult);\n        return new RunResult(state, type, undefined, 0);\n    }\n}\nexport class InputStageResult extends RunResult {\n    constructor(state, runState, invocationId) {\n        super(state, \"input\", runState, invocationId);\n    }\n    get outputs() {\n        throw new Error('Outputs are not available in the \"input\" stage');\n    }\n}\nexport class OutputStageResult extends RunResult {\n    constructor(state, invocationId) {\n        super(state, \"output\", undefined, invocationId);\n    }\n    get inputArguments() {\n        throw new Error('Input arguments are not available in the \"output\" stage');\n    }\n    set inputs(inputs) {\n        throw new Error('Setting inputs is not available in the \"output\" stage');\n    }\n}\n//# sourceMappingURL=run.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Diagnostics } from \"../harness/diagnostics.js\";\nimport { RunResult } from \"../run.js\";\nimport { streamsToAsyncIterable, stubOutStreams, } from \"../stream.js\";\nimport { timestamp } from \"../timestamp.js\";\nconst resumeRun = (request) => {\n    const [type, , state] = request;\n    console.log(\"resumeRun\", type, state);\n    // There may not be any state to resume from.\n    if (!state)\n        return undefined;\n    if (state.length > 1) {\n        throw new Error(\"I don't yet know how to resume from nested subgraphs.\");\n    }\n    const result = RunResult.load(state[0].state);\n    if (type === \"input\") {\n        const [, inputs] = request;\n        result.inputs = inputs.inputs;\n    }\n    return result;\n};\nexport class RunServer {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async serve(runner, diagnostics = false, context = {}) {\n        const stream = this.#transport.createServerStream();\n        const requestReader = stream.readableRequests.getReader();\n        let request = await requestReader.read();\n        if (request.done)\n            return;\n        const result = resumeRun(request.value);\n        const responses = stream.writableResponses.getWriter();\n        const servingContext = {\n            ...context,\n            probe: diagnostics\n                ? new Diagnostics(async (message) => {\n                    const { type, data } = message;\n                    const response = [type, stubOutStreams(data)];\n                    if (type == \"nodestart\") {\n                        response.push(message.state);\n                    }\n                    await responses.write(response);\n                })\n                : undefined,\n        };\n        try {\n            for await (const stop of runner.run(servingContext, result)) {\n                if (stop.type === \"input\") {\n                    const state = stop.runState;\n                    const { node, inputArguments, timestamp } = stop;\n                    await responses.write([\n                        \"input\",\n                        { node, inputArguments, timestamp },\n                        state,\n                    ]);\n                    request = await requestReader.read();\n                    if (request.done) {\n                        await responses.close();\n                        return;\n                    }\n                    else {\n                        const [type, inputs] = request.value;\n                        if (type === \"input\") {\n                            stop.inputs = inputs.inputs;\n                        }\n                    }\n                }\n                else if (stop.type === \"output\") {\n                    const { node, outputs, timestamp } = stop;\n                    await responses.write([\"output\", { node, outputs, timestamp }]);\n                }\n            }\n            await responses.write([\"end\", { timestamp: timestamp() }]);\n            await responses.close();\n        }\n        catch (e) {\n            const error = e;\n            let message;\n            if (error?.cause) {\n                const { cause } = error;\n                message = cause;\n            }\n            else {\n                message = error.message;\n            }\n            console.error(\"Run Server error:\", message);\n            await responses.write([\n                \"error\",\n                { error: message, timestamp: timestamp() },\n            ]);\n            await responses.close();\n        }\n    }\n}\nconst createRunResult = (response) => {\n    const [type, data, state] = response.data;\n    const reply = async (chunk) => {\n        if (type !== \"input\") {\n            throw new Error(\"For now, we cannot reply to messages other than 'input'.\");\n        }\n        await response.reply([type, chunk, state]);\n    };\n    return {\n        type,\n        data,\n        state,\n        reply,\n    };\n};\nexport class RunClient {\n    #transport;\n    constructor(clientTransport) {\n        this.#transport = clientTransport;\n    }\n    async *run(state) {\n        const stream = this.#transport.createClientStream();\n        const server = streamsToAsyncIterable(stream.writableRequests, stream.readableResponses);\n        const request = [\"run\", {}];\n        state && request.push(state);\n        await server.start(request);\n        for await (const response of server) {\n            yield createRunResult(response);\n        }\n    }\n    async runOnce(inputs) {\n        let outputs;\n        for await (const stop of this.run()) {\n            const { type, data } = stop;\n            if (type === \"input\") {\n                stop.reply({ inputs });\n            }\n            else if (type === \"output\") {\n                outputs = data.outputs;\n                break;\n            }\n        }\n        return outputs || {};\n    }\n}\n//# sourceMappingURL=run.js.map","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class InitServer {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async serve() {\n        const stream = this.#transport.createServerStream();\n        const reader = stream.readableRequests.getReader();\n        const request = await reader.read();\n        if (request.done) {\n            throw new Error(\"Client closed stream without sending a request.\");\n        }\n        return request.value.url;\n    }\n}\nexport class InitClient {\n    #transport;\n    constructor(transport) {\n        this.#transport = transport;\n    }\n    async load(url) {\n        const stream = this.#transport.createClientStream();\n        const writer = stream.writableRequests.getWriter();\n        await writer.write({ url });\n        await writer.close();\n    }\n}\n//# sourceMappingURL=init.js.map","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const defineConfig = (config) => config;\nexport const hasOrigin = (origin) => ({\n    test: (url) => new URL(url).origin === origin,\n});\n//# sourceMappingURL=config.js.map"],"names":["STREAM_KIND","StreamCapability","kind","stream","constructor","this","stringifyWithStreams","value","foundStreams","JSON","stringify","key","object","maybeStream","ReadableStream","isStreamCapability","push","$type","id","length","streams","parseWithStreams","getStream","parsed","parse","stubOutStreams","data","stringified","portToStreams","port","readable","start","controller","onmessage","ev","enqueue","close","cancel","writable","WritableStream","write","chunk","postMessage","WritableResult","writer","reply","StreamsAsyncIterator","reader","getReader","getWriter","next","done","read","undefined","err","abort","streamsToAsyncIterable","releaseLock","Symbol","asyncIterator","patchReadableStream","prototype","async","HTTPServerTransport","request","response","createServerStream","header","readableRequests","o","body","iterator","error","Error","writableResponses","pipeTo","end","HTTPClientTransport","url","options","fetch","method","headers","globalThis","bind","createClientStream","responseResolve","responsePromise","Promise","resolve","that","readableResponses","pull","result","console","log","writableRequests","ok","status","pipeThrough","TextDecoderStream","queue","TransformStream","transform","brokenChunk","endsWith","chunks","split","filter","Boolean","join","shift","lastChunk","flush","chunkRepairTransform","startsWith","slice","siphon","type","Array","isArray","parseWithStreamsTransform","DISPATCHER_SEND","PortDispatcher","worker","waitForSender","Map","pool","addEventListener","event","waiting","get","delete","set","receive","pooledPort","portFactory","streamsAvailable","then","reason","portFactoryToStreams","send","port1","port2","MessageChannel","WorkerClientTransport","highWaterMark","WorkerServerTransport","clientStreams","callHandler","handler","inputs","context","handlerFunction","Function","invoke","getHandlerFunction","catch","$error","KitBuilder","title","description","version","namespacePrefix","addPrefix","handlers","Object","keys","reduce","acc","build","prefix","prefixedHandlers","nodes","nodeFactory","proxy","Proxy","target","prop","includes","configOrLambda","config","getConfigWithLambda","$id","rest","create","wrap","params","functions","entries","previous","current","name","fn","argNames","toString","match","argName","trim","args","map","lastArgName","results","atob","process","str","Buffer","from","btoa","NodeTunnel","outputName","to","when","getInputNames","inputNames","matches","every","inputName","inputValue","test","readNodeSpec","node","spec","fromEntries","v","TUNNEL_HASH","Math","round","Date","now","TUNNEL_PREFIX","TUNNEL_SUFFIX","SPLIT_REGEX","RegExp","TUNNEL_REGEX","replaceTunnelledInputs","input","allow","replacer","json","parts","part","nodeType","encodedInputs","all","outputs","jsonString","createTunnelKit","outputWrappedHandlers","nodeTunnels","tunnels","replaceOutputs","memoize","replace","getTunnelValue","destinations","flatMap","_","tunnel","createDestinationMap","inputWrappedHandlers","destinationTunnels","some","replaceInputs","timestamp","performance","getHandlerConfig","handlerConfig","find","arg","ProxyServer","transport","serve","kits","tunnelKit","readConfig","kit","handlersFromKits","descriptor","e","message","ProxyClient","shutdownServer","createProxyKit","nodesToProxy","proxiedNodes","Diagnostics","EventTarget","callback","super","report","Traversal","computeMissingInputs","heads","requiredInputs","Set","edge","in","optional","inputsWithConfiguration","forEach","add","configuration","has","MachineEdgeState","state","constants","queueOutput","queuesMap","wireOutputs","opportunites","opportunity","out","constant","output","getAvailableInputs","nodeId","useInputs","MachineResult","missingInputs","opportunities","newOpportunities","outputsPromise","pendingOutputs","skip","fromObject","edgeState","TraversalMachineIterator","graph","noParallelExecution","processCompletedNode","completedNodeOutput","promiseId","cause","warn","processAllPendingNodes","values","promise","size","race","tails","toNode","currentDescriptor","incomingEdges","GraphRepresentation","edges","TraversalMachine","previousResult","entry","entryResult","prepareToSave","reviver","RunResult","runState","invocationId","inputArguments","save","saveRunnerState","isAtExitNode","load","stringifiedResult","s","loadRunnerState","RunServer","runner","diagnostics","requestReader","resumeRun","responses","servingContext","probe","stop","run","createRunResult","RunClient","clientTransport","server","runOnce","InitServer","InitClient","defineConfig","hasOrigin","origin","URL"],"mappings":"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"}