/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { ReduceInputs, ReduceOutputs } from "./nodes/reduce.js";
export declare const Core: import("@google-labs/breadboard").KitConstructor<import("@google-labs/breadboard").GenericKit<{
    /**
     * Places an `import` node on the board.
     *
     * Use this node to import other boards into the current board.
     * Outputs `board` as a BoardCapability, which can be passed to e.g. `invoke`.
     *
     * The config param expects either `path` or `graph` as a string or
     * `GraphDescriptor', respectively.
     *
     * @param config - optional configuration for the node.
     * @returns - a `Node` object that represents the placed node.
     */
    import: {
        describe: (inputs?: import("@google-labs/breadboard").InputValues | undefined) => Promise<{
            inputSchema: import("@google-labs/breadboard").Schema;
            outputSchema: import("@google-labs/breadboard").SchemaBuilder;
        }>;
        invoke: (inputs: import("@google-labs/breadboard").InputValues, context: import("@google-labs/breadboard").NodeHandlerContext) => Promise<import("@google-labs/breadboard").LambdaNodeOutputs>;
    };
    /**
     * Places an `include` node on the board.
     *
     * Use this node to include other boards into the current board.
     *
     * The `include` node acts as a sort of instant board-to-node converter: just
     * give it the URL of a serialized board, and it will pretend as if that whole
     * board is just one node.
     *
     * See [`include` node
     * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#include)
     * for more information.
     *
     * @param $ref - the URL of the board to include, or a graph or a
     *   BreadboardCapability returned by e.g. lambda.
     * @param config - optional configuration for the node.
     * @returns - a `Node` object that represents the placed node.
     */
    include: {
        describe: (inputs?: import("@google-labs/breadboard").InputValues | undefined) => Promise<{
            inputSchema: import("@google-labs/breadboard").Schema;
            outputSchema: import("@google-labs/breadboard").Schema;
        }>; /**
         * Places an `include` node on the board.
         *
         * Use this node to include other boards into the current board.
         *
         * The `include` node acts as a sort of instant board-to-node converter: just
         * give it the URL of a serialized board, and it will pretend as if that whole
         * board is just one node.
         *
         * See [`include` node
         * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#include)
         * for more information.
         *
         * @param $ref - the URL of the board to include, or a graph or a
         *   BreadboardCapability returned by e.g. lambda.
         * @param config - optional configuration for the node.
         * @returns - a `Node` object that represents the placed node.
         */
        invoke: (inputs: import("@google-labs/breadboard").InputValues, context: import("@google-labs/breadboard").NodeHandlerContext) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    };
    /**
     * Places an `invoke` node on the board.
     *
     * Use this node to invoke other boards into the current board.
     *
     * See [`include` node
     * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#include)
     * for more information.
     *
     * Expects as input one of
     *  - `path`: A board to be loaded
     *  - `graph`: A graph (treated as JSON)
     *  - `board`: A {BreadboardCapability}, e.g. from lambda or import
     *
     * All other inputs are passed to the invoked board,
     * and the output are the invoked board's outputs.
     *
     * @param config - optional configuration for the node.
     * @returns - a `Node` object that represents the placed node.
     */
    invoke: {
        describe: (inputs?: import("@google-labs/breadboard").InputValues | undefined) => Promise<{
            inputSchema: import("@google-labs/breadboard").Schema;
            outputSchema: import("@google-labs/breadboard").Schema;
        }>; /**
         * Places the `passthrough` node on the board.
         *
         * A `passthrough` node is a node that simply passes its inputs to
         * its outputs. Every computing machine needs a no-op node,
         * and Breadboard library is no exception.
         *
         * See [`passthrough` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#passthrough) for more information.
         *
         * @param config - optional configuration for the node.
         * @returns - a `Node` object that represents the placed node.
         */
        invoke: (inputs: import("@google-labs/breadboard").InputValues, context: import("@google-labs/breadboard").NodeHandlerContext) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    };
    /**
     * Places the `passthrough` node on the board.
     *
     * A `passthrough` node is a node that simply passes its inputs to
     * its outputs. Every computing machine needs a no-op node,
     * and Breadboard library is no exception.
     *
     * See [`passthrough` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#passthrough) for more information.
     *
     * @param config - optional configuration for the node.
     * @returns - a `Node` object that represents the placed node.
     */
    passthrough: {
        desribe: (inputs?: import("@google-labs/breadboard").InputValues | undefined) => Promise<{
            inputSchema: import("@google-labs/breadboard").Schema;
            outputSchema: import("@google-labs/breadboard").Schema;
        }>;
        invoke: (inputs: import("@google-labs/breadboard").InputValues) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    };
    /**
     * Places a `reflect` node on the board.
     *
     * This node is used to reflect the board itself. It provides a JSON
     * representation of the board as a `graph` output property. This can be
     * used for studying the board's structure from inside the board.
     *
     * See [`reflect` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#reflect) for more information.
     *
     * @param config - optional configuration for the node.
     * @returns - a `Node` object that represents the placed node.
     */
    reflect: {
        desribe: () => Promise<{
            inputSchema: import("@google-labs/breadboard").Schema;
            outputSchema: import("@google-labs/breadboard").Schema;
        }>;
        invoke: (_inputs: import("@google-labs/breadboard").InputValues, context: import("@google-labs/breadboard").NodeHandlerContext) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    };
    /**
     * Places a `slot` node on the board.
     *
     * This node is used to provide a slot for another board to be placed into.
     *
     * This type of node is useful for situations where we wish to leave
     * a place in the board where anyone could insert other boards.
     *
     * Programmers call it "dependency injection".
     *
     * See [`slot` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#slot) for more information.
     *
     * @param config - optional configuration for the node.
     * @returns - a `Node` object that represents the placed node.
     */
    slot: {
        describe: (inputs?: import("@google-labs/breadboard").InputValues | undefined) => Promise<{
            inputSchema: import("@google-labs/breadboard").Schema;
            outputSchema: import("@google-labs/breadboard").Schema;
        }>;
        invoke: (inputs: import("@google-labs/breadboard").InputValues, context: import("@google-labs/breadboard").NodeHandlerContext) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    };
    /**
     * Use this node to accumulate local state, like context in a prompt.
     *
     * The node looks for property called `accumulator` in its input. All other
     * properties are appended to this property, and returned as `accumulator`
     * output property.
     *
     * The way the properties are appended depends on the type of the
     * `accumulator` input property.
     *
     * If the `accumulator` property is "string-ey" (that is, it's a `string`,
     * `number`, `boolean`, `bigint`, `null` or `undefined`), the properties will
     * be appended as strings, formatted as
     * `{{property_name}}: {{proprety_value}}` and joined with "`\n`".
     *
     * If the `accumulator` property is an array, the properties will be appended
     * as array items, formatted as `{{property_name}}: {{proprety_value}}`.
     *
     * Otherwise, the `accumulator` property will be treated as an object and
     * the properties will be added as properties on this object.
     *
     * See [`append` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/core-kit/README.md) for more information.
     *
     */
    append: {
        describe: import("@google-labs/breadboard").NodeDescriberFunction;
        invoke: (inputs: import("@google-labs/breadboard").InputValues) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    };
    /**
     * Work-in-progress implementation of the `map` node.
     * See #127 for more information.
     */
    map: (inputs: import("@google-labs/breadboard").InputValues, context?: import("@google-labs/breadboard").NodeHandlerContext | undefined) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    reduce: (inputs: import("@google-labs/breadboard").InputValues, context?: import("@google-labs/breadboard").NodeHandlerContext | undefined) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    batch: (inputs: import("@google-labs/breadboard").InputValues) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    fetch: {
        describe: import("@google-labs/breadboard").NodeDescriberFunction;
        invoke: (inputs: import("@google-labs/breadboard").InputValues) => Promise<{
            $error: any;
            stream?: undefined;
            response?: undefined;
        } | {
            stream: import("@google-labs/breadboard").StreamCapability<any>;
            $error?: undefined;
            response?: undefined;
        } | {
            response: any;
            $error?: undefined;
            stream?: undefined;
        }>;
    };
    runJavascript: {
        describe: import("@google-labs/breadboard").NodeDescriberFunction;
        invoke: import("@google-labs/breadboard").NodeHandlerFunction;
    };
    secrets: {
        describe: import("@google-labs/breadboard").NodeDescriberFunction;
        invoke: (inputs: import("@google-labs/breadboard").InputValues) => Promise<Partial<Record<string, import("@google-labs/breadboard").NodeValue>>>;
    };
}>>;
export type Core = InstanceType<typeof Core>;
export default Core;
/**
 * This is a wrapper around existing kits for the new syntax to add types.
 *
 * This should transition to a codegen step, with typescript types constructed
 * from .describe() calls.
 */
import { NewNodeValue as NodeValue, NewInputValues as InputValues, NewOutputValues as OutputValues, NewNodeFactory as NodeFactory } from "@google-labs/breadboard";
export type CoreKitType = {
    passthrough: NodeFactory<InputValues, OutputValues>;
    /**
     * Creates the `append` node, which can be used to accumulate local state,
     * like context in a prompt.
     *
     * The node looks for property called `accumulator` in its input. All other
     * properties are appended to this property, and returned as `accumulator`
     * output property.
     *
     * The way the properties are appended depends on the type of the
     * `accumulator` input property.
     *
     * If the `accumulator` property is "string-ey" (that is, it's a `string`,
     * `number`, `boolean`, `bigint`, `null` or `undefined`), the properties will
     * be appended as strings, formatted as
     * `{{property_name}}: {{proprety_value}}` and joined with "`\n`".
     *
     * If the `accumulator` property is an array, the properties will be appended
     * as array items, formatted as `{{property_name}}: {{proprety_value}}`.
     *
     * Otherwise, the `accumulator` property will be treated as an object and
     * the properties will be added as properties on this object.
     *
     * See [`append` node reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/core-kit/README.md) for more information.
     *
     */
    append: NodeFactory<{
        accumulator: NodeValue;
        [key: string]: NodeValue;
    }, {
        accumulator: NodeValue;
    }>;
    /**
     * Creates an `invoke` node, which can be used invoke other boards within
     * the current board.
     *
     * See [`include` node
     * reference](https://github.com/breadboard-ai/breadboard/blob/main/packages/breadboard/docs/nodes.md#include)
     * for more information.
     *
     * Expects as input one of
     *  - `path`: A board to be loaded
     *  - `graph`: A graph (treated as JSON)
     *  - `board`: A {BreadboardCapability}, e.g. from lambda or import
     *
     * All other inputs are passed to the invoked board,
     * and the output are the invoked board's outputs.
     */
    invoke: NodeFactory<{
        /**
         * The URL to the board to be invoked.
         */
        path: string;
        [key: string]: NodeValue;
    } | {
        /**
         * A string of the serailized graph to be invoked.
         */
        graph: string;
        [key: string]: NodeValue;
    } | {
        /**
         * A board to be invoked.
         */
        board: NodeValue;
        [key: string]: NodeValue;
    }, {
        [key: string]: unknown;
    }>;
    map: NodeFactory<{
        list: NodeValue[];
        board?: NodeValue;
    }, {
        list: NodeValue[];
    }>;
    reduce: NodeFactory<ReduceInputs, ReduceOutputs>;
    fetch: NodeFactory<{
        url: string;
    }, {
        response: string;
    }>;
    runJavascript: NodeFactory<{
        code: string;
        name: string;
        raw: boolean;
        [key: string]: NodeValue;
    }, {
        result: unknown;
        [k: string]: unknown;
    }>;
    secrets: NodeFactory<{
        keys: string[];
    }, {
        [k: string]: string;
    }>;
};
/**
 * The Core Kit. Use members of this object to create nodes to enable
 * composition and reuse of in Breadboard. The most useful node is `invoke`,
 * which allows you to invoke other boards within the current board.
 * Another useful one is `map`, which allows you to map over a list of items
 * and invoke a board for each item.
 */
export declare const core: CoreKitType;
//# sourceMappingURL=index.d.ts.map