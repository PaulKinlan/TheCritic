/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
export var ObjectType;
(function (ObjectType) {
    ObjectType[ObjectType["stringy"] = 0] = "stringy";
    ObjectType[ObjectType["array"] = 1] = "array";
    ObjectType[ObjectType["object"] = 2] = "object";
})(ObjectType || (ObjectType = {}));
export const getObjectType = (value) => {
    if (value === null || value === undefined)
        return ObjectType.stringy;
    const type = typeof value;
    if (["string", "number", "boolean", "bigint"].includes(type))
        return ObjectType.stringy;
    if (Array.isArray(value))
        return ObjectType.array;
    return ObjectType.object;
};
const asString = (values) => {
    if (getObjectType(values) == ObjectType.stringy)
        return String(values);
    return Object.entries(values)
        .map(([k, v]) => {
        const value = getObjectType(v) === ObjectType.stringy ? v : JSON.stringify(v);
        return `${k}: ${value}`;
    })
        .join("\n");
};
export const computeInputSchema = (incomingWires) => {
    const properties = {
        accumulator: {
            title: "accumulator",
            description: "A string, an object, or an array to which other input values will be appended.",
            type: ["array", "object", "string"],
            items: { type: "string" },
        },
    };
    const inputSchema = { properties, additionalProperties: true };
    if (!incomingWires.properties)
        return inputSchema;
    Object.entries(incomingWires.properties).forEach(([propertyName, schema]) => {
        properties[propertyName] = schema;
    });
    return inputSchema;
};
export const flattenValues = (values) => {
    let result = {};
    Object.entries(values).forEach(([key, value]) => {
        if (key === "$flatten" && getObjectType(value) == ObjectType.object) {
            result = { ...result, ...value };
        }
        else {
            result[key] = value;
        }
    });
    return result;
};
export const appendDescriber = async (_inputs, incomingWires) => {
    const inputSchema = computeInputSchema(incomingWires || {});
    return {
        inputSchema,
        outputSchema: {
            properties: {
                accumulator: {
                    title: "accumulator",
                    description: "The result of appending. This is input `accumulator` with the provided values appended to it.",
                },
            },
        },
    };
};
export default {
    describe: appendDescriber,
    invoke: async (inputs) => {
        const { accumulator, ...values } = inputs;
        if (Object.keys(values).length === 0)
            return { accumulator };
        const type = getObjectType(accumulator);
        switch (type) {
            case ObjectType.stringy: {
                const stringy = accumulator === null || accumulator === undefined
                    ? ""
                    : `${accumulator}\n`;
                return { accumulator: `${stringy}${asString(values)}` };
            }
            case ObjectType.array: {
                const flattenedValues = flattenValues(values);
                return {
                    accumulator: [...accumulator, flattenedValues],
                };
            }
            case ObjectType.object:
                return {
                    accumulator: {
                        ...accumulator,
                        ...values,
                    },
                };
        }
    },
};
//# sourceMappingURL=append.js.map